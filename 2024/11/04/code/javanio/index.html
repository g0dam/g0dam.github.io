<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Java NIO（New Input&#x2F;Output）是Java 1.4中引入的一套新的I&#x2F;O API，旨在提供比传统Java I&#x2F;O更高效的I&#x2F;O操作。它通过非阻塞模式、通道（Channels）、缓冲区（Buffers）等机制，增强了Java处理高并发和大数据量时的性能，尤其适合需要高吞吐量的网络应用开发。 1. Java NIO 核心概念NIO（New">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java开发】Java NIO">
<meta property="og:url" content="https://godreams.cn/2024/11/04/code/javanio/index.html">
<meta property="og:site_name" content="g0dam">
<meta property="og:description" content="Java NIO（New Input&#x2F;Output）是Java 1.4中引入的一套新的I&#x2F;O API，旨在提供比传统Java I&#x2F;O更高效的I&#x2F;O操作。它通过非阻塞模式、通道（Channels）、缓冲区（Buffers）等机制，增强了Java处理高并发和大数据量时的性能，尤其适合需要高吞吐量的网络应用开发。 1. Java NIO 核心概念NIO（New">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-1.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-2.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-3.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-4.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-5.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-6.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-7.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-8.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-9.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-10.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-11.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-12.png">
<meta property="og:image" content="https://godreams.cn/2024/11/04/code/javanio/image-13.png">
<meta property="article:published_time" content="2024-11-04T05:49:36.000Z">
<meta property="article:modified_time" content="2024-12-16T05:19:59.954Z">
<meta property="article:author" content="g0dam">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://godreams.cn/2024/11/04/code/javanio/image.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>【Java开发】Java NIO</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="g0dam" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/idea/">Idea</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/11/05/WebSecurity/codeaudit/javacodesqlinjection/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/11/01/WebSecurity/codeaudit/randomfileread/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://godreams.cn/2024/11/04/code/javanio/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://godreams.cn/2024/11/04/code/javanio/&text=【Java开发】Java NIO"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://godreams.cn/2024/11/04/code/javanio/&is_video=false&description=【Java开发】Java NIO"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【Java开发】Java NIO&body=Check out this article: https://godreams.cn/2024/11/04/code/javanio/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://godreams.cn/2024/11/04/code/javanio/&name=【Java开发】Java NIO&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://godreams.cn/2024/11/04/code/javanio/&t=【Java开发】Java NIO"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-NIO-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1. Java NIO 核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">2. 主要特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java-NIO-%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">3. Java NIO 中的核心类和接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java-NIO-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">4. Java NIO 的操作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">5. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Java-NIO%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">6. Java NIO的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-%E5%92%8C%E4%BC%A0%E7%BB%9F-IO-%E5%9C%A8%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">6.1.</span> <span class="toc-text">NIO 和传统 IO 在操作文件时的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-%E5%92%8C%E4%BC%A0%E7%BB%9F-IO-%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">6.2.</span> <span class="toc-text">NIO 和传统 IO 在网络传输中的差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E3%80%81BIO%E5%92%8CAIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">NIO、BIO和AIO的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8CChannel%E9%80%9A%E9%81%93"><span class="toc-number">8.</span> <span class="toc-text">Buffer缓冲区和Channel通道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">8.1.</span> <span class="toc-text">Buffer 缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-%E9%80%9A%E9%81%93"><span class="toc-number">8.2.</span> <span class="toc-text">Channel 通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%80%9A%E9%81%93-FileChannel"><span class="toc-number">8.2.1.</span> <span class="toc-text">文件通道 FileChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">8.2.2.</span> <span class="toc-text">直接与非直接缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%96%87%E4%BB%B6%E9%80%9A%E9%81%93-AsynchronousFileChannel"><span class="toc-number">8.2.3.</span> <span class="toc-text">异步文件通道 AsynchronousFileChannel</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-NIO-%E4%B8%AD%E7%9A%84Paths-%E5%92%8C-Files"><span class="toc-number">9.</span> <span class="toc-text">Java NIO 中的Paths 和 Files</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Paths-%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">1. Paths 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Files-%E7%B1%BB"><span class="toc-number">9.1.1.</span> <span class="toc-text">2. Files 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Files-walkFileTree-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.2.</span> <span class="toc-text">Files.walkFileTree() 静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">9.1.3.</span> <span class="toc-text">搜索文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">10.</span> <span class="toc-text">NIO实现网络聊天室</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scatter-%E5%92%8C-Gather"><span class="toc-number">10.1.</span> <span class="toc-text">Scatter 和 Gather</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E9%81%93-AsynchronousSocketChannel-%E5%92%8C-AsynchronousServerSocketChannel"><span class="toc-number">10.2.</span> <span class="toc-text">异步套接字通道 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%BB%A3%E7%A0%81"><span class="toc-number">10.3.</span> <span class="toc-text">简单聊天室代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">Java IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8"><span class="toc-number">11.2.</span> <span class="toc-text">信号驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-IO"><span class="toc-number">11.3.</span> <span class="toc-text">异步 IO</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        【Java开发】Java NIO
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">g0dam</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-11-04T05:49:36.000Z" class="dt-published" itemprop="datePublished">2024-11-04</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Code/">Code</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Java/" rel="tag">Java</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p><img src="/2024/11/04/code/javanio/image.png"></p>
<p>Java NIO（New Input&#x2F;Output）是Java 1.4中引入的一套新的I&#x2F;O API，旨在提供比传统Java I&#x2F;O更高效的I&#x2F;O操作。它通过非阻塞模式、通道（Channels）、缓冲区（Buffers）等机制，增强了Java处理高并发和大数据量时的性能，尤其适合需要高吞吐量的网络应用开发。</p>
<h2 id="1-Java-NIO-核心概念"><a href="#1-Java-NIO-核心概念" class="headerlink" title="1. Java NIO 核心概念"></a>1. <strong>Java NIO 核心概念</strong></h2><p>NIO（New I&#x2F;O）的设计目标是解决传统 I&#x2F;O（BIO，Blocking I&#x2F;O）在处理大量并发连接时的性能瓶颈。传统 I&#x2F;O 在网络通信中主要使用阻塞式 I&#x2F;O，为每个连接分配一个线程。当连接数量增加时，系统性能将受到严重影响，线程资源成为关键瓶颈。而 NIO 提供了非阻塞 I&#x2F;O 和 I&#x2F;O 多路复用，可以在单个线程中处理多个并发连接，从而在网络传输中显著提高性能。</p>
<ul>
<li><p><strong>Channel（通道）</strong>：NIO中的通道类似于传统I&#x2F;O中的“流”，但不同的是通道是双向的，可以用于读取、写入或者同时执行这两种操作。常见的通道类型包括<code>FileChannel</code>、<code>SocketChannel</code>、<code>ServerSocketChannel</code>、<code>DatagramChannel</code>等。</p>
</li>
<li><p><strong>Buffer（缓冲区）</strong>：缓冲区是NIO中用于存储数据的容器。与传统I&#x2F;O的直接读写数据不同，NIO通过先将数据写入缓冲区，再由缓冲区发送到通道，或从通道中读取数据放入缓冲区。这种机制使得数据可以被更有效地管理。常见的缓冲区有<code>ByteBuffer</code>、<code>CharBuffer</code>、<code>IntBuffer</code>等，支持多种基本数据类型。</p>
</li>
<li><p><strong>Selector（选择器）</strong>：选择器用于管理多个通道，允许单线程处理多个通道的事件（如连接请求、读写操作等），实现非阻塞I&#x2F;O的多路复用。它使得一个线程可以监听多个通道的状态（如读、写、连接等），从而避免了每个连接一个线程的资源开销。</p>
</li>
</ul>
<h2 id="2-主要特性"><a href="#2-主要特性" class="headerlink" title="2. 主要特性"></a>2. <strong>主要特性</strong></h2><ul>
<li><p><strong>非阻塞I&#x2F;O</strong>：传统I&#x2F;O是阻塞的，比如当执行<code>read()</code>时，程序会一直等待直到数据完全读取。而NIO允许非阻塞操作，线程在执行I&#x2F;O操作时无需等待，可以继续执行其他任务。这对于需要处理大量并发请求的服务器应用非常有用。</p>
</li>
<li><p><strong>多路复用</strong>：通过<code>Selector</code>，Java NIO支持单线程管理多个通道的连接请求，这种技术称为“多路复用”（Multiplexing）。相比传统的“一个请求一个线程”模式，NIO的多路复用可以显著减少线程开销。</p>
</li>
</ul>
<h2 id="3-Java-NIO-中的核心类和接口"><a href="#3-Java-NIO-中的核心类和接口" class="headerlink" title="3. Java NIO 中的核心类和接口"></a>3. <strong>Java NIO 中的核心类和接口</strong></h2><ul>
<li><p><strong>ByteBuffer</strong>：这是NIO中最常用的缓冲区类，主要用于字节存储。<code>ByteBuffer</code>支持直接缓冲区（Direct Buffer）和非直接缓冲区。直接缓冲区在Java堆外直接分配内存，与操作系统底层的I&#x2F;O操作更加接近，适合大数据的快速传输。</p>
</li>
<li><p><strong>FileChannel</strong>：用于文件的通道，通过<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>RandomAccessFile</code>等获取。<code>FileChannel</code>可以从文件中读取数据或写入数据，还支持内存映射文件（MappedByteBuffer）等高效操作。</p>
</li>
<li><p><strong>SocketChannel、ServerSocketChannel、DatagramChannel</strong>：这些通道用于网络通信。<code>SocketChannel</code>可以用于TCP客户端，<code>ServerSocketChannel</code>用于TCP服务器，而<code>DatagramChannel</code>用于UDP通信。</p>
</li>
<li><p><strong>Selector</strong>：<code>Selector</code>通过<code>select()</code>方法监听多个通道的事件（如读、写、连接等），并返回已准备就绪的通道。这种机制极大地提高了服务器的并发性能。</p>
</li>
</ul>
<h2 id="4-Java-NIO-的操作流程"><a href="#4-Java-NIO-的操作流程" class="headerlink" title="4. Java NIO 的操作流程"></a>4. <strong>Java NIO 的操作流程</strong></h2><p>使用Java NIO进行非阻塞I&#x2F;O的流程通常如下：</p>
<ol>
<li><strong>创建通道</strong>：打开一个通道，例如<code>FileChannel</code>或<code>SocketChannel</code>。</li>
<li><strong>配置缓冲区</strong>：为通道创建一个或多个缓冲区，用于存储数据。</li>
<li><strong>写入或读取数据</strong>：将数据写入缓冲区或从缓冲区读取数据，通过通道传输。</li>
<li><strong>非阻塞模式与选择器</strong>：将通道配置为非阻塞模式，将通道注册到选择器上，通过选择器监听并处理多个通道的事件。</li>
<li><strong>事件处理</strong>：通过选择器的<code>select()</code>方法获取就绪的通道集合，根据不同事件执行相应的操作（读、写、连接等）。</li>
</ol>
<h2 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. <strong>代码示例</strong></h2><p>以下是一个简单的NIO示例，展示如何使用<code>Selector</code>和<code>SocketChannel</code>处理非阻塞网络通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();  <span class="comment">// 创建选择器</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        serverSocket.configureBlocking(<span class="literal">false</span>);  <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        serverSocket.register(selector, SelectionKey.OP_ACCEPT);  <span class="comment">// 注册选择器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();  <span class="comment">// 阻塞直到有事件触发</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                keys.remove();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;  <span class="comment">// 处理连接请求</span></span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">                    client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);  <span class="comment">// 注册读事件</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;  <span class="comment">// 处理读请求</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line">                    client.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Received message: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()).trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中：</p>
<ul>
<li>创建了一个<code>Selector</code>用于管理多个通道。</li>
<li>通过<code>ServerSocketChannel</code>建立服务器套接字，并设置为非阻塞模式。</li>
<li>将通道注册到选择器上，监听<code>OP_ACCEPT</code>（连接请求）事件。</li>
<li>选择器等待事件触发，通过迭代处理每个就绪的<code>SelectionKey</code>，实现非阻塞I&#x2F;O。</li>
</ul>
<h2 id="6-Java-NIO的优缺点"><a href="#6-Java-NIO的优缺点" class="headerlink" title="6. Java NIO的优缺点"></a>6. <strong>Java NIO的优缺点</strong></h2><p>传统 IO 基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，以及使用 Socket 和 ServerSocket 进行网络传输。<br>NIO 使用通道（Channel）和缓冲区（Buffer）进行文件操作，以及使用 SocketChannel 和 ServerSocketChannel 进行网络传输。<br>传统 IO 采用阻塞式模型，对于每个连接，都需要创建一个独立的线程来处理读写操作。当一个线程在等待 I&#x2F;O 操作时，无法执行其他任务。这会导致大量线程的创建和销毁，以及上下文切换，降低了系统性能。<br>NIO 使用非阻塞模型，允许线程在等待 I&#x2F;O 时执行其他任务。这种模式通过使用选择器（Selector）来监控多个通道（Channel）上的 I&#x2F;O 事件，实现了更高的性能和可伸缩性。</p>
<p>以下是 NIO 在网络传输中优于传统 I&#x2F;O 的原因：<br>①、NIO 支持非阻塞 I&#x2F;O，这意味着在执行 I&#x2F;O 操作时，线程不会被阻塞。这使得在网络传输中可以有效地管理大量并发连接（数千甚至数百万）。而在操作文件时，这个优势没有那么明显，因为文件读写通常不涉及大量并发操作。<br>②、NIO 支持 I&#x2F;O 多路复用，这意味着一个线程可以同时监视多个通道（如套接字），并在 I&#x2F;O 事件（如可读、可写）准备好时处理它们。这大大提高了网络传输中的性能，因为单个线程可以高效地管理多个并发连接。操作文件时这个优势也无法提现出来。<br>③、NIO 提供了 ByteBuffer 类，可以高效地管理缓冲区。这在网络传输中很重要，因为数据通常是以字节流的形式传输。操作文件的时候，虽然也有缓冲区，但优势仍然不够明显。</p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>高性能：支持非阻塞I&#x2F;O和多路复用，大大减少了线程开销和阻塞时间。</li>
<li>更适合网络编程：NIO的结构适合开发高并发的网络应用程序，特别是I&#x2F;O密集型服务。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>开发复杂度高：与传统I&#x2F;O相比，NIO的编程复杂度更高，需要处理选择器、缓冲区等。</li>
<li>适用场景有限：适合I&#x2F;O密集型应用，但对CPU密集型应用的性能提升有限。</li>
</ul>
</li>
</ul>
<h3 id="NIO-和传统-IO-在操作文件时的差异"><a href="#NIO-和传统-IO-在操作文件时的差异" class="headerlink" title="NIO 和传统 IO 在操作文件时的差异"></a>NIO 和传统 IO 在操作文件时的差异</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 使用传统 I/O 方法传输文件</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">long</span> <span class="title function_">transferFile</span><span class="params">(File source, File des)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!des.exists())</span><br><span class="line">            des.createNewFile();</span><br><span class="line">        <span class="comment">// 创建输入输出流</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(des));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用数组传输数据</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 NIO 方式传输文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">transferFileWithNIO</span><span class="params">(File source, File des)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!des.exists())</span><br><span class="line">            des.createNewFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建随机存取文件对象</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(source, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(des, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> read.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">writeChannel</span> <span class="operator">=</span> write.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并使用ByteBuffer 传输数据</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span>(readChannel.read(byteBuffer) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            writeChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件通道</span></span><br><span class="line">        writeChannel.close();;</span><br><span class="line">        readChannel.close();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">transferfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="type">File</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/dell/下载/Clash.for.Windows-0.20.35-win.7z&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">des</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.7z&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">nio</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b.7z&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> transferfile.transferFile(source, des);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;普通字节流时间&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeNio</span> <span class="operator">=</span> transferfile.transferFileWithNIO(source, nio);</span><br><span class="line">        System.out.println(timeNio + <span class="string">&quot;NIO时间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="/2024/11/04/code/javanio/image-1.png"><br>文件越大的情况下，竟然普通字节流（传统 IO）的速度更快,NIO的魅力主要是在网络当中</p>
<h3 id="NIO-和传统-IO-在网络传输中的差异"><a href="#NIO-和传统-IO-在网络传输中的差异" class="headerlink" title="NIO 和传统 IO 在网络传输中的差异"></a>NIO 和传统 IO 在网络传输中的差异</h3><p>IO，用的套接字，其中<br>Socket 和 ServerSocket 是传统的阻塞式 I&#x2F;O 编程方式，用于建立和管理 TCP 连接。<br>Socket：表示客户端套接字，负责与服务器端建立连接并进行数据的读写。<br>ServerSocket：表示服务器端套接字，负责监听客户端连接请求。当有新的连接请求时，ServerSocket 会创建一个新的 Socket 实例，用于与客户端进行通信。<br>在传统阻塞式 I&#x2F;O 编程中，每个连接都需要一个单独的线程进行处理，这导致了在高并发场景下的性能问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOSever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">                </span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> in.read(buffer);</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">                </span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                client.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NIO，为了解决传统阻塞式 I&#x2F;O 的性能问题，Java NIO 引入了 ServerSocketChannel 和 SocketChannel。它们是非阻塞 I&#x2F;O，可以在单个线程中处理多个连接。<br>ServerSocketChannel：类似于 ServerSocket，表示服务器端套接字通道。它负责监听客户端连接请求，并可以设置为非阻塞模式，这意味着在等待客户端连接请求时不会阻塞线程。<br>SocketChannel：类似于 Socket，表示客户端套接字通道。它负责与服务器端建立连接并进行数据的读写。SocketChannel 也可以设置为非阻塞模式，在读写数据时不会阻塞线程。</p>
<p>Selector 是 Java NIO 中的一个关键组件，用于实现 I&#x2F;O 多路复用。它允许在单个线程中同时监控多个 ServerSocketChannel 和 SocketChannel，并通过 SelectionKey 标识关注的事件。当某个事件发生时，Selector 会将对应的 SelectionKey 添加到已选择的键集合中。通过使用 Selector，可以在单个线程中同时处理多个连接，从而有效地提高 I&#x2F;O 操作的性能，特别是在高并发场景下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ServerSocketChannel</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8081</span>));</span><br><span class="line">            <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 Selector</span></span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            <span class="comment">// 将ServerSocketChannel 注册到 Selector ,关注 OP_ACCEPT 事件</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 无限循环，处理事件</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 阻塞直到有事件发生</span></span><br><span class="line">                selector.select();</span><br><span class="line">                <span class="comment">// 获取发生事件的 SelectionKey</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="comment">// 处理完成后，从selectdKeys集合中删除</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        <span class="comment">// 有新的连接请求</span></span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 接受连接</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">                        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">                        client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">// 将新的SocketChannel 注册到Selector，关注 OP_READ事件</span></span><br><span class="line">                        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        <span class="comment">// 有数据可读</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 创建 ByteBuffer 缓冲区</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">// 从 SocketChannel 中读取并写入 ByteBuffer</span></span><br><span class="line">                        client.read(buffer);</span><br><span class="line">                        <span class="comment">// 翻转ByteBuffer，准备读取</span></span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        <span class="comment">// 将数据从ByteBuffer写回到 SocketChannel</span></span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                        <span class="comment">// 关闭连接</span></span><br><span class="line">                        client.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个基于 Java NIO 的简单 TCP 服务器。它使用 ServerSocketChannel 和 Selector（后面会讲） 实现了非阻塞 I&#x2F;O 和 I&#x2F;O 多路复用。服务器循环监听事件，当有新的连接请求时，接受连接并将新的 SocketChannel 注册到 Selector，关注 OP_READ 事件。当有数据可读时，从 SocketChannel 中读取数据并写入 ByteBuffer，然后将数据从 ByteBuffer 写回到 SocketChannel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">clientCount</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorServiceIO</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorServiceNIO</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用传统IO的客户端</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">ioClient</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                out.write(<span class="string">&quot;hello 你好啊&quot;</span>.getBytes());</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                in.read(buffer);</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用传统IO的客户端</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">nioClient</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">                socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8081</span>));</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;你好啊 这个是nio&quot;</span>.getBytes());</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                socketChannel.read(buffer);</span><br><span class="line">                socketChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别测试性能</span></span><br><span class="line">        <span class="type">long</span> startTime, endTime;</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; clientCount; i++)&#123;</span><br><span class="line">            executorServiceIO.execute(ioClient);</span><br><span class="line">        &#125;</span><br><span class="line">        executorServiceIO.shutdown();</span><br><span class="line">        executorServiceIO.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;传统IO服务器处理&quot;</span> + clientCount + <span class="string">&quot;个客户端耗时&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; clientCount; i++)&#123;</span><br><span class="line">            executorServiceNIO.execute(nioClient);</span><br><span class="line">        &#125;</span><br><span class="line">        executorServiceNIO.shutdown();</span><br><span class="line">        executorServiceNIO.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;NIO服务器处理&quot;</span> + clientCount + <span class="string">&quot;个客户端耗时&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/11/04/code/javanio/image-2.png" alt="可以看出NIO快了一些"></p>
<h2 id="NIO、BIO和AIO的区别"><a href="#NIO、BIO和AIO的区别" class="headerlink" title="NIO、BIO和AIO的区别"></a>NIO、BIO和AIO的区别</h2><p>NIO 与原来的 I&#x2F;O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。<br>面向流的 I&#x2F;O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。<br>面向块的 I&#x2F;O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I&#x2F;O 缺少一些面向流的 I&#x2F;O 所具有的优雅性和简单性。</p>
<p>Java AIO，全称 Asynchronous IO，是异步非阻塞的 IO。是一种非阻塞异步的通信模式。<br>在 NIO 的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。</p>
<p>BIO （Blocking I&#x2F;O）：同步阻塞 I&#x2F;O 模式。这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。<br>NIO （New I&#x2F;O）：同步非阻塞模式。这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。<br>AIO （Asynchronous I&#x2F;O）：异步非阻塞 I&#x2F;O 模型。这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。</p>
<p>阻塞 VS 非阻塞：人是否坐在水壶前面一直等。<br>同步 VS 异步：水壶是不是在水烧开之后主动通知人。</p>
<p>BIO 方式适用于连接数目比较小且固定的架构<br>NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂<br>AIO 方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BioFileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">BioFileDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BioFileDemo</span>();</span><br><span class="line">        demo.writeFile();</span><br><span class="line">        demo.readFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;logs/itdas/dasda.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fileWriter);</span><br><span class="line"></span><br><span class="line">            bufferedWriter.write(<span class="string">&quot;dasdasdasdasd&quot;</span>);</span><br><span class="line">            bufferedWriter.newLine();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;写入完成&quot;</span>);</span><br><span class="line">            bufferedWriter.close();</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;logs/itdas/dasda.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(filename);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例展示了如何使用 Java 中的传统阻塞 I&#x2F;O（BIO）对文件进行读写操作。在 writeFile() 方法中，我们首先创建一个 FileWriter 对象，并使用 BufferedWriter 进行缓冲写入。接着，使用 bufferedWriter.write() 方法将字符串写入文件，然后调用 bufferedWriter.newLine() 方法添加换行符。最后，关闭 BufferedWriter 和 FileWriter。在 readFile() 方法中，我们创建一个 FileReader 对象，并使用 BufferedReader 进行缓冲读取。然后通过调用 bufferedReader.readLine() 方法循环读取文件内容，直到返回 null 表示读取完毕。最后，关闭 BufferedReader 和 FileReader。</p>
<p>接下来是 NIO 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioFileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioFileDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioFileDemo</span>();</span><br><span class="line">        demo.writeFile();</span><br><span class="line">        demo.readFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 NIO 写入文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;logs/itwanger/paicoding.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> FileChannel.open(path, EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE));</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;学编程就上技术派&quot;</span>);</span><br><span class="line">            fileChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;写入完成&quot;</span>);</span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 NIO 读取文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;logs/itwanger/paicoding.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> FileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> fileChannel.read(buffer);</span><br><span class="line">            <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(<span class="string">&quot;读取的内容: &quot;</span> + StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                bytesRead = fileChannel.read(buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 AIO 实现文件的读取和写入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AioDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AioDemo</span>();</span><br><span class="line">        demo.writeFile();</span><br><span class="line">        demo.readFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 AsynchronousFileChannel 写入文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Paths.get() 获取文件路径</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;logs/itwanger/paicoding.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用 AsynchronousFileChannel.open() 打开文件通道，指定写入和创建文件的选项。</span></span><br><span class="line">            <span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将要写入的字符串（&quot;学编程就上技术派&quot;）转换为 ByteBuffer。</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;学编程就上技术派&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用 fileChannel.write() 方法将 ByteBuffer 中的内容写入文件。这是一个异步操作，因此需要使用 Future 对象等待写入操作完成。</span></span><br><span class="line">            Future&lt;Integer&gt; result = fileChannel.write(buffer, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 等待写操作完成</span></span><br><span class="line">            result.get();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;写入完成&quot;</span>);</span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException | java.util.concurrent.ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 AsynchronousFileChannel 读取文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;logs/itwanger/paicoding.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 指定读取文件的选项。</span></span><br><span class="line">            <span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">            <span class="comment">// 创建一个 ByteBuffer，用于存储从文件中读取的数据。</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 fileChannel.read() 方法从文件中异步读取数据。该方法接受一个 CompletionHandler 对象，用于处理异步操作完成后的回调。</span></span><br><span class="line">            fileChannel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    <span class="comment">// 在 CompletionHandler 的 completed() 方法中，翻转 ByteBuffer（attachment.flip()），然后使用 Charset.forName(&quot;UTF-8&quot;).decode() 将其解码为字符串并打印。最后，清空缓冲区并关闭文件通道。</span></span><br><span class="line">                    attachment.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;读取的内容: &quot;</span> + StandardCharsets.UTF_8.decode(attachment));</span><br><span class="line">                    attachment.clear();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        fileChannel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果异步读取操作失败，CompletionHandler 的 failed() 方法将被调用，打印错误信息。</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;读取失败&quot;</span>);</span><br><span class="line">                    exc.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待异步操作完成</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BIO（Blocking I&#x2F;O）：采用阻塞式 I&#x2F;O 模型，线程在执行 I&#x2F;O 操作时被阻塞，无法处理其他任务，适用于连接数较少且稳定的场景。<br>NIO（New I&#x2F;O 或 Non-blocking I&#x2F;O）：使用非阻塞 I&#x2F;O 模型，线程在等待 I&#x2F;O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，提高性能和可伸缩性，适用于高并发场景。<br>AIO（Asynchronous I&#x2F;O）：采用异步 I&#x2F;O 模型，线程发起 I&#x2F;O 请求后立即返回，当 I&#x2F;O 操作完成时通过回调函数通知线程，进一步提高了并发处理能力，适用于高吞吐量场景。</p>
<h2 id="Buffer缓冲区和Channel通道"><a href="#Buffer缓冲区和Channel通道" class="headerlink" title="Buffer缓冲区和Channel通道"></a>Buffer缓冲区和Channel通道</h2><p>在 NIO 中，并不是以流的方式来处理数据的，而是以 buffer 缓冲区和 Channel 通道配合使用来处理数据的。可以把 Channel 通道比作铁路，buffer 缓冲区比作成火车(运载着货物),要时刻记住：Channel 不与数据打交道，它只负责运输数据。与数据打交道的是 Buffer 缓冲区.相对于传统 IO 而言，流是单向的。对于 NIO 而言，有了 Channel 通道这个概念，我们的读写都是双向的。</p>
<h3 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h3><p>Buffer 是缓冲区的抽象类 其中 ByteBuffer 是用得最多的实现类(在通道中读写字节数据)<br><img src="/2024/11/04/code/javanio/image-3.png"><br>Buffer 类维护了 4 个核心变量来提供关于其所包含的数组信息。它们是：</p>
<ul>
<li>容量 Capacity 缓冲区能够容纳的数据元素的最大数量。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)</li>
<li>上界 Limit 缓冲区里的数据的总数，代表了当前缓冲区中一共有多少数据。</li>
<li>位置 Position 下一个要被读或写的元素的位置。Position 会自动由相应的 get()和 put()函数更新。</li>
<li>标记 Mark 一个备忘位置。用于记录上一次读写的位置。</li>
</ul>
<p>首先展示一下是如何创建缓冲区的，核心变量的值是怎么变化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个缓冲区</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看一下初始时4个核心变量的值</span></span><br><span class="line">System.out.println(<span class="string">&quot;初始时--&gt;limit---&gt;&quot;</span>+byteBuffer.limit());</span><br><span class="line">System.out.println(<span class="string">&quot;初始时--&gt;position---&gt;&quot;</span>+byteBuffer.position());</span><br><span class="line">System.out.println(<span class="string">&quot;初始时--&gt;capacity---&gt;&quot;</span>+byteBuffer.capacity());</span><br><span class="line">System.out.println(<span class="string">&quot;初始时--&gt;mark---&gt;&quot;</span> + byteBuffer.mark());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些数据到缓冲区中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;沉默王二&quot;</span>;</span><br><span class="line">byteBuffer.put(s.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看一下初始时4个核心变量的值</span></span><br><span class="line">System.out.println(<span class="string">&quot;put完之后--&gt;limit---&gt;&quot;</span>+byteBuffer.limit());</span><br><span class="line">System.out.println(<span class="string">&quot;put完之后--&gt;position---&gt;&quot;</span>+byteBuffer.position());</span><br><span class="line">System.out.println(<span class="string">&quot;put完之后--&gt;capacity---&gt;&quot;</span>+byteBuffer.capacity());</span><br><span class="line">System.out.println(<span class="string">&quot;put完之后--&gt;mark---&gt;&quot;</span> + byteBuffer.mark());</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始时--&gt;limit---&gt;1024</span><br><span class="line">初始时--&gt;position---&gt;0</span><br><span class="line">初始时--&gt;capacity---&gt;1024</span><br><span class="line">初始时--&gt;mark---&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024]</span><br><span class="line">--------------------------------------</span><br><span class="line">put完之后--&gt;limit---&gt;1024</span><br><span class="line">put完之后--&gt;position---&gt;12</span><br><span class="line">put完之后--&gt;capacity---&gt;1024</span><br><span class="line">put完之后--&gt;mark---&gt;java.nio.HeapByteBuffer[pos=12 lim=1024 cap=1024]</span><br></pre></td></tr></table></figure>
<p>现在我想要从缓存区拿数据，怎么拿呀？？NIO 给了我们一个flip()方法。这个方法可以改动 position 和 limit 的位置！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flip()方法</span></span><br><span class="line">byteBuffer.flip();</span><br><span class="line">System.out.println(<span class="string">&quot;flip()方法之后--&gt;limit---&gt;&quot;</span>+byteBuffer.limit());</span><br><span class="line">System.out.println(<span class="string">&quot;flip()方法之后--&gt;position---&gt;&quot;</span>+byteBuffer.position());</span><br><span class="line">System.out.println(<span class="string">&quot;flip()方法之后--&gt;capacity---&gt;&quot;</span>+byteBuffer.capacity());</span><br><span class="line">System.out.println(<span class="string">&quot;flip()方法之后--&gt;mark---&gt;&quot;</span> + byteBuffer.mark());</span><br></pre></td></tr></table></figure>
<p><img src="/2024/11/04/code/javanio/image-4.png"><br>在调用 flip() 之后，limit 变为当前 position 的值（12），position 重置为 0。这意味着你可以从缓冲区的开始位置读取刚刚写入的数据，直到 limit 指定的位置。capacity 保持不变（1024）。当切换成读模式之后，我们就可以读取缓冲区的数据了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个limit()大小的字节数组(因为就只有limit这么多个数据可读)</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[byteBuffer.limit()];</span><br><span class="line"><span class="comment">// 将读取的数据装进我们的字节数组中</span></span><br><span class="line">byteBuffer.get(bytes);</span><br><span class="line"><span class="comment">// 输出数据</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, bytes.length));</span><br></pre></td></tr></table></figure>
<p>随后输出一下核心变量的值看看：<br><img src="/2024/11/04/code/javanio/image-5.png"><br>读完如何还想写数据到缓冲区，那就使用clear() 方法，这个方法会“清空”缓冲区，数据没有真正被清空，只是被遗忘掉了<br><img src="/2024/11/04/code/javanio/image-6.png"></p>
<h3 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel 通道"></a>Channel 通道</h3><p>Channel 通道只负责传输数据、不直接操作数据。操作数据都是通过 Buffer 缓冲区来进行操作！通常，通道可以分为两大类：文件通道和套接字通道。<br>FileChannel：用于文件 I&#x2F;O 的通道，支持文件的读、写和追加操作。FileChannel 允许在文件的任意位置进行数据传输，支持文件锁定以及内存映射文件等高级功能。FileChannel 无法设置为非阻塞模式，因此它只适用于阻塞式文件操作。<br>SocketChannel：用于 TCP 套接字 I&#x2F;O 的通道。SocketChannel 支持非阻塞模式，可以与 Selector（下文会讲）一起使用，实现高效的网络通信。SocketChannel 允许连接到远程主机，进行数据传输。<br>与之匹配的有ServerSocketChannel：用于监听 TCP 套接字连接的通道。与 SocketChannel 类似，ServerSocketChannel 也支持非阻塞模式，并可以与 Selector 一起使用。ServerSocketChannel 负责监听新的连接请求，接收到连接请求后，可以创建一个新的 SocketChannel 以处理数据传输。<br>DatagramChannel：用于 UDP 套接字 I&#x2F;O 的通道。DatagramChannel 支持非阻塞模式，可以发送和接收数据报包，适用于无连接的、不可靠的网络通信。</p>
<h4 id="文件通道-FileChannel"><a href="#文件通道-FileChannel" class="headerlink" title="文件通道 FileChannel"></a>文件通道 FileChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileChannel.open(Paths.get(<span class="string">&quot;docs/配套教程.md&quot;</span>), StandardOpenOption.WRITE);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用FileChannel 配合 ByteBuffer 缓冲区实现文件复制的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;logs/javabetter/itwanger.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">destinationChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;logs/javabetter/itwanger1.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (sourceChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">      buffer.flip();</span><br><span class="line">      destinationChannel.write(buffer);</span><br><span class="line">      buffer.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取数据后，我们调用 flip() 方法，以便在缓冲区中准备好要写入的数据。然后，我们将缓冲区的内容写入目标文件的 FileChannel（write() 方法）。在写入完成后，我们调用 clear() 方法重置缓冲区，以便在下一次迭代中重用它。</p>
</li>
<li><p>使用内存映射文件（MappedByteBuffer）的方式实现文件复制的功能(直接操作缓冲区)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;logs/javabetter/itwanger.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">      <span class="type">FileChannel</span> <span class="variable">destinationChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;logs/javabetter/itwanger2.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> sourceChannel.size();</span><br><span class="line">    <span class="type">MappedByteBuffer</span> <span class="variable">sourceMappedBuffer</span> <span class="operator">=</span> sourceChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, fileSize);</span><br><span class="line">    <span class="type">MappedByteBuffer</span> <span class="variable">destinationMappedBuffer</span> <span class="operator">=</span> destinationChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fileSize; i++) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> sourceMappedBuffer.get(i);</span><br><span class="line">        destinationMappedBuffer.put(i, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MappedByteBuffer 是 Java NIO 中的一个类，它继承自 java.nio.ByteBuffer。MappedByteBuffer 用于表示一个内存映射文件，即将文件的一部分或全部映射到内存中，以便通过直接操作内存来实现对文件的读写。这种方式可以提高文件 I&#x2F;O 的性能，因为操作系统可以直接在内存和磁盘之间传输数据，无需通过 Java 应用程序进行额外的数据拷贝。</p>
</li>
</ol>
<p>通常与 FileChannel 一起使用，可以通过调用 FileChannel 的 map() 方法创建 MappedByteBuffer 对象。map() 方法接受三个参数：映射模式（FileChannel.MapMode）映射起始位置和映射的长度。<br>映射模式包括只读模式（READ_ONLY）、读写模式（READ_WRITE）和专用模式（PRIVATE）。<br>我们设置源文件的 MappedByteBuffer 为只读模式（READ_ONLY），目标文件的 MappedByteBuffer 为读写模式（READ_WRITE）。<br>在循环中，我们逐字节地从源文件的 MappedByteBuffer 读取数据并将其写入目标文件的 MappedByteBuffer。这样就实现了文件复制功能。利用内存映射文件（MappedByteBuffer）实现的文件复制，可能会比使用 ByteBuffer 的方法更快。<br>需要注意的是，使用 MappedByteBuffer 进行文件操作时，数据的修改可能不会立即写入磁盘。可以通过调用 MappedByteBuffer 的 force() 方法将数据立即写回磁盘。</p>
<ol start="3">
<li>通道之间通过transfer()实现数据的传输(直接操作缓冲区)：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;logs/javabetter/itwanger.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">      <span class="type">FileChannel</span> <span class="variable">destinationChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;logs/javabetter/itwanger3.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ)) &#123;</span><br><span class="line">    sourceChannel.transferTo(<span class="number">0</span>, sourceChannel.size(), destinationChannel);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line">FileChannel 的 transferTo() 方法是一个高效的文件传输方法，它允许将文件的一部分或全部内容直接从源文件通道传输到目标通道（通常是另一个文件通道或网络通道）。这种传输方式可以避免将文件数据在用户空间和内核空间之间进行多次拷贝，提高了文件传输的性能。</span><br><span class="line">需要注意的是，transferTo() 方法可能无法一次传输所有请求的字节。在实际应用中，你可能需要使用循环来确保所有字节都被传输。</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelTransferToLoopExampleWithPaths</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">sourcePath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;logs/itwanger/paicoding.txt&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">destinationPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;logs/itwanger/paicoding_copy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 try-with-resources 语句确保通道资源被正确关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> FileChannel.open(sourcePath, StandardOpenOption.READ);</span><br><span class="line">             <span class="type">FileChannel</span> <span class="variable">destinationChannel</span> <span class="operator">=</span> FileChannel.open(destinationPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> sourceChannel.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环传输，直到所有字节都被传输</span></span><br><span class="line">            <span class="keyword">while</span> (position &lt; count) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> sourceChannel.transferTo(position, count - position, destinationChannel);</span><br><span class="line">                position += transferred;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此外，transferTo() 方法在底层使用了操作系统提供的零拷贝功能（如 Linux 的 sendfile() 系统调用），可以大幅提高文件传输性能。但是，不同操作系统和 JVM 实现可能会影响零拷贝的可用性和性能，因此实际性能可能因环境而异。<br>零拷贝（Zero-Copy）是一种优化数据传输性能的技术，它最大限度地减少了在数据传输过程中的 CPU 和内存开销。在传统的数据传输过程中，数据通常需要在用户空间和内核空间之间进行多次拷贝，这会导致额外的 CPU 和内存开销。零拷贝技术通过避免这些多余的拷贝操作，实现了更高效的数据传输。<br>在 Java 中，零拷贝技术主要应用于文件和网络 I&#x2F;O。FileChannel 类的 transferTo() 和 transferFrom() 方法就利用了零拷贝技术，可以在文件和网络通道之间高效地传输数据。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83398714">https://zhuanlan.zhihu.com/p/83398714</a></li>
</ol>
<h4 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h4><p>直接缓冲区和非直接缓冲区的差别主要在于它们在内存中的存储方式。这里给出了直接缓冲区和非直接缓冲区的简要概述和区别：<br>非直接缓冲区：</p>
<ul>
<li>分配在 JVM 堆内存中</li>
<li>受到垃圾回收的管理</li>
<li>在读写操作时，需要将数据从堆内存复制到操作系统的本地内存，再进行 I&#x2F;O 操作</li>
<li>创建： ByteBuffer.allocate(int capacity)<br>直接缓冲区：</li>
<li>分配在操作系统的本地内存中</li>
<li>不受垃圾回收的管理</li>
<li>在读写操作时，直接在本地内存中进行，避免了数据复制，提高了性能</li>
<li>创建： ByteBuffer.allocateDirect(int capacity)</li>
<li>还有前面提到的 FileChannel.map() 方法，会返回一个类型为 MappedByteBuffer 的直接缓冲区。<br><img src="/2024/11/04/code/javanio/image-7.png"><br>非直接缓冲区存储在JVM内部，数据需要从应用程序（Java）复制到非直接缓冲区，再复制到内核缓冲区，最后发送到设备（磁盘&#x2F;网络）。而对于直接缓冲区，数据可以直接从应用程序（Java）复制到内核缓冲区，无需经过JVM的非直接缓冲区。</li>
</ul>
<h4 id="异步文件通道-AsynchronousFileChannel"><a href="#异步文件通道-AsynchronousFileChannel" class="headerlink" title="异步文件通道 AsynchronousFileChannel"></a>异步文件通道 AsynchronousFileChannel</h4><p>AsynchronousFileChannel 是 Java 7 引入的一个异步文件通道类，提供了对文件的异步读、写、打开和关闭等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;example.txt&quot;</span>);</span><br><span class="line"><span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE);</span><br></pre></td></tr></table></figure>

<p>AsynchronousFileChannel 提供了两种异步操作的方式：</p>
<ol>
<li><p>Future 方式：使用 Future 对象来跟踪异步操作的完成情况。当我们调用一个异步操作（如 read() 或 write()）时，它会立即返回一个 Future 对象。可以使用这个对象来检查操作是否完成，以及获取操作的结果。这种方式适用于不需要在操作完成时立即执行其他操作的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Future&lt;Integer&gt; result = fileChannel.read(buffer, position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!result.isDone()) &#123;</span><br><span class="line">    <span class="comment">// 执行其他操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> result.get();</span><br><span class="line">System.out.println(<span class="string">&quot;Bytes read: &quot;</span> + bytesRead);</span><br></pre></td></tr></table></figure>
</li>
<li><p>CompletionHandler 方式，使用一个实现了 CompletionHandler 接口的对象来处理异步操作的完成。我们需要提供一个 CompletionHandler 实现类，重写 completed() 和 failed() 方法，分别处理操作成功和操作失败的情况。当异步操作完成时，系统会自动调用相应的方法。这种方式适用于需要在操作完成时立即执行其他操作的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fileChannel.read(buffer, position, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bytes read: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Read failed&quot;</span>);</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>完整的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;docs/配套教程.md&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(path, StandardOpenOption.READ)) &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Future&lt;Integer&gt; result = fileChannel.read(buffer, position);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!result.isDone()) &#123;</span><br><span class="line">            <span class="comment">// 在这里可以执行其他任务，例如处理其他 I/O 操作</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> result.get();</span><br><span class="line">        <span class="keyword">if</span> (bytesRead &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        position += bytesRead;</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">        buffer.get(data);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line"></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 AsynchronousFileChannel.read() 方法发起异步读取操作。这个方法会返回一个 Future<Integer> 对象，表示读取操作的结果。我们可以通过调用 isDone() 方法来检查异步操作是否完成。完成后，我们可以通过调用 get() 方法获取实际读取的字节数。<br>然后我们来看 CompletionHandler 接口的形式：</Integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readAllBytes</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">position</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    fileChannel.read(buffer, position.get(), <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer bytesRead, Object attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                position.addAndGet(bytesRead);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">                buffer.clear();</span><br><span class="line"></span><br><span class="line">                fileChannel.read(buffer, position.get(), attachment, <span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: &quot;</span> + exc.getMessage());</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    latch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Java-NIO-中的Paths-和-Files"><a href="#Java-NIO-中的Paths-和-Files" class="headerlink" title="Java NIO 中的Paths 和 Files"></a>Java NIO 中的Paths 和 Files</h2><p>Java NIO（New I&#x2F;O）库引入了许多新的功能，其中包括 <code>Paths</code> 和 <code>Files</code> 这两个重要的类，它们主要用于文件和目录的操作，提供了比传统的 <code>File</code> 类更强大和灵活的功能。</p>
<h3 id="1-Paths-类"><a href="#1-Paths-类" class="headerlink" title="1. Paths 类"></a>1. <code>Paths</code> 类</h3><p><code>Paths</code> 类用于定位文件系统中的路径，是 <code>java.nio.file.Path</code> 的便捷工厂类。<code>Paths</code> 类的静态方法可以将字符串路径转换为 <code>Path</code> 实例，便于进行进一步的操作。</p>
<ul>
<li><p><strong>创建 Path 对象</strong><br>使用 <code>Paths.get(String first, String... more)</code> 方法可以轻松创建一个 <code>Path</code> 实例。该方法接受一个字符串或多个字符串参数（代表路径的各个部分）并返回 <code>Path</code> 对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;file.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取路径信息</strong><br><code>Path</code> 类提供了丰富的路径信息查询方法，如：</p>
<ul>
<li><code>getFileName()</code>: 获取文件名。</li>
<li><code>getParent()</code>: 获取上级目录路径。</li>
<li><code>getRoot()</code>: 获取根路径。</li>
<li><code>isAbsolute()</code>: 检查路径是否为绝对路径。</li>
<li><code>toAbsolutePath()</code>: 转换为绝对路径。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;docs/配套教程.md&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件名</span></span><br><span class="line">System.out.println(<span class="string">&quot;File name: &quot;</span> + path.getFileName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父目录</span></span><br><span class="line">System.out.println(<span class="string">&quot;Parent: &quot;</span> + path.getParent());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取根目录</span></span><br><span class="line">System.out.println(<span class="string">&quot;Root: &quot;</span> + path.getRoot());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路径与另一个路径结合</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> path.resolve(<span class="string">&quot;config/app.properties&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Resolved path: &quot;</span> + newPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">normalizedPath</span> <span class="operator">=</span> newPath.normalize();</span><br><span class="line">System.out.println(<span class="string">&quot;Normalized path: &quot;</span> + normalizedPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将相对路径转换为绝对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">absolutePath</span> <span class="operator">=</span> path.toAbsolutePath();</span><br><span class="line">System.out.println(<span class="string">&quot;Absolute path: &quot;</span> + absolutePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个路径之间的相对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">basePath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/docs/&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">targetPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/docs/imgs/itwanger&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">relativePath</span> <span class="operator">=</span> basePath.relativize(targetPath);</span><br><span class="line">System.out.println(<span class="string">&quot;Relative path: &quot;</span> + relativePath);</span><br></pre></td></tr></table></figure>

<h4 id="2-Files-类"><a href="#2-Files-类" class="headerlink" title="2. Files 类"></a>2. <code>Files</code> 类</h4><p><code>Files</code> 类包含大量静态方法，用于操作文件和目录。<code>Files</code> 提供了对文件创建、删除、读取、写入等功能的支持，非常适合进行文件 I&#x2F;O 操作。</p>
<p>以下是 <code>Files</code> 类中一些常用的方法：</p>
<ul>
<li><p><strong>文件和目录的创建和删除</strong>  </p>
<ul>
<li><code>createFile(Path path)</code>: 创建一个新文件，如果文件已经存在则会抛出异常。</li>
<li><code>createDirectory(Path path)</code>: 创建一个新目录。</li>
<li><code>delete(Path path)</code>: 删除文件或目录。</li>
<li><code>deleteIfExists(Path path)</code>: 如果文件存在则删除，避免异常抛出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Path实例</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;logs/javabetter/itwanger4.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新文件</span></span><br><span class="line">Files.createFile(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否存在</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> Files.exists(path);</span><br><span class="line">System.out.println(<span class="string">&quot;File exists: &quot;</span> + exists);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件</span></span><br><span class="line">Files.delete(path);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件读写</strong>  </p>
<ul>
<li><code>readAllBytes(Path path)</code>: 读取文件内容并以字节数组的形式返回。</li>
<li><code>readAllLines(Path path)</code>: 读取文件内容并将每行作为列表中的一个元素返回。</li>
<li><code>write(Path path, byte[] bytes)</code>: 将字节数组写入文件。</li>
<li><code>write(Path path, Iterable&lt;? extends CharSequence&gt; lines)</code>: 将多行文本写入文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件属性检查</strong>  </p>
<ul>
<li><code>exists(Path path)</code>: 检查文件或目录是否存在。</li>
<li><code>isDirectory(Path path)</code>: 检查是否为目录。</li>
<li><code>isReadable(Path path)</code>: 检查文件是否可读。</li>
<li><code>isWritable(Path path)</code>: 检查文件是否可写。</li>
</ul>
</li>
<li><p><strong>文件复制和移动</strong>  </p>
<ul>
<li><code>copy(Path source, Path target, CopyOption... options)</code>: 复制文件。</li>
<li><code>move(Path source, Path target, CopyOption... options)</code>: 移动或重命名文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;copyOfFile.txt&quot;</span>);</span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>java.nio.file.Files</code>类提供了大量静态方法，用于处理文件系统中的文件和目录。这些方法包括文件的创建、删除、复制、移动等操作，以及读取和设置文件属性。</p>
<p>下面展示一个 Files 和 Paths 一起使用的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Path实例</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;logs/javabetter/itwanger4.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新文件</span></span><br><span class="line">Files.createFile(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否存在</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> Files.exists(path);</span><br><span class="line">System.out.println(<span class="string">&quot;File exists: &quot;</span> + exists);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件</span></span><br><span class="line">Files.delete(path);</span><br></pre></td></tr></table></figure>

<p>以下是一些常用方法及其示例：</p>
<p>1、<code>exists(Path path, LinkOption... options)</code>：检查文件或目录是否存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> Files.exists(path);</span><br><span class="line">System.out.println(<span class="string">&quot;File exists: &quot;</span> + exists);</span><br></pre></td></tr></table></figure>

<p>LinkOption 是一个枚举类，它定义了如何处理文件系统链接的选项。它位于 java.nio.file 包中。LinkOption 主要在与文件或目录的路径操作相关的方法中使用，以控制这些方法如何处理符号链接。符号链接是一种特殊类型的文件，它在 Unix 和类 Unix 系统（如 Linux 和 macOS）上很常见。在 Windows 上，类似的概念被称为快捷方式。</p>
<p>2、<code>createFile(Path path, FileAttribute&lt;?&gt;... attrs)</code>：创建一个新的空文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;newFile.txt&quot;</span>);</span><br><span class="line">Files.createFile(newPath);</span><br></pre></td></tr></table></figure>

<p>FileAttribute 是一个泛型接口，用于处理各种不同类型的属性。在使用 FileAttribute 时，你需要为其提供一个特定的实现。<code>java.nio.file.attribute</code> 包中的 PosixFileAttributes 类提供了 POSIX（Portable Operating System Interface，定义了许多与文件系统相关的操作，包括文件和目录的创建、删除、读取和修改。）文件属性的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;fileWithPermissions.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;PosixFilePermission&gt; permissions = PosixFilePermissions.fromString(<span class="string">&quot;rw-r-----&quot;</span>);</span><br><span class="line">FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; fileAttribute = PosixFilePermissions.asFileAttribute(permissions);</span><br><span class="line"></span><br><span class="line">Files.createFile(path, fileAttribute);</span><br></pre></td></tr></table></figure>

<p>PosixFileAttributes 接口提供了获取 POSIX 文件属性的方法，如文件所有者、文件所属的组以及文件的访问权限。以上示例会创建一个读写属性的文件。</p>
<p>3、<code>createDirectory(Path dir, FileAttribute&lt;?&gt;... attrs)</code>：创建一个新的目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">newDir</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;newDirectory&quot;</span>);</span><br><span class="line">Files.createDirectory(newDir);</span><br></pre></td></tr></table></figure>

<p>4、<code>delete(Path path)</code>：删除文件或目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">pathToDelete</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;fileToDelete.txt&quot;</span>);</span><br><span class="line">Files.delete(pathToDelete);</span><br></pre></td></tr></table></figure>

<p>5、<code>copy(Path source, Path target, CopyOption... options)</code>：复制文件或目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">sourcePath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;sourceFile.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">targetPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;targetFile.txt&quot;</span>);</span><br><span class="line">Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>

<p>在 Java NIO 中，有两个实现了 CopyOption 接口的枚举类：StandardCopyOption 和 LinkOption。</p>
<p>StandardCopyOption 枚举类提供了以下两个选项：</p>
<ul>
<li>REPLACE_EXISTING：如果目标文件已经存在，该选项会使 <code>Files.copy()</code> 方法替换目标文件。如果不指定此选项，<code>Files.copy()</code> 方法在目标文件已存在时将抛出 FileAlreadyExistsException。</li>
<li>COPY_ATTRIBUTES：此选项表示在复制文件时，尽可能地复制文件的属性（如文件时间戳、权限等）。如果不指定此选项，那么目标文件将具有默认的属性。</li>
</ul>
<p>6、<code>move(Path source, Path target, CopyOption... options)</code>：移动或重命名文件或目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">sourcePath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;sourceFile.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">targetPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;targetFile.txt&quot;</span>);</span><br><span class="line">Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>

<p>7、<code>readAllLines(Path path, Charset cs)</code>：读取文件的所有行到一个字符串列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path, StandardCharsets.UTF_8);</span><br><span class="line">lines.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>8、<code>write(Path path, Iterable&lt;? extends CharSequence&gt; lines, Charset cs, OpenOption... options)</code>：将字符串列表写入文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">List&lt;String&gt; lines = Arrays.asList(<span class="string">&quot;沉默王二 1&quot;</span>, <span class="string">&quot;沉默王二 2&quot;</span>, <span class="string">&quot;沉默王二 3&quot;</span>);</span><br><span class="line">Files.write(path, lines, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p>OpenOption 是 Java NIO 中一个用于配置文件操作的接口。它提供了在使用 <code>Files.newByteChannel()</code>、<code>Files.newInputStream()</code>、<code>Files.newOutputStream()</code>、<code>AsynchronousFileChannel.open()</code> 和 <code>FileChannel.open()</code> 方法时定制行为的选项。</p>
<p>在 Java NIO 中，有两个实现了 OpenOption 接口的枚举类：StandardOpenOption 和 LinkOption。</p>
<p>StandardOpenOption 枚举类提供了以下几个选项：</p>
<ul>
<li>READ：以读取模式打开文件。</li>
<li>WRITE：以写入模式打开文件。</li>
<li>APPEND：以追加模式打开文件。</li>
<li>TRUNCATE_EXISTING：在打开文件时，截断文件的内容，使其长度为 0。仅适用于 WRITE 或 APPEND 模式。</li>
<li>CREATE：当文件不存在时创建文件。如果文件已存在，则打开文件。</li>
<li>CREATE_NEW：当文件不存在时创建文件。如果文件已存在，抛出 FileAlreadyExistsException。</li>
<li>DELETE_ON_CLOSE：在关闭通道时删除文件。</li>
<li>SPARSE：提示文件系统创建一个稀疏文件。</li>
<li>SYNC：要求每次更新文件的内容或元数据时都进行同步。</li>
<li>DSYNC：要求每次更新文件内容时都进行同步。</li>
</ul>
<p>8、<code>newBufferedReader(Path path, Charset cs) 和 newBufferedWriter(Path path, Charset cs, OpenOption... options)</code>：创建 BufferedReader 和 BufferedWriter 对象以读取和写入文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read file</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> Files.newBufferedReader(path, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write file</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">outputPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;outputFile.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> Files.newBufferedWriter(outputPath, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Files-walkFileTree-静态方法"><a href="#Files-walkFileTree-静态方法" class="headerlink" title="Files.walkFileTree() 静态方法"></a>Files.walkFileTree() 静态方法</h4><p>这个方法可以递归地访问目录结构中的所有文件和目录，并允许您对这些文件和目录执行自定义操作。使用 walkFileTree 方法时，需要提供一个起始路径（起始目录）和一个实现了 FileVisitor 接口的对象。FileVisitor 接口包含四个方法，它们在遍历过程中的不同阶段被调用：</p>
<ul>
<li>preVisitDirectory：在访问目录之前调用。</li>
<li>postVisitDirectory：在访问目录之后调用。</li>
<li>visitFile：在访问文件时调用。</li>
<li>visitFileFailed：在访问文件失败时调用。</li>
</ul>
<p>来看下面这个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WalkFileTreeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">startingDir</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;docs&quot;</span>);</span><br><span class="line">        <span class="type">MyFileVisitor</span> <span class="variable">fileVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFileVisitor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.walkFileTree(startingDir, fileVisitor);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyFileVisitor</span> <span class="keyword">extends</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;准备访问目录: &quot;</span> + dir);</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在访问目录: &quot;</span> + dir);</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;访问文件: &quot;</span> + file);</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFileFailed</span><span class="params">(Path file, IOException exc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;访问文件失败: &quot;</span> + file);</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">准备访问目录: docs</span><br><span class="line">访问文件: docs/安装环境.md</span><br><span class="line">准备访问目录: docs/imgs</span><br><span class="line">访问文件: docs/imgs/init_03.jpg</span><br><span class="line">准备访问目录: docs/imgs/itwanger</span><br><span class="line">访问文件: docs/imgs/itwanger/tongzhishu.jpeg</span><br><span class="line">访问文件: docs/imgs/itwanger/tongzhishu1.jpeg</span><br><span class="line">访问文件: docs/imgs/itwanger/tongzhishu1.pdf</span><br><span class="line">正在访问目录: docs/imgs/itwanger</span><br><span class="line">访问文件: docs/imgs/init_02.jpg</span><br><span class="line">访问文件: docs/imgs/init_00.jpg</span><br><span class="line">访问文件: docs/imgs/init_01.jpg</span><br><span class="line">访问文件: docs/imgs/init_04.jpg</span><br><span class="line">正在访问目录: docs/imgs</span><br><span class="line">访问文件: docs/服务器启动教程.md</span><br><span class="line">访问文件: docs/配套教程.md</span><br><span class="line">访问文件: docs/约定.md</span><br><span class="line">访问文件: docs/本地开发环境配置教程.md</span><br><span class="line">访问文件: docs/前端工程结构说明.md</span><br><span class="line">正在访问目录: docs</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个名为 MyFileVisitor 的自定义 FileVisitor 类，它扩展了 SimpleFileVisitor 类。SimpleFileVisitor 是 FileVisitor 接口的一个实现，它提供了一些默认的行为。我们可以覆盖 SimpleFileVisitor 中的方法以实现自己的逻辑。在这个例子中，我们只是打印出了访问的文件和目录。然后，我们使用 Files.walkFileTree 方法遍历文件树。这个方法会遍历整个目录结构，并调用 MyFileVisitor 中的相应方法。</p>
<p>其中，FileVisitResult 枚举包含以下四个选项：</p>
<ul>
<li>CONTINUE ： 继续</li>
<li>TERMINATE ： 终止</li>
<li>SKIP_SIBLINGS ： 跳过兄弟节点，然后继续</li>
<li>SKIP_SUBTREE ： 跳过子树（不访问此目录的条目），然后继续，仅在 preVisitDirectory 方法返回时才有意义，除此以外和 CONTINUE 相同。</li>
</ul>
<h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><p><code>walkFileTree()</code> 方法还可以用于搜索文件，下面这个例子扩展了 SimpleFileVisitor 来查找一个名为 itwanger.txt 的文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindFileWithWalkFileTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">startingDir</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;logs&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">targetFileName</span> <span class="operator">=</span> <span class="string">&quot;itwanger.txt&quot;</span>;</span><br><span class="line">        <span class="type">FindFileVisitor</span> <span class="variable">findFileVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FindFileVisitor</span>(targetFileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.walkFileTree(startingDir, findFileVisitor);</span><br><span class="line">            <span class="keyword">if</span> (findFileVisitor.isFileFound()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;找到文件了: &quot;</span> + findFileVisitor.getFoundFilePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ooh，文件没找到&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FindFileVisitor</span> <span class="keyword">extends</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> String targetFileName;</span><br><span class="line">        <span class="keyword">private</span> Path foundFilePath;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FindFileVisitor</span><span class="params">(String targetFileName)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetFileName = targetFileName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFileFound</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> foundFilePath != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Path <span class="title function_">getFoundFilePath</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> foundFilePath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getFileName().toString();</span><br><span class="line">            <span class="keyword">if</span> (fileName.equals(targetFileName)) &#123;</span><br><span class="line">                foundFilePath = file;</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.TERMINATE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主方法中，我们使用 Files.walkFileTree 方法遍历文件树，并传递一个起始目录和 FindFileVisitor 实例。遍历完成后，我们检查是否找到了目标文件，如果找到了，就打印出它的路径。##</p>
<h2 id="NIO实现网络聊天室"><a href="#NIO实现网络聊天室" class="headerlink" title="NIO实现网络聊天室"></a>NIO实现网络聊天室</h2><h3 id="Scatter-和-Gather"><a href="#Scatter-和-Gather" class="headerlink" title="Scatter 和 Gather"></a>Scatter 和 Gather</h3><p>Scatter 和 Gather 是 Java NIO 中两种高效的 I&#x2F;O 操作，用于将数据分散到多个缓冲区或从多个缓冲区中收集数据。</p>
<p>Scatter（分散）：它将从 Channel 读取的数据分散（写入）到多个缓冲区。这种操作可以在读取数据时将其分散到不同的缓冲区，有助于处理结构化数据。例如，我们可以将消息头、消息体和消息尾分别写入不同的缓冲区。<br>Gather（聚集）：与 Scatter 相反，它将多个缓冲区中的数据聚集（读取）并写入到一个 Channel。这种操作允许我们在发送数据时从多个缓冲区中聚集数据。例如，我们可以将消息头、消息体和消息尾从不同的缓冲区中聚集到一起并写入到同一个 Channel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="comment">// 创建一个ServerSocketChannel</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受连接</span></span><br><span class="line"><span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scatter：分散读取数据到多个缓冲区</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">headerBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bodyBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] buffers = &#123;headerBuffer, bodyBuffer&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">bytesRead</span> <span class="operator">=</span> socketChannel.read(buffers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出缓冲区数据</span></span><br><span class="line">headerBuffer.flip();</span><br><span class="line"><span class="keyword">while</span> (headerBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>) headerBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">bodyBuffer.flip();</span><br><span class="line"><span class="keyword">while</span> (bodyBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>) bodyBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gather：聚集数据从多个缓冲区写入到Channel</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">headerResponse</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;Header Response&quot;</span>.getBytes());</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bodyResponse</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;Body Response&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">ByteBuffer[] responseBuffers = &#123;headerResponse, bodyResponse&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">bytesWritten</span> <span class="operator">=</span> socketChannel.write(responseBuffers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">socketChannel.close();</span><br><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="comment">// 创建一个SocketChannel</span></span><br><span class="line"><span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据到服务器</span></span><br><span class="line"><span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> <span class="string">&quot;Header Content&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;Body Content&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">headerBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(header.getBytes());</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bodyBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(body.getBytes());</span><br><span class="line"></span><br><span class="line">ByteBuffer[] buffers = &#123;headerBuffer, bodyBuffer&#125;;</span><br><span class="line">socketChannel.write(buffers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从服务器接收数据</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">headerResponseBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bodyResponseBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] responseBuffers = &#123;headerResponseBuffer, bodyResponseBuffer&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">bytesRead</span> <span class="operator">=</span> socketChannel.read(responseBuffers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出接收到的数据</span></span><br><span class="line">headerResponseBuffer.flip();</span><br><span class="line"><span class="keyword">while</span> (headerResponseBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>) headerResponseBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bodyResponseBuffer.flip();</span><br><span class="line"><span class="keyword">while</span> (bodyResponseBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>) bodyResponseBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<h3 id="异步套接字通道-AsynchronousSocketChannel-和-AsynchronousServerSocketChannel"><a href="#异步套接字通道-AsynchronousSocketChannel-和-AsynchronousServerSocketChannel" class="headerlink" title="异步套接字通道 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel"></a>异步套接字通道 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel</h3><p>AsynchronousSocketChannel 和 AsynchronousServerSocketChannel 是 Java 7 引入的异步 I&#x2F;O 类，分别用于处理异步客户端 Socket 和服务器端 ServerSocket。异步 I&#x2F;O 允许在 I&#x2F;O 操作进行时执行其他任务，并在操作完成时接收通知，提高了并发处理能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynchronousServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open();</span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">        server.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel client, Void attachment)</span>&#123;</span><br><span class="line">                <span class="comment">// 接收下一个连接请求</span></span><br><span class="line">                server.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                Future&lt;Integer&gt; readResult = client.read(buffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    readResult.get();</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining());</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到的消息&quot;</span> + message);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">                <span class="comment">// 为了让服务器继续运行，我们需要组织main县城退出</span></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，<code>Future</code> 是一种用于表示异步计算结果的接口。它提供了一种在异步任务完成后获取结果的机制。上面的代码中使用了 <code>Future&lt;Integer&gt;</code>，它的作用是表示 <code>client.read(buffer)</code> 方法的异步读取操作的结果。</p>
<p><code>Future</code> 的作用</p>
<ul>
<li><strong>异步操作</strong>：在 <code>client.read(buffer)</code> 中，<code>read</code> 方法是异步的，这意味着它不会立即返回读取的字节数，而是立即返回一个 <code>Future</code> 对象来表示读取操作的状态。</li>
<li><strong>获取结果</strong>：通过调用 <code>Future</code> 对象的 <code>get()</code> 方法，可以等待操作完成并获得最终的读取结果。此时，如果读取操作还没有完成，<code>get()</code> 会阻塞当前线程，直到读取操作完成后返回结果。</li>
<li><strong>控制任务完成状态</strong>：<code>Future</code> 还提供了 <code>isDone()</code> 等方法，可以在不阻塞的情况下检查任务是否完成，从而让程序更灵活地处理异步操作。</li>
</ul>
<p>示例流程说明</p>
<ol>
<li>当客户端连接时，服务器会创建一个 <code>ByteBuffer</code> 来接收数据。</li>
<li><code>client.read(buffer)</code> 发起异步读取，并立即返回一个 <code>Future&lt;Integer&gt;</code>。</li>
<li>通过 <code>readResult.get()</code> 阻塞当前线程，直到读取完成。</li>
<li>一旦读取完成，代码将 <code>buffer</code> 的内容转换为字符串，并输出到控制台。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynchronousClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">AsynchronousSocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> AsynchronousSocketChannel.open();</span><br><span class="line">            Future&lt;Void&gt; connectResult = client.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">5000</span>));</span><br><span class="line">            connectResult.get();</span><br><span class="line">            </span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;哈里独家阿&quot;</span>;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            Future&lt;Integer&gt; writeResuilt = client.write(buffer);</span><br><span class="line">            writeResuilt.get();</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单聊天室代码"><a href="#简单聊天室代码" class="headerlink" title="简单聊天室代码"></a>简单聊天室代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chat2Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个selector</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;聊天室服务端启动了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端连接</span></span><br><span class="line">        AtomicReference&lt;SocketChannel&gt; clientRef = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从控制台读取输入并发送给客户端</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">sendMessageThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span>(<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)))&#123;</span><br><span class="line">               <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;输入服务器消息&quot;</span>);</span><br><span class="line">                   <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">                   <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> clientRef.get();</span><br><span class="line">                   <span class="keyword">if</span>(client != <span class="literal">null</span> &amp;&amp; client.isConnected())&#123;</span><br><span class="line">                       <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap((message + <span class="string">&quot;\n&quot;</span>).getBytes());</span><br><span class="line">                       client.write(buffer);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        sendMessageThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(readyChannels == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 接受客户端连接</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接&quot;</span>);</span><br><span class="line">                    client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    clientRef.set(client);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// 读取客户端消息</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(bytesRead &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.remaining()];</span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes).trim();</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端消息&quot;</span> + message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chat2Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个socketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个selector</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哦嗯控制台读取输入并发送给服务器端</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">senMessageThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)))&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入客户端消息&quot;</span>);;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(socketChannel.isConnected())&#123;</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap((message + <span class="string">&quot;\n&quot;</span>).getBytes());</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        senMessageThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(readyChannels == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                    <span class="comment">// 连接到服务器</span></span><br><span class="line">                    socketChannel.finishConnect();</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(<span class="string">&quot;已连接到服务器&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// 读取服务器消息</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(bytesRead &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.remaining()];</span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes).trim();</span><br><span class="line">                        System.out.println(<span class="string">&quot;服务器消息&quot;</span> + message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们了解到，Java NIO 在文件 IO 上的性能其实和传统 IO 差不多，甚至在处理大文件的时候还有些甘拜下风，但 NIO 的主要作用体现在网络 IO 上，像 Netty 框架底层其实就是 NIO，我们来做一下简单的总结吧。<br>SocketChannel（用于 TCP 连接）和 ServerSocketChannel（用于监听和接受新的 TCP 连接）可以用来替代传统的 Socket 和 ServerSocket 类，提供非阻塞模式。<br>NIO 支持阻塞和非阻塞模式。非阻塞模式允许程序在等待 I&#x2F;O 时执行其他任务，从而提高并发性能。非阻塞模式的实现依赖于 Selector，它可以监控多个通道上的 I&#x2F;O 事件。<br>NIO 支持将数据分散到多个 Buffer（Scatter）或从多个 Buffer 收集数据（Gather），提供了更高效的数据传输方式。<br>Java NIO.2 引入了 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel，这些类提供了基于回调的异步 I&#x2F;O 操作。异步套接字通道可以在完成 I&#x2F;O 操作时自动触发回调函数，从而实现高效的异步处理。</p>
<h2 id="Java-IO模型"><a href="#Java-IO模型" class="headerlink" title="Java IO模型"></a>Java IO模型</h2><p>阻塞 I&#x2F;O（Blocking I&#x2F;O）：在这种模型中，I&#x2F;O 操作是阻塞的，即执行 I&#x2F;O 操作时，线程会被阻塞，直到操作完成。在阻塞 I&#x2F;O 模型中，每个连接都需要一个线程来处理。因此，对于大量并发连接的场景，阻塞 I&#x2F;O 模型的性能较差。<br><img src="/2024/11/04/code/javanio/image-8.png"><br>非阻塞 I&#x2F;O（Non-blocking I&#x2F;O）：在这种模型中，I&#x2F;O 操作不会阻塞线程。当数据尚未准备好时，I&#x2F;O 调用会立即返回。线程可以继续执行其他任务，然后在适当的时候再次尝试执行 I&#x2F;O 操作。非阻塞 I&#x2F;O 模型允许单个线程同时处理多个连接，但可能需要在应用程序级别进行复杂的调度和管理。<br><img src="/2024/11/04/code/javanio/image-9.png"></p>
<p>在上面的两幅图中，涉及到了两个概念：内核空间和用户空间。我们之前在介绍非直接缓冲区的时候，有这样一副图片。<br><img src="/2024/11/04/code/javanio/image-10.png"></p>
<p>除了前面提到的阻塞 IO 和非阻塞 IO 模型，还有另外三种 IO 模型，分别是多路复用、信号驱动和异步 IO。</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>I&#x2F;O 多路复用（I&#x2F;O Multiplexing）模型使用操作系统提供的多路复用功能（如 select、poll、epoll 等），使得单个线程可以同时处理多个 I&#x2F;O 事件。当某个连接上的数据准备好时，操作系统会通知应用程序。这样，应用程序可以在一个线程中处理多个并发连接，而不需要为每个连接创建一个线程。</p>
<ul>
<li>select 是 Unix 系统中最早的 I&#x2F;O 多路复用技术。它允许一个线程同时监视多个文件描述符（如套接字），并等待某个文件描述符上的 I&#x2F;O 事件（如可读、可写或异常）。select 的主要问题是性能受限，特别是在处理大量文件描述符时。这是因为它使用一个位掩码来表示文件描述符集，每次调用都需要传递这个掩码，并在内核和用户空间之间进行复制。</li>
<li>poll 是对 select 的改进。它使用一个文件描述符数组而不是位掩码来表示文件描述符集。这样可以避免 select 中的性能问题。然而，poll 仍然需要遍历整个文件描述符数组，以检查每个文件描述符的状态。因此，在处理大量文件描述符时，性能仍然受限。</li>
<li>epoll 是 Linux 中的一种高性能 I&#x2F;O 多路复用技术。它通过在内核中维护一个事件表来避免遍历文件描述符数组的性能问题。当某个文件描述符上的 I&#x2F;O 事件发生时，内核会将该事件添加到事件表中。应用程序可以使用 epoll_wait 函数来获取已准备好的 I&#x2F;O 事件，而无需遍历整个文件描述符集。这种方法大大提高了在大量并发连接下的性能。<br><img src="/2024/11/04/code/javanio/image-11.png"></li>
</ul>
<p>在 Java NIO 中，I&#x2F;O 多路复用主要通过 Selector 类实现。Selector 能够监控多个 Channel（通道）上的 I&#x2F;O 事件，如连接、读取和写入。这使得一个线程可以处理多个并发连接，提高了程序的性能和可伸缩性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">    <span class="keyword">if</span> (readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端连接上了: &quot;</span> + socketChannel.getRemoteAddress());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 处理读取数据事件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 处理写入数据事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Selector 的 select() 方法等待 I&#x2F;O 事件。select() 方法会阻塞，直到至少有一个 Channel 上的事件发生。当有事件发生时，可以通过调用 selectedKeys() 方法获取已准备好进行 I&#x2F;O 操作的 Channel 的 SelectionKey 集合。</p>
<h3 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h3><p>信号驱动 I&#x2F;O（Signal-driven I&#x2F;O）模型中，应用程序可以向操作系统注册一个信号处理函数，当某个 I&#x2F;O 事件发生时，操作系统会发送一个信号通知应用程序。应用程序在收到信号后处理相应的 I&#x2F;O 事件。这种模型与非阻塞 I&#x2F;O 类似，也需要在应用程序级别进行事件管理和调度。<br><img src="/2024/11/04/code/javanio/image-12.png"></p>
<p>多路复用和信号驱动的差别主要在事件通知机制和引用场景上。</p>
<p>多路复用模型允许一个线程同时管理多个 I&#x2F;O 连接。这是通过使用特殊的系统调用（如 select、poll 和 epoll）实现的，它们能够监视多个文件描述符上的 I&#x2F;O 事件。当某个 I&#x2F;O 事件发生时，这些系统调用会返回，通知应用程序执行相应的 I&#x2F;O 操作。I&#x2F;O 多路复用模型适用于高并发、低延迟和高吞吐量的场景，因为它能够有效地减少线程数量和上下文切换开销。</p>
<p>信号驱动模型依赖于信号（如 SIGIO）来通知应用程序 I&#x2F;O 事件的发生。在这个模型中，应用程序首先设置文件描述符为信号驱动模式，并为相应的信号注册处理函数。当 I&#x2F;O 事件发生时，内核会发送一个信号给应用程序，触发信号处理函数的执行。然后，应用程序可以在信号处理函数中执行相应的 I&#x2F;O 操作。I&#x2F;O 信号驱动模型适用于低并发、低延迟和低吞吐量的场景，因为它需要为每个 I&#x2F;O 事件创建一个信号和信号处理函数。</p>
<p>Linux 的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令(api)，返回一个 file descriptor（fd，文件描述符）。而对一个Socket的读写也会有响应的描述符，称为 socket fd（Socket文件描述符），描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）。</p>
<p>在Linux下对文件的操作是利用文件描述符(file descriptor)来实现的。</p>
<h3 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h3><p>异步 I&#x2F;O（Asynchronous I&#x2F;O）模型与同步 I&#x2F;O 模型的主要区别在于，异步 I&#x2F;O 操作会在后台运行，当操作完成时，操作系统会通知应用程序。应用程序不需要等待 I&#x2F;O 操作的完成，可以继续执行其他任务。这种模型适用于处理大量并发连接，且可以简化应用程序的设计和开发。</p>
<ul>
<li>同步：在执行 I&#x2F;O 操作时，应用程序需要等待操作的完成。同步操作会导致线程阻塞，直到操作完成。同步 I&#x2F;O 包括阻塞 I&#x2F;O、非阻塞 I&#x2F;O 和 I&#x2F;O 多路复用。</li>
<li>异步：在执行 I&#x2F;O 操作时，应用程序不需要等待操作的完成。异步操作允许应用程序在 I&#x2F;O 操作进行时继续执行其他任务。异步 I&#x2F;O 模型包括信号驱动 I&#x2F;O 和异步 I&#x2F;O。<br><img src="/2024/11/04/code/javanio/image-13.png"></li>
</ul>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
          <li><a href="/categories/">Categories</a></li>
        
          <li><a href="/idea/">Idea</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-NIO-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1. Java NIO 核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">2. 主要特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java-NIO-%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">3. Java NIO 中的核心类和接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java-NIO-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">4. Java NIO 的操作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">5. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Java-NIO%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">6. Java NIO的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-%E5%92%8C%E4%BC%A0%E7%BB%9F-IO-%E5%9C%A8%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">6.1.</span> <span class="toc-text">NIO 和传统 IO 在操作文件时的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-%E5%92%8C%E4%BC%A0%E7%BB%9F-IO-%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">6.2.</span> <span class="toc-text">NIO 和传统 IO 在网络传输中的差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E3%80%81BIO%E5%92%8CAIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">NIO、BIO和AIO的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8CChannel%E9%80%9A%E9%81%93"><span class="toc-number">8.</span> <span class="toc-text">Buffer缓冲区和Channel通道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">8.1.</span> <span class="toc-text">Buffer 缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-%E9%80%9A%E9%81%93"><span class="toc-number">8.2.</span> <span class="toc-text">Channel 通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%80%9A%E9%81%93-FileChannel"><span class="toc-number">8.2.1.</span> <span class="toc-text">文件通道 FileChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">8.2.2.</span> <span class="toc-text">直接与非直接缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%96%87%E4%BB%B6%E9%80%9A%E9%81%93-AsynchronousFileChannel"><span class="toc-number">8.2.3.</span> <span class="toc-text">异步文件通道 AsynchronousFileChannel</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-NIO-%E4%B8%AD%E7%9A%84Paths-%E5%92%8C-Files"><span class="toc-number">9.</span> <span class="toc-text">Java NIO 中的Paths 和 Files</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Paths-%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">1. Paths 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Files-%E7%B1%BB"><span class="toc-number">9.1.1.</span> <span class="toc-text">2. Files 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Files-walkFileTree-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.2.</span> <span class="toc-text">Files.walkFileTree() 静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">9.1.3.</span> <span class="toc-text">搜索文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">10.</span> <span class="toc-text">NIO实现网络聊天室</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scatter-%E5%92%8C-Gather"><span class="toc-number">10.1.</span> <span class="toc-text">Scatter 和 Gather</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E9%81%93-AsynchronousSocketChannel-%E5%92%8C-AsynchronousServerSocketChannel"><span class="toc-number">10.2.</span> <span class="toc-text">异步套接字通道 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%BB%A3%E7%A0%81"><span class="toc-number">10.3.</span> <span class="toc-text">简单聊天室代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">Java IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8"><span class="toc-number">11.2.</span> <span class="toc-text">信号驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-IO"><span class="toc-number">11.3.</span> <span class="toc-text">异步 IO</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://godreams.cn/2024/11/04/code/javanio/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://godreams.cn/2024/11/04/code/javanio/&text=【Java开发】Java NIO"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://godreams.cn/2024/11/04/code/javanio/&is_video=false&description=【Java开发】Java NIO"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【Java开发】Java NIO&body=Check out this article: https://godreams.cn/2024/11/04/code/javanio/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://godreams.cn/2024/11/04/code/javanio/&title=【Java开发】Java NIO"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://godreams.cn/2024/11/04/code/javanio/&name=【Java开发】Java NIO&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://godreams.cn/2024/11/04/code/javanio/&t=【Java开发】Java NIO"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024-2025
    g0dam
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/idea/">Idea</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/g0dam">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'owner/githubrepo';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
