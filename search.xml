<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>反序列化漏洞分析笔记</title>
      <link href="/2024/09/10/WebSecurity/deserialization/"/>
      <url>/2024/09/10/WebSecurity/deserialization/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是序列化和反序列化？"><a href="#什么是序列化和反序列化？" class="headerlink" title="什么是序列化和反序列化？"></a>什么是序列化和反序列化？</h1><p>我个人的理解是：序列化是将对象转换为字节流，反序列化是将字节流转换为对象。为什么会有这些概念呢？还是来源于具体的需求，举个例子来说，比如一个公司要开发一个软件，这个软件需要保存用户的信息，那么这个信息需要持久化存储，那么这个信息怎么存储呢，这些信息可能是个在程序运行时可能是个对象，经过序列化之后，就可以存储到文件中，那么反序列化就是将存储在文件中的对象，恢复成对象，这样就可以解决对象的持久化存储的问题。</p><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><p>不管是什么语言的序列化，从概念需求出发，就可以决定出场景：数据存储、网络传输、通过特定协议读取。</p><h2 id="为什么反序列化会出现漏洞？"><a href="#为什么反序列化会出现漏洞？" class="headerlink" title="为什么反序列化会出现漏洞？"></a>为什么反序列化会出现漏洞？</h2><p>从根本原因来看，我个人感觉还是来自输入数据校验不完整，反序列化漏洞的存在应当归咎于开发者（有时候在想一些漏洞成因时，我总是想要确定下应当是谁负责任……），开发者开发应用时应当假设所有用户都是不可信的，对于所有用可能接触到的输入点都需要格外注意。就反序列化来说，一旦输入数据没有经过校验，那么反序列化的对象就可能会被恶意用户定制化，进而执行恶意代码。</p><h2 id="漏洞利用的关键"><a href="#漏洞利用的关键" class="headerlink" title="漏洞利用的关键"></a>漏洞利用的关键</h2><p>黑盒：判断出存在有序列化的数据，序列化的接口，观察恢复元数据，利用原生类构造调用链，验证是否存在<br>白盒：定位关键函数，观察序列化输入是否可控</p><h1 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="PHP反序列化漏洞"></a>PHP反序列化漏洞</h1><p>在PHP中，序列化和反序列化是将对象转换为可以存储或传输的字符串表示形式的过程，以及将这种字符串表示形式恢复为对象的过程。魔术方法（magic methods）是PHP中一些以双下划线开始的方法，它们在某些操作发生时自动被调用，例如对象的创建、销毁、调用不存在的方法等。序列化和反序列化的函数是使用<code>unserialize()</code>和<code>serialize()</code>函数，其实感觉没什么讨论的，重点先讨论下魔术方法。</p><h2 id="PHP中的魔术方法"><a href="#PHP中的魔术方法" class="headerlink" title="PHP中的魔术方法"></a>PHP中的魔术方法</h2><p>以下内容参考自：<a href="https://segmentfault.com/a/1190000007250604">PHP之十六个魔术方法详解</a></p><ul><li>__construct()，类的构造函数</li><li>__destruct()，类的析构函数</li><li>__call()，在对象中调用一个不可访问方法时调用</li><li>__callStatic()，用静态方式中调用一个不可访问方法时调用</li><li>__get()，获得一个类的成员变量时调用</li><li>__set()，设置一个类的成员变量时调用</li><li>__isset()，当对不可访问属性调用isset()或empty()时调用</li><li>__unset()，当对不可访问属性调用unset()时被调用。</li><li>__sleep()，执行serialize()时，先会调用这个函数</li><li>__wakeup()，执行unserialize()时，先会调用这个函数</li><li>__toString()，类被当成字符串时的回应方法</li><li>__invoke()，调用函数的方式调用一个对象时的回应方法</li><li>__set_state()，调用var_export()导出类时，此静态方法会被调用。</li><li>__clone()，当对象复制完成时调用</li><li>__autoload()，尝试加载未定义的类</li><li>__debugInfo()，打印所需调试信息</li></ul><p>其中，__toString()用的比较多，它的触发场景可以总结为下面这些：</p><ul><li>echo($obj)&#x2F;print($obj)打印时会触发 </li><li>反序列化对象与字符串连接时 </li><li>反序列化对象参与格式化字符串时 </li><li>反序列化对象与字符串进行&#x3D;&#x3D;比较时（PHP进行&#x3D;&#x3D;比较的时候会转换参数类型） </li><li>反序列化对象参与格式化SQL语句，绑定参数时 </li><li>反序列化对象在经过php字符串处理函数，如strlen()、strops()、strcmp()、addslashes()等 </li><li>在in_array()方法中，第一个参数时反序列化对象，第二个参数的数组中有__toString()返回的字符串的时候__toString()会被调用 </li><li>反序列化的对象作为class_exists()的参数的时候</li></ul><p>从序列化到反序列化这几个函数的执行过程是：<br><code>__construct()</code> -&gt;<code>__sleep()</code> -&gt; <code>__wakeup()</code> -&gt; <code>__toString()</code> -&gt; <code>__destruct()</code></p><img src="/2024/09/10/WebSecurity/deserialization/image.png" class="" title="Alt text"><p>图中显示的是很经典的图，展示了对象序列化后的内容，其中：</p><ul><li>a - array 数组型</li><li>b - boolean 布尔型</li><li>d - double 浮点型</li><li>i - integer 整数型</li><li>o - common object 共同对象</li><li>r - objec reference 对象引用</li><li>s - non-escaped binary string 非转义的二进制字符串</li><li>S - escaped binary string 转义的二进制字符串</li><li>C - custom object 自定义对象</li><li>O - class 对象</li><li>N - null 空</li><li>R - pointer reference 指针引用</li><li>U - unicode string Unicode 编码的字符串</li></ul><p>PHP序列化需注意以下几点：</p><ol><li>只序列化属性：PHP的序列化机制默认只序列化对象的公共（public）和受保护（protected）属性。私有（private）属性不会被序列化，除非在类的 __sleep() 魔术方法中明确指定。</li><li>类定义必须可用：反序列化对象时，必须确保定义该对象的类在当前作用域中可用。如果类定义不存在，反序列化将失败，并且可能产生警告或错误。</li><li>控制属性：攻击者如果能够控制序列化数据中的属性值，可能会尝试利用这些属性来触发类的其他方法或执行不安全的操作。</li></ol><h3 id="实战漏洞分析"><a href="#实战漏洞分析" class="headerlink" title="实战漏洞分析"></a>实战漏洞分析</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 反序列化漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文精读】App’s Auto-Login Function Security Testing via Android OS-Level Virtualization</title>
      <link href="/2024/09/10/PaperReading/Auto-Login/"/>
      <url>/2024/09/10/PaperReading/Auto-Login/</url>
      
        <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>本文研究的问题是APP账号自动登录，首先刚看到题目我以为是那种手机上都会有自动输入账号密码的机制，读了文章之后了解到这里说的自动登录是登录状态的保持，比如微信，我们只需要在刚下载微信时输入账号密码进行登录，之后每次即便是关掉微信进程，也是一打开就是自动登录的，这也就省去了用户频繁输入账号和口令的麻烦。然而，在实际使用中，它易受到“data-clone attack”的威胁： 如果自动登录依赖的数据存储在本地，它可能会被攻击者克隆，导致攻击者可以突破登录设备数量限制或秘密登录受害者的帐户，从而损害APP运营者的合法权益或侵犯用户隐私和数据安全。对此，业界提出了设备一致性检查方案，只要发现APP运行设备环境发生变化，APP将禁止自动登录进而阻止克隆攻击。针对该问题，本文进一步研究发现该方案无法完全防御“data-clone attack”。该团队提出了一个具有良好透明性的虚拟化方案VPDroid， 可定制攻击所需的设备环境，以进行App自动登录的安全测试。该研究对应用市场中234个主流APP进行了测试，结果表明，通过VPDroid可有效绕过被测APP的一致性检查机制。在该成果的研究过程中，该团队发现了系列安全漏洞，近20个厂商对提交的漏洞给予了确认（其中包括1个CVE和近10项CNVD漏洞成果）。</p><p>具体什么是自动登录呢，如下图是我在作者的另一篇论文中找到的图片，可以看到当前已有设备登录账号，在另一手机登陆时会弹出仅能登录一个设备的提示。在安卓手机中，app通常使用用户登录凭证来实现自动登录，在首次登录成功之后，app将凭证数据保存在本地存储当中，下次登陆前进行验证，安卓提供了四种存储机制包括内部存储、外部存储、共享存储、数据库存储。相应的app数据会存储在对应路径当中，一般其它的应用是无法访问的。要实现克隆的话不仅需要克隆应用本身资源，为了防止这样的克隆行为，业界的解决方案是检查设备一致性，如设备电话号、序列号等信息，此类行为可能可以使用Xposed等框架hook相关函数进行绕过，但很多app也会有反调试措施，而且之前的相关工作当中仅hook了13个相关的标识信息，但本文通过调研发现了103个有关设备标识的信息。</p><p>本文通过定制了一个安卓虚拟机系统来实现了对设备标识的定制化修改，该修改对于app来说是透明的。Cells是一个轻量的安卓虚拟机系统，可以直接与硬件进行交互，他的主要机制是创建了一个独立的虚拟机命名空间，以此实现同真机系统的隔离，以及不同系统间的隔离，但是Cells也有很多局限性，它的灵活性弱，对新版本的安卓系统并不支持，同时缺少对蓝牙、GPS等设备的支持，而且对于app来说，可以发现Cells虚拟机的指纹信息，也就是说可以发现当前设备是虚拟机。</p><p>本文在Cells的基础上进行定制化，为了实现对app克隆的攻击模型，虚拟机需要满足两个条件，第一点是需要直接能够接触到硬件，第二点是可以定制化系统参数并且对app而言该操作是透明的。为了实现这些目标，本文主要采取两个方式，首先是针对在安卓ServiceManager中定义的服务，采用binder机制进行通信，binder机制是安卓系统引入的进程间通信的一种机制。第二种方法是，对于没有在ServiceManager中定义的服务，采用和真机交互的方式，设置通信代理。（RIL是一种和电话运营商网络交互的功能接口，RILD是在C++层的接口）</p><p>VPDroid系统整体概况图如图所示，虚拟出的安卓设备独立于主机，并可实现其中的参数定制。</p><p>那么怎么具体实现参数定制化呢，VPDroid提供了一个定制文件，修改其中的文件信息便可实现定制，对于安卓系统的参数信息，只需要将其中定制信息初始化在虚拟机内存中即可，对于用户层和内核层的定制化，则需要将其初始化在真机内存中。</p><p>本文采用了应用商店排名靠前的234个应用进行实验，在VPDroid中所有app都能实现绕过，作者也提出了建议，不要将认证凭证保存在本地、或者采用可信执行环境，但这样的开销也会加大，影响用户体验，本文最后也指出了VPDroid对于经root的用户来说还不是透明的，因为在采用代理通信时，VPDroid并未直接与RILD通信，也存在有相应的指纹信息。</p><h1 id="Professional-term"><a href="#Professional-term" class="headerlink" title="Professional term"></a>Professional term</h1><ul><li>original equipment manufacturer (OEM)（原始设备生产商）：</li><li>app克隆：深入挖掘APP克隆实验 - FreeBuf网络安全行业门户 Android 手机克隆&#x2F;一键换机原理初探_IT先森的博客-CSDN博客_手机克隆原理</li><li>Binder：安卓中进程间通信的一种机制 SourceAnalysis-1&#x2F;Binder源码分析.md at master · VPDroid&#x2F;SourceAnalysis-1 (github.com)</li><li>SELinux：SELinux 属于MAC的具体实现，增强了Linux系统的安全性。MAC机制的特点在于，资源的拥有者，并不能决定谁可以接入到资源。具体决定是否可以接入到资源，是基于安全策略。而安全策略则是有一系列的接入规则组成，并仅有特定权限的用户有权限操作安全策略</li><li>Android RIL概述：和电话运营商网络交互的功能接口Android RIL概述-CSDN博客</li></ul><h1 id="Thesaurus"><a href="#Thesaurus" class="headerlink" title="Thesaurus"></a>Thesaurus</h1><ul><li>client-side tampering vulnerabilities（客户端篡改漏洞）：In this paper, we focus on the security risk caused by mobile apps’ auto-login functions, which belongs to client-side tampering vulnerabilities.</li><li>hassle（麻烦）：It avoids the hassle of retyping user ID and password in a small keyboard when reaccessing the app.</li><li>In a nutshell（简而言之）：In a nutshell, we make the following three significant contributions.</li><li>backends（后端）：They exploit an entire class of apps that only rely on device-public information to authenticate the user to their backends.</li><li>seamlessly（无缝地）：For example, Smart Switch can seamlessly transfer app private data and home layouts between Galaxy devices, and it is similar for other OEM-made clone apps.</li><li>jeopardy（危险）：As a result, the user’s sensitive data will be in jeopardy without raising suspicion.</li><li>citation（引文）：The citation [19] provides more details to advocate the subscription-based app economy. For the smart home apps, we also purchase related smart home devices, including one smart lock, two security - cameras, and one smart light bulb, to test whether we can control them after launching a data-clone attack.</li><li>imperceptible（察觉不到的）：User-mode apps in the VP are imperceptible to the change of device; this requires our virtualization and device-attribute customization functions are invisible to user-mode apps running in - the VP.</li><li>proprietary（特有的，专有的）：some hardware vendors provide proprietary software</li><li>pseudo（假的）：The Binder driver is a custom pseudo driver with no corresponding physical device.</li><li>To the best of our knowledge（据我们所知）：To the best of our knowledge, VPDroid offers the most comprehensive Android device-attribute editing options so far.</li></ul><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><p>GitHub - VPDroid&#x2F;Dev: VPDroid is a lightweight Android OS-level virtualization architecture</p><p>​</p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文精读 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/09/10/hello-world/"/>
      <url>/2024/09/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
